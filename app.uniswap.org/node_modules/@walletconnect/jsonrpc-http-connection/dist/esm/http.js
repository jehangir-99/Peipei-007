import{EventEmitter}from"events";import fetch from"cross-fetch";import{safeJsonParse,safeJsonStringify}from"@walletconnect/safe-json";import{formatJsonRpcError,isHttpUrl,parseConnectionError}from"@walletconnect/jsonrpc-utils";const DEFAULT_HTTP_HEADERS={Accept:"application/json","Content-Type":"application/json"},DEFAULT_HTTP_METHOD="POST",DEFAULT_FETCH_OPTS={headers:DEFAULT_HTTP_HEADERS,method:"POST"},EVENT_EMITTER_MAX_LISTENERS_DEFAULT=10;export class HttpConnection{constructor(url,disableProviderPing=!1){if(this.url=url,this.disableProviderPing=disableProviderPing,this.events=new EventEmitter,this.isAvailable=!1,this.registering=!1,!isHttpUrl(url))throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);this.url=url,this.disableProviderPing=disableProviderPing}get connected(){return this.isAvailable}get connecting(){return this.registering}on(event,listener){this.events.on(event,listener)}once(event,listener){this.events.once(event,listener)}off(event,listener){this.events.off(event,listener)}removeListener(event,listener){this.events.removeListener(event,listener)}async open(url=this.url){await this.register(url)}async close(){if(!this.isAvailable)throw new Error("Connection already closed");this.onClose()}async send(payload,context){this.isAvailable||await this.register();try{const body=safeJsonStringify(payload),res=await fetch(this.url,Object.assign(Object.assign({},DEFAULT_FETCH_OPTS),{body:body})),data=await res.json();this.onPayload({data:data})}catch(e){this.onError(payload.id,e)}}async register(url=this.url){if(!isHttpUrl(url))throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);if(this.registering){const currentMaxListeners=this.events.getMaxListeners();return(this.events.listenerCount("register_error")>=currentMaxListeners||this.events.listenerCount("open")>=currentMaxListeners)&&this.events.setMaxListeners(currentMaxListeners+1),new Promise(((resolve,reject)=>{this.events.once("register_error",(error=>{this.resetMaxListeners(),reject(error)})),this.events.once("open",(()=>{if(this.resetMaxListeners(),void 0===this.isAvailable)return reject(new Error("HTTP connection is missing or invalid"));resolve()}))}))}this.url=url,this.registering=!0;try{if(!this.disableProviderPing){const body=safeJsonStringify({id:1,jsonrpc:"2.0",method:"test",params:[]});await fetch(url,Object.assign(Object.assign({},DEFAULT_FETCH_OPTS),{body:body}))}this.onOpen()}catch(e){const error=this.parseError(e);throw this.events.emit("register_error",error),this.onClose(),error}}onOpen(){this.isAvailable=!0,this.registering=!1,this.events.emit("open")}onClose(){this.isAvailable=!1,this.registering=!1,this.events.emit("close")}onPayload(e){if(void 0===e.data)return;const payload="string"==typeof e.data?safeJsonParse(e.data):e.data;this.events.emit("payload",payload)}onError(id,e){const error=this.parseError(e),message=error.message||error.toString(),payload=formatJsonRpcError(id,message);this.events.emit("payload",payload)}parseError(e,url=this.url){return parseConnectionError(e,url,"HTTP")}resetMaxListeners(){this.events.getMaxListeners()>10&&this.events.setMaxListeners(10)}}export default HttpConnection;