import Zt,{EventEmitter as L}from"events";import ei from"@walletconnect/keyvaluestorage";import{HEARTBEAT_EVENTS as G,HeartBeat as ti}from"@walletconnect/heartbeat";import{generateChildLogger as b,getLoggerContext as w,pino as Ee,getDefaultLoggerOptions as we}from"@walletconnect/logger";import{IMessageTracker as ii,IPublisher as si,ISubscriber as ri,IRelayer as ni,IStore as oi,IJsonRpcHistory as ai,IExpirer as hi,IVerify as ci,IEchoClient as li,ICore as ui}from"@walletconnect/types";import{safeJsonStringify as di,safeJsonParse as gi}from"@walletconnect/safe-json";import*as Y from"@walletconnect/relay-auth";import{getInternalError as c,mapToObj as ve,objToMap as Ie,generateKeyPair as pi,generateRandomBytes32 as se,deriveSymKey as Di,hashKey as yi,validateEncoding as mi,isTypeOneEnvelope as Ce,encrypt as bi,validateDecoding as fi,decrypt as Ei,deserialize as _e,decodeTypeByte as wi,BASE16 as vi,hashMessage as re,getRelayProtocolName as ne,createExpiringPromise as M,getRelayProtocolApi as H,isUndefined as oe,getSdkError as K,isValidArray as Ii,isNode as ae,getBundleId as Ci,isOnline as Re,formatRelayRpcUrl as _i,subscribeToNetworkChange as Ri,isProposalStruct as Ti,isSessionStruct as Si,TYPE_1 as Pi,calcExpiry as J,formatUri as xi,parseUri as Te,createDelayedPromise as Oi,engineEvent as he,isExpired as Se,isValidParams as ce,isValidUrl as Ai,isValidString as zi,parseExpirerTarget as Ni,formatTopicTarget as Ui,formatIdTarget as Li,isReactNative as $i,isBrowser as Fi}from"@walletconnect/utils";import{toString as ki}from"uint8arrays";import{ONE_DAY as $,SIX_HOURS as Mi,ONE_SECOND as X,THIRTY_DAYS as W,FIVE_SECONDS as Pe,THIRTY_SECONDS as le,toMiliseconds as R,ONE_MINUTE as ue,Watch as Ki,FIVE_MINUTES as xe}from"@walletconnect/time";import{JsonRpcProvider as Bi}from"@walletconnect/jsonrpc-provider";import{getBigIntRpcId as Oe,isJsonRpcRequest as Ae,isJsonRpcResponse as ze,formatJsonRpcResult as Ne,formatJsonRpcRequest as Ue,formatJsonRpcError as Vi,isJsonRpcResult as qi,isJsonRpcError as Le}from"@walletconnect/jsonrpc-utils";import ji from"@walletconnect/jsonrpc-ws-connection";import Gi from"lodash.isequal";import Yi from"isomorphic-unfetch";function Hi(n,e){if(n.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),i=0;i<t.length;i++)t[i]=255;for(var s=0;s<n.length;s++){var r=n.charAt(s),o=r.charCodeAt(0);if(255!==t[o])throw new TypeError(r+" is ambiguous");t[o]=s}var a=n.length,h=n.charAt(0),l=Math.log(a)/Math.log(256),d=Math.log(256)/Math.log(a);function m(u){if("string"!=typeof u)throw new TypeError("Expected String");if(0===u.length)return new Uint8Array;var p=0;if(" "!==u[p]){for(var C=0,D=0;u[p]===h;)C++,p++;for(var P=(u.length-p)*l+1>>>0,x=new Uint8Array(P);u[p];){var E=t[u.charCodeAt(p)];if(255===E)return;for(var O=0,N=P-1;(0!==E||O<D)&&-1!==N;N--,O++)E+=a*x[N]>>>0,x[N]=E%256>>>0,E=E/256>>>0;if(0!==E)throw new Error("Non-zero carry");D=O,p++}if(" "!==u[p]){for(var _=P-D;_!==P&&0===x[_];)_++;for(var A=new Uint8Array(C+(P-_)),j=C;_!==P;)A[j++]=x[_++];return A}}}return{encode:function(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===u.length)return"";for(var p=0,C=0,D=0,P=u.length;D!==P&&0===u[D];)D++,p++;for(var x=(P-D)*d+1>>>0,E=new Uint8Array(x);D!==P;){for(var O=u[D],N=0,_=x-1;(0!==O||N<C)&&-1!==_;_--,N++)O+=256*E[_]>>>0,E[_]=O%a>>>0,O=O/a>>>0;if(0!==O)throw new Error("Non-zero carry");C=N,D++}for(var A=x-C;A!==x&&0===E[A];)A++;for(var j=h.repeat(p);A<x;++A)j+=n.charAt(E[A]);return j},decodeUnsafe:m,decode:function(u){var p=m(u);if(p)return p;throw new Error(`Non-${e} character`)}}}var Ji=Hi,Xi=Ji;const $e=n=>{if(n instanceof Uint8Array&&"Uint8Array"===n.constructor.name)return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")},Wi=n=>(new TextEncoder).encode(n),Qi=n=>(new TextDecoder).decode(n);class Zi{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class es{constructor(e,t,i){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return Fe(this,e)}}class ts{constructor(e){this.decoders=e}or(e){return Fe(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Fe=(n,e)=>new ts({...n.decoders||{[n.prefix]:n},...e.decoders||{[e.prefix]:e}});class is{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new Zi(e,t,i),this.decoder=new es(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const Q=({name:n,prefix:e,encode:t,decode:i})=>new is(n,e,t,i),B=({prefix:n,name:e,alphabet:t})=>{const{encode:i,decode:s}=Xi(t,e);return Q({prefix:n,name:e,encode:i,decode:r=>$e(s(r))})},ss=(n,e,t,i)=>{const s={};for(let d=0;d<e.length;++d)s[e[d]]=d;let r=n.length;for(;"="===n[r-1];)--r;const o=new Uint8Array(r*t/8|0);let a=0,h=0,l=0;for(let d=0;d<r;++d){const g=s[n[d]];if(void 0===g)throw new SyntaxError(`Non-${i} character`);h=h<<t|g,a+=t,a>=8&&(a-=8,o[l++]=255&h>>a)}if(a>=t||255&h<<8-a)throw new SyntaxError("Unexpected end of data");return o},rs=(n,e,t)=>{const i="="===e[e.length-1],s=(1<<t)-1;let r="",o=0,a=0;for(let h=0;h<n.length;++h)for(a=a<<8|n[h],o+=8;o>t;)o-=t,r+=e[s&a>>o];if(o&&(r+=e[s&a<<t-o]),i)for(;r.length*t&7;)r+="=";return r},y=({name:n,prefix:e,bitsPerChar:t,alphabet:i})=>Q({prefix:e,name:n,encode:s=>rs(s,i,t),decode:s=>ss(s,i,t,n)}),ns=Q({prefix:"\0",name:"identity",encode:n=>Qi(n),decode:n=>Wi(n)});var os=Object.freeze({__proto__:null,identity:ns});const as=y({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var hs=Object.freeze({__proto__:null,base2:as});const cs=y({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var ls=Object.freeze({__proto__:null,base8:cs});const us=B({prefix:"9",name:"base10",alphabet:"0123456789"});var ds=Object.freeze({__proto__:null,base10:us});const gs=y({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),ps=y({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Ds=Object.freeze({__proto__:null,base16:gs,base16upper:ps});const ys=y({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),ms=y({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),bs=y({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),fs=y({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Es=y({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),ws=y({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),vs=y({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Is=y({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Cs=y({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var _s=Object.freeze({__proto__:null,base32:ys,base32upper:ms,base32pad:bs,base32padupper:fs,base32hex:Es,base32hexupper:ws,base32hexpad:vs,base32hexpadupper:Is,base32z:Cs});const Rs=B({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Ts=B({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Ss=Object.freeze({__proto__:null,base36:Rs,base36upper:Ts});const Ps=B({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),xs=B({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Os=Object.freeze({__proto__:null,base58btc:Ps,base58flickr:xs});const As=y({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),zs=y({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Ns=y({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Us=y({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Ls=Object.freeze({__proto__:null,base64:As,base64pad:zs,base64url:Ns,base64urlpad:Us});const ke=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),$s=ke.reduce(((n,e,t)=>(n[t]=e,n)),[]),Fs=ke.reduce(((n,e,t)=>(n[e.codePointAt(0)]=t,n)),[]);function ks(n){return n.reduce(((e,t)=>e+=$s[t]),"")}function Ms(n){const e=[];for(const t of n){const i=Fs[t.codePointAt(0)];if(void 0===i)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const Ks=Q({prefix:"ðŸš€",name:"base256emoji",encode:ks,decode:Ms});var Bs=Object.freeze({__proto__:null,base256emoji:Ks}),Vs=Ke,Me=128,qs=127,js=~qs,Gs=Math.pow(2,31);function Ke(n,e,t){e=e||[];for(var i=t=t||0;n>=Gs;)e[t++]=255&n|Me,n/=128;for(;n&js;)e[t++]=255&n|Me,n>>>=7;return e[t]=0|n,Ke.bytes=t-i+1,e}var Ys=de,Hs=128,Be=127;function de(n,i){var o,t=0,s=0,r=i=i||0,a=n.length;do{if(r>=a)throw de.bytes=0,new RangeError("Could not decode varint");o=n[r++],t+=s<28?(o&Be)<<s:(o&Be)*Math.pow(2,s),s+=7}while(o>=Hs);return de.bytes=r-i,t}var Js=Math.pow(2,7),Xs=Math.pow(2,14),Ws=Math.pow(2,21),Qs=Math.pow(2,28),Zs=Math.pow(2,35),er=Math.pow(2,42),tr=Math.pow(2,49),ir=Math.pow(2,56),sr=Math.pow(2,63),rr=function(n){return n<Js?1:n<Xs?2:n<Ws?3:n<Qs?4:n<Zs?5:n<er?6:n<tr?7:n<ir?8:n<sr?9:10},nr={encode:Vs,decode:Ys,encodingLength:rr},Ve=nr;const qe=(n,e,t=0)=>(Ve.encode(n,e,t),e),je=n=>Ve.encodingLength(n),ge=(n,e)=>{const t=e.byteLength,i=je(n),s=i+je(t),r=new Uint8Array(s+t);return qe(n,r,0),qe(t,r,i),r.set(e,s),new or(n,t,e,r)};class or{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s}}const Ge=({name:n,code:e,encode:t})=>new ar(n,e,t);class ar{constructor(e,t,i){this.name=e,this.code=t,this.encode=i}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?ge(this.code,t):t.then((i=>ge(this.code,i)))}throw Error("Unknown type, must be binary type")}}const Ye=n=>async e=>new Uint8Array(await crypto.subtle.digest(n,e)),hr=Ge({name:"sha2-256",code:18,encode:Ye("SHA-256")}),cr=Ge({name:"sha2-512",code:19,encode:Ye("SHA-512")});var lr=Object.freeze({__proto__:null,sha256:hr,sha512:cr});const He=0,ur="identity",Je=$e,dr=n=>ge(0,Je(n)),gr={code:0,name:ur,encode:Je,digest:dr};var pr=Object.freeze({__proto__:null,identity:gr});new TextEncoder,new TextDecoder;const Xe={...os,...hs,...ls,...ds,...Ds,..._s,...Ss,...Os,...Ls,...Bs};function We(n){return null!=globalThis.Buffer?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):n}function Dr(n=0){return null!=globalThis.Buffer&&null!=globalThis.Buffer.allocUnsafe?We(globalThis.Buffer.allocUnsafe(n)):new Uint8Array(n)}function Qe(n,e,t,i){return{name:n,prefix:e,encoder:{name:n,prefix:e,encode:t},decoder:{decode:i}}}const Ze=Qe("utf8","u",(n=>"u"+new TextDecoder("utf8").decode(n)),(n=>(new TextEncoder).encode(n.substring(1)))),pe=Qe("ascii","a",(n=>{let e="a";for(let t=0;t<n.length;t++)e+=String.fromCharCode(n[t]);return e}),(n=>{const e=Dr((n=n.substring(1)).length);for(let t=0;t<n.length;t++)e[t]=n.charCodeAt(t);return e})),yr={utf8:Ze,"utf-8":Ze,hex:Xe.base16,latin1:pe,ascii:pe,binary:pe,...Xe};function mr(n,e="utf8"){const t=yr[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return"utf8"!==e&&"utf-8"!==e||null==globalThis.Buffer||null==globalThis.Buffer.from?t.decoder.decode(`${t.prefix}${n}`):We(globalThis.Buffer.from(n,"utf-8"))}const De="wc",et=2,Z="core",z=`${De}@2:${Z}:`,tt={name:Z,logger:"error"},it={database:":memory:"},st="crypto",ye="client_ed25519_seed",rt=$,nt="keychain",ot="0.3",at="messages",ht="0.3",ct=Mi,lt="publisher",ut="irn",dt="error",me="wss://relay.walletconnect.com",be="wss://relay.walletconnect.org",gt="relayer",v={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},pt="_subscription",f={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},Dt=X,br={database:":memory:"},yt="2.11.3",mt=1e4,bt="0.3",ft="WALLETCONNECT_CLIENT_ID",T={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},fr=W,Et="subscription",wt="0.3",vt=1e3*Pe,It="pairing",Ct="0.3",Er=W,F={wc_pairingDelete:{req:{ttl:$,prompt:!1,tag:1e3},res:{ttl:$,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:le,prompt:!1,tag:1002},res:{ttl:le,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:$,prompt:!1,tag:0},res:{ttl:$,prompt:!1,tag:0}}},V={create:"pairing_create",expire:"pairing_expire",delete:"pairing_delete",ping:"pairing_ping"},S={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},_t="history",Rt="0.3",Tt="expirer",I={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},St="0.3",wr=$,ee="verify-api",k="https://verify.walletconnect.com",te="https://verify.walletconnect.org",Pt=[k,te],xt="echo",Ot="https://echo.walletconnect.com";class At{constructor(e,t){this.core=e,this.logger=t,this.keychain=new Map,this.name=nt,this.version=ot,this.initialized=!1,this.storagePrefix=z,this.init=async()=>{if(!this.initialized){const i=await this.getKeyChain();typeof i<"u"&&(this.keychain=i),this.initialized=!0}},this.has=i=>(this.isInitialized(),this.keychain.has(i)),this.set=async(i,s)=>{this.isInitialized(),this.keychain.set(i,s),await this.persist()},this.get=i=>{this.isInitialized();const s=this.keychain.get(i);if(typeof s>"u"){const{message:r}=c("NO_MATCHING_KEY",`${this.name}: ${i}`);throw new Error(r)}return s},this.del=async i=>{this.isInitialized(),this.keychain.delete(i),await this.persist()},this.core=e,this.logger=b(t,this.name)}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,ve(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?Ie(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class zt{constructor(e,t,i){this.core=e,this.logger=t,this.name=st,this.initialized=!1,this.init=async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)},this.hasKeys=s=>(this.isInitialized(),this.keychain.has(s)),this.getClientId=async()=>{this.isInitialized();const s=await this.getClientSeed(),r=Y.generateKeyPair(s);return Y.encodeIss(r.publicKey)},this.generateKeyPair=()=>{this.isInitialized();const s=pi();return this.setPrivateKey(s.publicKey,s.privateKey)},this.signJWT=async s=>{this.isInitialized();const r=await this.getClientSeed(),o=Y.generateKeyPair(r),a=se(),h=rt;return await Y.signJWT(a,s,h,o)},this.generateSharedKey=(s,r,o)=>{this.isInitialized();const a=this.getPrivateKey(s),h=Di(a,r);return this.setSymKey(h,o)},this.setSymKey=async(s,r)=>{this.isInitialized();const o=r||yi(s);return await this.keychain.set(o,s),o},this.deleteKeyPair=async s=>{this.isInitialized(),await this.keychain.del(s)},this.deleteSymKey=async s=>{this.isInitialized(),await this.keychain.del(s)},this.encode=async(s,r,o)=>{this.isInitialized();const a=mi(o),h=di(r);if(Ce(a)){const m=a.senderPublicKey,U=a.receiverPublicKey;s=await this.generateSharedKey(m,U)}const l=this.getSymKey(s),{type:d,senderPublicKey:g}=a;return bi({type:d,symKey:l,message:h,senderPublicKey:g})},this.decode=async(s,r,o)=>{this.isInitialized();const a=fi(r,o);if(Ce(a)){const h=a.receiverPublicKey,l=a.senderPublicKey;s=await this.generateSharedKey(h,l)}try{const h=this.getSymKey(s),l=Ei({symKey:h,encoded:r});return gi(l)}catch(h){this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`),this.logger.error(h)}},this.getPayloadType=s=>{const r=_e(s);return wi(r.type)},this.getPayloadSenderPublicKey=s=>{const r=_e(s);return r.senderPublicKey?ki(r.senderPublicKey,vi):void 0},this.core=e,this.logger=b(t,this.name),this.keychain=i||new At(this.core,this.logger)}get context(){return w(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(ye)}catch{e=se(),await this.keychain.set(ye,e)}return mr(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Nt extends ii{constructor(e,t){super(e,t),this.logger=e,this.core=t,this.messages=new Map,this.name=at,this.version=ht,this.initialized=!1,this.storagePrefix=z,this.init=async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const i=await this.getRelayerMessages();typeof i<"u"&&(this.messages=i),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(i){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(i)}finally{this.initialized=!0}}},this.set=async(i,s)=>{this.isInitialized();const r=re(s);let o=this.messages.get(i);return typeof o>"u"&&(o={}),typeof o[r]<"u"||(o[r]=s,this.messages.set(i,o),await this.persist()),r},this.get=i=>{this.isInitialized();let s=this.messages.get(i);return typeof s>"u"&&(s={}),s},this.has=(i,s)=>{this.isInitialized();return typeof this.get(i)[re(s)]<"u"},this.del=async i=>{this.isInitialized(),this.messages.delete(i),await this.persist()},this.logger=b(e,this.name),this.core=t}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,ve(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?Ie(e):void 0}async persist(){await this.setRelayerMessages(this.messages)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class vr extends si{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.events=new L,this.name=lt,this.queue=new Map,this.publishTimeout=R(ue),this.failedPublishTimeout=R(X),this.needsTransportRestart=!1,this.publish=async(i,s,r)=>{var o;this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:r}});const a=r?.ttl||ct,h=ne(r),l=r?.prompt||!1,d=r?.tag||0,g=r?.id||Oe().toString(),m={topic:i,message:s,opts:{ttl:a,relay:h,prompt:l,tag:d,id:g}},U=`Failed to publish payload, please try again. id:${g} tag:${d}`,u=Date.now();let p,C=1;try{for(;void 0===p;){if(Date.now()-u>this.publishTimeout)throw new Error(U);this.logger.trace({id:g,attempts:C},`publisher.publish - attempt ${C}`),p=await await M(this.rpcPublish(i,s,a,h,l,d,g).catch((D=>this.logger.warn(D))),this.publishTimeout,U),C++,p||await new Promise((D=>setTimeout(D,this.failedPublishTimeout)))}this.relayer.events.emit(v.publish,m),this.logger.debug("Successfully Published Payload"),this.logger.trace({type:"method",method:"publish",params:{id:g,topic:i,message:s,opts:r}})}catch(D){if(this.logger.debug("Failed to Publish Payload"),this.logger.error(D),null!=(o=r?.internal)&&o.throwOnFailedPublish)throw D;this.queue.set(g,m)}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.relayer=e,this.logger=b(t,this.name),this.registerEventListeners()}get context(){return w(this.logger)}rpcPublish(e,t,i,s,r,o,a){var h,l,d,g;const m={method:H(s.protocol).publish,params:{topic:e,message:t,ttl:i,prompt:r,tag:o},id:a};return oe(null==(h=m.params)?void 0:h.prompt)&&(null==(l=m.params)||delete l.prompt),oe(null==(d=m.params)?void 0:d.tag)&&(null==(g=m.params)||delete g.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:m}),this.relayer.request(m)}removeRequestFromQueue(e){this.queue.delete(e)}checkQueue(){this.queue.forEach((async e=>{const{topic:t,message:i,opts:s}=e;await this.publish(t,i,s)}))}registerEventListeners(){this.relayer.core.heartbeat.on(G.pulse,(()=>{if(this.needsTransportRestart)return this.needsTransportRestart=!1,void this.relayer.events.emit(v.connection_stalled);this.checkQueue()})),this.relayer.on(v.message_ack,(e=>{this.removeRequestFromQueue(e.id.toString())}))}}class Ir{constructor(){this.map=new Map,this.set=(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t])},this.get=e=>this.map.get(e)||[],this.exists=(e,t)=>this.get(e).includes(t),this.delete=(e,t)=>{if(typeof t>"u")return void this.map.delete(e);if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter((r=>r!==t));s.length?this.map.set(e,s):this.map.delete(e)},this.clear=()=>{this.map.clear()}}get topics(){return Array.from(this.map.keys())}}var Cr=Object.defineProperty,_r=Object.defineProperties,Rr=Object.getOwnPropertyDescriptors,Ut=Object.getOwnPropertySymbols,Tr=Object.prototype.hasOwnProperty,Sr=Object.prototype.propertyIsEnumerable,Lt=(n,e,t)=>e in n?Cr(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,q=(n,e)=>{for(var t in e||(e={}))Tr.call(e,t)&&Lt(n,t,e[t]);if(Ut)for(var t of Ut(e))Sr.call(e,t)&&Lt(n,t,e[t]);return n},fe=(n,e)=>_r(n,Rr(e));class $t extends ri{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.subscriptions=new Map,this.topicMap=new Ir,this.events=new L,this.name=Et,this.version=wt,this.pending=new Map,this.cached=[],this.initialized=!1,this.pendingSubscriptionWatchLabel="pending_sub_watch_label",this.pollingInterval=20,this.storagePrefix=z,this.subscribeTimeout=R(ue),this.restartInProgress=!1,this.batchSubscribeTopicsLimit=500,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),this.registerEventListeners(),this.clientId=await this.relayer.core.crypto.getClientId())},this.subscribe=async(i,s)=>{await this.restartToComplete(),this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}});try{const r=ne(s),o={topic:i,relay:r};this.pending.set(i,o);const a=await this.rpcSubscribe(i,r);return"string"==typeof a&&(this.onSubscribe(a,o),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}})),a}catch(r){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(r),r}},this.unsubscribe=async(i,s)=>{await this.restartToComplete(),this.isInitialized(),typeof s?.id<"u"?await this.unsubscribeById(i,s.id,s):await this.unsubscribeByTopic(i,s)},this.isSubscribed=async i=>{if(this.topics.includes(i))return!0;const s=`${this.pendingSubscriptionWatchLabel}_${i}`;return await new Promise(((r,o)=>{const a=new Ki;a.start(s);const h=setInterval((()=>{!this.pending.has(i)&&this.topics.includes(i)&&(clearInterval(h),a.stop(s),r(!0)),a.elapsed(s)>=vt&&(clearInterval(h),a.stop(s),o(new Error("Subscription resolution timeout")))}),this.pollingInterval)})).catch((()=>!1))},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.start=async()=>{await this.onConnect()},this.stop=async()=>{await this.onDisconnect()},this.restart=async()=>{this.restartInProgress=!0,await this.restore(),await this.reset(),this.restartInProgress=!1},this.relayer=e,this.logger=b(t,this.name),this.clientId=""}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t}catch{}return i}onEnable(){this.cached=[],this.initialized=!0}onDisable(){this.cached=this.values,this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map((async s=>await this.unsubscribeById(e,s,t))))}async unsubscribeById(e,t,i){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});try{const s=ne(i);await this.rpcUnsubscribe(e,t,s);const r=K("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,r),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}})}catch(s){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(s),s}}async rpcSubscribe(e,t){const i={method:H(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{return await await M(this.relayer.request(i).catch((s=>this.logger.warn(s))),this.subscribeTimeout)?re(e+this.clientId):null}catch{this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(v.connection_stalled)}return null}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,i={method:H(t.protocol).batchSubscribe,params:{topics:e.map((s=>s.topic))}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{return await await M(this.relayer.request(i).catch((s=>this.logger.warn(s))),this.subscribeTimeout)}catch{this.relayer.events.emit(v.connection_stalled)}}rpcUnsubscribe(e,t,i){const s={method:H(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s}),this.relayer.request(s)}onSubscribe(e,t){this.setSubscription(e,fe(q({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach((t=>{this.setSubscription(t.id,q({},t)),this.pending.delete(t.topic)}))}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t)}addSubscription(e,t){this.subscriptions.set(e,q({},t)),this.topicMap.set(t.topic,e),this.events.emit(T.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(T.deleted,fe(q({},i),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(T.sync)}async reset(){if(this.cached.length){const e=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let t=0;t<e;t++){const i=this.cached.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(i)}}this.events.emit(T.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){if(!e.length)return;const t=await this.rpcBatchSubscribe(e);Ii(t)&&this.onBatchSubscribe(t.map(((i,s)=>fe(q({},e[s]),{id:i}))))}async onConnect(){await this.restart(),this.onEnable()}onDisconnect(){this.onDisable()}async checkPending(){if(!this.initialized||!this.relayer.connected)return;const e=[];this.pending.forEach((t=>{e.push(t)})),await this.batchSubscribe(e)}registerEventListeners(){this.relayer.core.heartbeat.on(G.pulse,(async()=>{await this.checkPending()})),this.events.on(T.created,(async e=>{const t=T.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()})),this.events.on(T.deleted,(async e=>{const t=T.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()}))}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(){this.restartInProgress&&await new Promise((e=>{const t=setInterval((()=>{this.restartInProgress||(clearInterval(t),e())}),this.pollingInterval)}))}}var Pr=Object.defineProperty,Ft=Object.getOwnPropertySymbols,xr=Object.prototype.hasOwnProperty,Or=Object.prototype.propertyIsEnumerable,kt=(n,e,t)=>e in n?Pr(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Ar=(n,e)=>{for(var t in e||(e={}))xr.call(e,t)&&kt(n,t,e[t]);if(Ft)for(var t of Ft(e))Or.call(e,t)&&kt(n,t,e[t]);return n};class Mt extends ni{constructor(e){super(e),this.protocol="wc",this.version=2,this.events=new L,this.name=gt,this.transportExplicitlyClosed=!1,this.initialized=!1,this.connectionAttemptInProgress=!1,this.connectionStatusPollingInterval=20,this.staleConnectionErrors=["socket hang up","socket stalled","interrupted"],this.hasExperiencedNetworkDisruption=!1,this.requestsInFlight=new Map,this.heartBeatTimeout=R(le+X),this.request=async t=>{var i,s;this.logger.debug("Publishing Request Payload");const r=t.id||Oe().toString();await this.toEstablishConnection();try{const o=this.provider.request(t);this.requestsInFlight.set(r,{promise:o,request:t}),this.logger.trace({id:r,method:t.method,topic:null==(i=t.params)?void 0:i.topic},"relayer.request - attempt to publish...");const a=await new Promise((async(h,l)=>{const d=()=>{l(new Error(`relayer.request - publish interrupted, id: ${r}`))};this.provider.on(f.disconnect,d);const g=await o;this.provider.off(f.disconnect,d),h(g)}));return this.logger.trace({id:r,method:t.method,topic:null==(s=t.params)?void 0:s.topic},"relayer.request - published"),a}catch(o){throw this.logger.debug(`Failed to Publish Request: ${r}`),o}finally{this.requestsInFlight.delete(r)}},this.resetPingTimeout=()=>{if(ae())try{clearTimeout(this.pingTimeout),this.pingTimeout=setTimeout((()=>{var t,i,s;null==(s=null==(i=null==(t=this.provider)?void 0:t.connection)?void 0:i.socket)||s.terminate()}),this.heartBeatTimeout)}catch(t){this.logger.warn(t)}},this.onPayloadHandler=t=>{this.onProviderPayload(t),this.resetPingTimeout()},this.onConnectHandler=()=>{this.startPingTimeout(),this.events.emit(v.connect)},this.onDisconnectHandler=()=>{this.onProviderDisconnect()},this.onProviderErrorHandler=t=>{this.logger.error(t),this.events.emit(v.error,t),this.logger.info("Fatal socket error received, closing transport"),this.transportClose()},this.registerProviderListeners=()=>{this.provider.on(f.payload,this.onPayloadHandler),this.provider.on(f.connect,this.onConnectHandler),this.provider.on(f.disconnect,this.onDisconnectHandler),this.provider.on(f.error,this.onProviderErrorHandler)},this.core=e.core,this.logger=typeof e.logger<"u"&&"string"!=typeof e.logger?b(e.logger,this.name):Ee(we({level:e.logger||dt})),this.messages=new Nt(this.logger,e.core),this.subscriber=new $t(this,this.logger),this.publisher=new vr(this,this.logger),this.relayUrl=e?.relayUrl||me,this.projectId=e.projectId,this.bundleId=Ci(),this.provider={}}async init(){this.logger.trace("Initialized"),this.registerEventListeners(),await this.createProvider(),await Promise.all([this.messages.init(),this.subscriber.init()]);try{await this.transportOpen()}catch{this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${be}...`),await this.restartTransport(be)}this.initialized=!0,setTimeout((async()=>{0===this.subscriber.topics.length&&0===this.subscriber.pending.size&&(this.logger.info("No topics subscribed to after init, closing transport"),await this.transportClose(),this.transportExplicitlyClosed=!1)}),mt)}get context(){return w(this.logger)}get connected(){var e,t,i;return 1===(null==(i=null==(t=null==(e=this.provider)?void 0:e.connection)?void 0:t.socket)?void 0:i.readyState)}get connecting(){var e,t,i;return 0===(null==(i=null==(t=null==(e=this.provider)?void 0:e.connection)?void 0:t.socket)?void 0:i.readyState)}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now()})}async subscribe(e,t){var i;this.isInitialized();let r,s=(null==(i=this.subscriber.topicMap.get(e))?void 0:i[0])||"";const o=a=>{a.topic===e&&(this.subscriber.off(T.created,o),r())};return await Promise.all([new Promise((a=>{r=a,this.subscriber.on(T.created,o)})),new Promise((async a=>{s=await this.subscriber.subscribe(e,t)||s,a()}))]),s}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportDisconnect(){if(!this.hasExperiencedNetworkDisruption&&this.connected&&this.requestsInFlight.size>0)try{await Promise.all(Array.from(this.requestsInFlight.values()).map((e=>e.promise)))}catch(e){this.logger.warn(e)}this.hasExperiencedNetworkDisruption||this.connected?await M(this.provider.disconnect(),2e3,"provider.disconnect()").catch((()=>this.onProviderDisconnect())):this.onProviderDisconnect()}async transportClose(){this.transportExplicitlyClosed=!0,await this.transportDisconnect()}async transportOpen(e){await this.confirmOnlineStateOrThrow(),e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportDisconnect(),await this.createProvider()),this.connectionAttemptInProgress=!0,this.transportExplicitlyClosed=!1;try{await new Promise((async(t,i)=>{const s=()=>{this.provider.off(f.disconnect,s),i(new Error("Connection interrupted while trying to subscribe"))};this.provider.on(f.disconnect,s),await M(this.provider.connect(),R(ue),`Socket stalled when trying to connect to ${this.relayUrl}`).catch((r=>{i(r)})),await this.subscriber.start(),this.hasExperiencedNetworkDisruption=!1,t()}))}catch(t){this.logger.error(t);const i=t;if(!this.isConnectionStalled(i.message))throw t}finally{this.connectionAttemptInProgress=!1}}async restartTransport(e){this.connectionAttemptInProgress||(this.relayUrl=e||this.relayUrl,await this.confirmOnlineStateOrThrow(),await this.transportClose(),await this.createProvider(),await this.transportOpen())}async confirmOnlineStateOrThrow(){if(!await Re())throw new Error("No internet connection detected. Please restart your network and try again.")}startPingTimeout(){var e,t,i,s,r;if(ae())try{null!=(t=null==(e=this.provider)?void 0:e.connection)&&t.socket&&(null==(r=null==(s=null==(i=this.provider)?void 0:i.connection)?void 0:s.socket)||r.once("ping",(()=>{this.resetPingTimeout()}))),this.resetPingTimeout()}catch(o){this.logger.warn(o)}}isConnectionStalled(e){return this.staleConnectionErrors.some((t=>e.includes(t)))}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new Bi(new ji(_i({sdkVersion:yt,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0,bundleId:this.bundleId}))),this.registerProviderListeners()}async recordMessageEvent(e){const{topic:t,message:i}=e;await this.messages.set(t,i)}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;if(!i||0===i.length)return this.logger.debug(`Ignoring invalid/empty message: ${i}`),!0;if(!await this.subscriber.isSubscribed(t))return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`),!0;const s=this.messages.has(t,i);return s&&this.logger.debug(`Ignoring duplicate message: ${i}`),s}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),Ae(e)){if(!e.method.endsWith(pt))return;const t=e.params,{topic:i,message:s,publishedAt:r}=t.data,o={topic:i,message:s,publishedAt:r};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(Ar({type:"event",event:t.id},o)),this.events.emit(t.id,o),await this.acknowledgePayload(e),await this.onMessageEvent(o)}else ze(e)&&this.events.emit(v.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(this.events.emit(v.message,e),await this.recordMessageEvent(e))}async acknowledgePayload(e){const t=Ne(e.id,!0);await this.provider.connection.send(t)}unregisterProviderListeners(){this.provider.off(f.payload,this.onPayloadHandler),this.provider.off(f.connect,this.onConnectHandler),this.provider.off(f.disconnect,this.onDisconnectHandler),this.provider.off(f.error,this.onProviderErrorHandler)}async registerEventListeners(){let e=await Re();Ri((async t=>{e!==t&&(e=t,t?await this.restartTransport().catch((i=>this.logger.error(i))):(this.hasExperiencedNetworkDisruption=!0,await this.transportDisconnect(),this.transportExplicitlyClosed=!1))}))}async onProviderDisconnect(){await this.subscriber.stop(),this.events.emit(v.disconnect),this.connectionAttemptInProgress=!1,!this.transportExplicitlyClosed&&setTimeout((async()=>{await this.transportOpen().catch((e=>this.logger.error(e)))}),R(Dt))}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){await this.confirmOnlineStateOrThrow(),!this.connected&&(this.connectionAttemptInProgress&&await new Promise((e=>{const t=setInterval((()=>{this.connected&&(clearInterval(t),e())}),this.connectionStatusPollingInterval)})),await this.transportOpen())}}var zr=Object.defineProperty,Kt=Object.getOwnPropertySymbols,Nr=Object.prototype.hasOwnProperty,Ur=Object.prototype.propertyIsEnumerable,Bt=(n,e,t)=>e in n?zr(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Vt=(n,e)=>{for(var t in e||(e={}))Nr.call(e,t)&&Bt(n,t,e[t]);if(Kt)for(var t of Kt(e))Ur.call(e,t)&&Bt(n,t,e[t]);return n};class qt extends oi{constructor(e,t,i,s=z,r=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,this.map=new Map,this.version=bt,this.cached=[],this.initialized=!1,this.storagePrefix=z,this.recentlyDeleted=[],this.recentlyDeletedLimit=200,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach((o=>{this.getKey&&null!==o&&!oe(o)?this.map.set(this.getKey(o),o):Ti(o)?this.map.set(o.id,o):Si(o)&&this.map.set(o.topic,o)})),this.cached=[],this.initialized=!0)},this.set=async(o,a)=>{this.isInitialized(),this.map.has(o)?await this.update(o,a):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:o,value:a}),this.map.set(o,a),await this.persist())},this.get=o=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:o}),this.getData(o)),this.getAll=o=>(this.isInitialized(),o?this.values.filter((a=>Object.keys(o).every((h=>Gi(a[h],o[h]))))):this.values),this.update=async(o,a)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:o,update:a});const h=Vt(Vt({},this.getData(o)),a);this.map.set(o,h),await this.persist()},this.delete=async(o,a)=>{this.isInitialized(),this.map.has(o)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:o,reason:a}),this.map.delete(o),this.addToRecentlyDeleted(o),await this.persist())},this.logger=b(t,this.name),this.storagePrefix=s,this.getKey=r}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}addToRecentlyDeleted(e){this.recentlyDeleted.push(e),this.recentlyDeleted.length>=this.recentlyDeletedLimit&&this.recentlyDeleted.splice(0,this.recentlyDeletedLimit/2)}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){if(this.recentlyDeleted.includes(e)){const{message:s}=c("MISSING_OR_INVALID",`Record was recently deleted - ${this.name}: ${e}`);throw this.logger.error(s),new Error(s)}const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class jt{constructor(e,t){this.core=e,this.logger=t,this.name=It,this.version=Ct,this.events=new Zt,this.initialized=!1,this.storagePrefix=z,this.ignoredPayloadTypes=[Pi],this.registeredMethods=[],this.init=async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))},this.register=({methods:i})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...i])]},this.create=async()=>{this.isInitialized();const i=se(),s=await this.core.crypto.setSymKey(i),r=J(xe),o={protocol:ut},a={topic:s,expiry:r,relay:o,active:!1},h=xi({protocol:this.core.protocol,version:this.core.version,topic:s,symKey:i,relay:o,expiryTimestamp:r});return await this.pairings.set(s,a),await this.core.relayer.subscribe(s),this.core.expirer.set(s,r),{topic:s,uri:h}},this.pair=async i=>{this.isInitialized(),this.isValidPair(i);const{topic:s,symKey:r,relay:o,expiryTimestamp:a}=Te(i.uri);let h;if(this.pairings.keys.includes(s)&&(h=this.pairings.get(s),h.active))throw new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);const l=a||J(xe),d={topic:s,relay:o,expiry:l,active:!1};return await this.pairings.set(s,d),this.core.expirer.set(s,l),i.activatePairing&&await this.activate({topic:s}),this.events.emit(V.create,d),this.core.crypto.keychain.has(s)||await this.core.crypto.setSymKey(r,s),await this.core.relayer.subscribe(s,{relay:o}),d},this.activate=async({topic:i})=>{this.isInitialized();const s=J(W);await this.pairings.update(i,{active:!0,expiry:s}),this.core.expirer.set(i,s)},this.ping=async i=>{this.isInitialized(),await this.isValidPing(i);const{topic:s}=i;if(this.pairings.keys.includes(s)){const r=await this.sendRequest(s,"wc_pairingPing",{}),{done:o,resolve:a,reject:h}=Oi();this.events.once(he("pairing_ping",r),(({error:l})=>{l?h(l):a()})),await o()}},this.updateExpiry=async({topic:i,expiry:s})=>{this.isInitialized(),await this.pairings.update(i,{expiry:s})},this.updateMetadata=async({topic:i,metadata:s})=>{this.isInitialized(),await this.pairings.update(i,{peerMetadata:s})},this.getPairings=()=>(this.isInitialized(),this.pairings.values),this.disconnect=async i=>{this.isInitialized(),await this.isValidDisconnect(i);const{topic:s}=i;this.pairings.keys.includes(s)&&(await this.sendRequest(s,"wc_pairingDelete",K("USER_DISCONNECTED")),await this.deletePairing(s))},this.sendRequest=async(i,s,r)=>{const o=Ue(s,r),a=await this.core.crypto.encode(i,o),h=F[s].req;return this.core.history.set(i,o),this.core.relayer.publish(i,a,h),o.id},this.sendResult=async(i,s,r)=>{const o=Ne(i,r),a=await this.core.crypto.encode(s,o),h=await this.core.history.get(s,i),l=F[h.request.method].res;await this.core.relayer.publish(s,a,l),await this.core.history.resolve(o)},this.sendError=async(i,s,r)=>{const o=Vi(i,r),a=await this.core.crypto.encode(s,o),h=await this.core.history.get(s,i),l=F[h.request.method]?F[h.request.method].res:F.unregistered_method.res;await this.core.relayer.publish(s,a,l),await this.core.history.resolve(o)},this.deletePairing=async(i,s)=>{await this.core.relayer.unsubscribe(i),await Promise.all([this.pairings.delete(i,K("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(i),s?Promise.resolve():this.core.expirer.del(i)])},this.cleanup=async()=>{const i=this.pairings.getAll().filter((s=>Se(s.expiry)));await Promise.all(i.map((s=>this.deletePairing(s.topic))))},this.onRelayEventRequest=i=>{const{topic:s,payload:r}=i;switch(r.method){case"wc_pairingPing":return this.onPairingPingRequest(s,r);case"wc_pairingDelete":return this.onPairingDeleteRequest(s,r);default:return this.onUnknownRpcMethodRequest(s,r)}},this.onRelayEventResponse=async i=>{const{topic:s,payload:r}=i,o=(await this.core.history.get(s,r.id)).request.method;return"wc_pairingPing"===o?this.onPairingPingResponse(s,r):this.onUnknownRpcMethodResponse(o)},this.onPairingPingRequest=async(i,s)=>{const{id:r}=s;try{this.isValidPing({topic:i}),await this.sendResult(r,i,!0),this.events.emit(V.ping,{id:r,topic:i})}catch(o){await this.sendError(r,i,o),this.logger.error(o)}},this.onPairingPingResponse=(i,s)=>{const{id:r}=s;setTimeout((()=>{qi(s)?this.events.emit(he("pairing_ping",r),{}):Le(s)&&this.events.emit(he("pairing_ping",r),{error:s.error})}),500)},this.onPairingDeleteRequest=async(i,s)=>{const{id:r}=s;try{this.isValidDisconnect({topic:i}),await this.deletePairing(i),this.events.emit(V.delete,{id:r,topic:i})}catch(o){await this.sendError(r,i,o),this.logger.error(o)}},this.onUnknownRpcMethodRequest=async(i,s)=>{const{id:r,method:o}=s;try{if(this.registeredMethods.includes(o))return;const a=K("WC_METHOD_UNSUPPORTED",o);await this.sendError(r,i,a),this.logger.error(a)}catch(a){await this.sendError(r,i,a),this.logger.error(a)}},this.onUnknownRpcMethodResponse=i=>{this.registeredMethods.includes(i)||this.logger.error(K("WC_METHOD_UNSUPPORTED",i))},this.isValidPair=i=>{var s;if(!ce(i)){const{message:o}=c("MISSING_OR_INVALID",`pair() params: ${i}`);throw new Error(o)}if(!Ai(i.uri)){const{message:o}=c("MISSING_OR_INVALID",`pair() uri: ${i.uri}`);throw new Error(o)}const r=Te(i.uri);if(null==(s=r?.relay)||!s.protocol){const{message:o}=c("MISSING_OR_INVALID","pair() uri#relay-protocol");throw new Error(o)}if(null==r||!r.symKey){const{message:o}=c("MISSING_OR_INVALID","pair() uri#symKey");throw new Error(o)}if(null!=r&&r.expiryTimestamp&&R(r?.expiryTimestamp)<Date.now()){const{message:o}=c("EXPIRED","pair() URI has expired. Please try again with a new connection URI.");throw new Error(o)}},this.isValidPing=async i=>{if(!ce(i)){const{message:r}=c("MISSING_OR_INVALID",`ping() params: ${i}`);throw new Error(r)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidDisconnect=async i=>{if(!ce(i)){const{message:r}=c("MISSING_OR_INVALID",`disconnect() params: ${i}`);throw new Error(r)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidPairingTopic=async i=>{if(!zi(i,!1)){const{message:s}=c("MISSING_OR_INVALID",`pairing topic should be a string: ${i}`);throw new Error(s)}if(!this.pairings.keys.includes(i)){const{message:s}=c("NO_MATCHING_KEY",`pairing topic doesn't exist: ${i}`);throw new Error(s)}if(Se(this.pairings.get(i).expiry)){await this.deletePairing(i);const{message:s}=c("EXPIRED",`pairing topic: ${i}`);throw new Error(s)}},this.core=e,this.logger=b(t,this.name),this.pairings=new qt(this.core,this.logger,this.name,this.storagePrefix)}get context(){return w(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(v.message,(async e=>{const{topic:t,message:i}=e;if(!this.pairings.keys.includes(t)||this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))return;const s=await this.core.crypto.decode(t,i);try{Ae(s)?(this.core.history.set(t,s),this.onRelayEventRequest({topic:t,payload:s})):ze(s)&&(await this.core.history.resolve(s),await this.onRelayEventResponse({topic:t,payload:s}),this.core.history.delete(t,s.id))}catch(r){this.logger.error(r)}}))}registerExpirerEvents(){this.core.expirer.on(I.expired,(async e=>{const{topic:t}=Ni(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(V.expire,{topic:t}))}))}}class Gt extends ai{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.records=new Map,this.events=new L,this.name=_t,this.version=Rt,this.cached=[],this.initialized=!1,this.storagePrefix=z,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach((i=>this.records.set(i.id,i))),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.set=(i,s,r)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:i,request:s,chainId:r}),this.records.has(s.id))return;const o={id:s.id,topic:i,request:{method:s.method,params:s.params||null},chainId:r,expiry:J(W)};this.records.set(o.id,o),this.events.emit(S.created,o)},this.resolve=async i=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:i}),!this.records.has(i.id))return;const s=await this.getRecord(i.id);typeof s.response>"u"&&(s.response=Le(i)?{error:i.error}:{result:i.result},this.records.set(s.id,s),this.events.emit(S.updated,s))},this.get=async(i,s)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:i,id:s}),await this.getRecord(s)),this.delete=(i,s)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:s}),this.values.forEach((r=>{if(r.topic===i){if(typeof s<"u"&&r.id!==s)return;this.records.delete(r.id),this.events.emit(S.deleted,r)}}))},this.exists=async(i,s)=>(this.isInitialized(),!!this.records.has(s)&&(await this.getRecord(s)).topic===i),this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=b(t,this.name)}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach((t=>{if(typeof t.response<"u")return;const i={topic:t.topic,request:Ue(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)})),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(S.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(S.created,(e=>{const t=S.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()})),this.events.on(S.updated,(e=>{const t=S.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()})),this.events.on(S.deleted,(e=>{const t=S.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()})),this.core.heartbeat.on(G.pulse,(()=>{this.cleanup()}))}cleanup(){try{this.records.forEach((e=>{R(e.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${e.id}`),this.delete(e.topic,e.id))}))}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Yt extends hi{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.expirations=new Map,this.events=new L,this.name=Tt,this.version=St,this.cached=[],this.initialized=!1,this.storagePrefix=z,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach((i=>this.expirations.set(i.target,i))),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.has=i=>{try{const s=this.formatTarget(i);return typeof this.getExpiration(s)<"u"}catch{return!1}},this.set=(i,s)=>{this.isInitialized();const r=this.formatTarget(i),o={target:r,expiry:s};this.expirations.set(r,o),this.checkExpiry(r,o),this.events.emit(I.created,{target:r,expiration:o})},this.get=i=>{this.isInitialized();const s=this.formatTarget(i);return this.getExpiration(s)},this.del=i=>{if(this.isInitialized(),this.has(i)){const s=this.formatTarget(i),r=this.getExpiration(s);this.expirations.delete(s),this.events.emit(I.deleted,{target:s,expiration:r})}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=b(t,this.name)}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if("string"==typeof e)return Ui(e);if("number"==typeof e)return Li(e);const{message:t}=c("UNKNOWN_TYPE","Target type: "+typeof e);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(I.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.warn(i),new Error(i)}return t}checkExpiry(e,t){const{expiry:i}=t;R(i)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(I.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach(((e,t)=>this.checkExpiry(t,e)))}registerEventListeners(){this.core.heartbeat.on(G.pulse,(()=>this.checkExpirations())),this.events.on(I.created,(e=>{const t=I.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})),this.events.on(I.expired,(e=>{const t=I.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})),this.events.on(I.deleted,(e=>{const t=I.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}))}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Ht extends ci{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,this.name=ee,this.initialized=!1,this.queue=[],this.verifyDisabled=!1,this.init=async i=>{if(this.verifyDisabled||$i()||!Fi())return;const s=this.getVerifyUrl(i?.verifyUrl);this.verifyUrl!==s&&this.removeIframe(),this.verifyUrl=s;try{await this.createIframe()}catch(r){this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`),this.logger.info(r)}if(!this.initialized){this.removeIframe(),this.verifyUrl=te;try{await this.createIframe()}catch(r){this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`),this.logger.info(r),this.verifyDisabled=!0}}},this.register=async i=>{this.initialized?this.sendPost(i.attestationId):(this.addToQueue(i.attestationId),await this.init())},this.resolve=async i=>{if(this.isDevEnv)return"";const s=this.getVerifyUrl(i?.verifyUrl);let r;try{r=await this.fetchAttestation(i.attestationId,s)}catch(o){this.logger.info(`failed to resolve attestation: ${i.attestationId} from url: ${s}`),this.logger.info(o),r=await this.fetchAttestation(i.attestationId,te)}return r},this.fetchAttestation=async(i,s)=>{this.logger.info(`resolving attestation: ${i} from url: ${s}`);const r=this.startAbortTimer(2*X),o=await fetch(`${s}/attestation/${i}`,{signal:this.abortController.signal});return clearTimeout(r),200===o.status?await o.json():void 0},this.addToQueue=i=>{this.queue.push(i)},this.processQueue=()=>{0!==this.queue.length&&(this.queue.forEach((i=>this.sendPost(i))),this.queue=[])},this.sendPost=i=>{var s;try{if(!this.iframe)return;null==(s=this.iframe.contentWindow)||s.postMessage(i,"*"),this.logger.info(`postMessage sent: ${i} ${this.verifyUrl}`)}catch{}},this.createIframe=async()=>{let i;const s=r=>{"verify_ready"===r.data&&(this.onInit(),window.removeEventListener("message",s),i())};await Promise.race([new Promise((r=>{const o=document.getElementById(ee);if(o)return this.iframe=o,this.onInit(),r();window.addEventListener("message",s);const a=document.createElement("iframe");a.id=ee,a.src=`${this.verifyUrl}/${this.projectId}`,a.style.display="none",document.body.append(a),this.iframe=a,i=r})),new Promise(((r,o)=>setTimeout((()=>{window.removeEventListener("message",s),o("verify iframe load timeout")}),R(Pe))))])},this.onInit=()=>{this.initialized=!0,this.processQueue()},this.removeIframe=()=>{this.iframe&&(this.iframe.remove(),this.iframe=void 0,this.initialized=!1)},this.getVerifyUrl=i=>{let s=i||k;return Pt.includes(s)||(this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${k}`),s=k),s},this.logger=b(t,this.name),this.verifyUrl=k,this.abortController=new AbortController,this.isDevEnv=ae()&&process.env.IS_VITEST}get context(){return w(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout((()=>this.abortController.abort()),R(e))}}class Jt extends li{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,this.context=xt,this.registerDeviceToken=async i=>{const{clientId:s,token:r,notificationType:o,enableEncrypted:a=!1}=i,h=`${Ot}/${this.projectId}/clients`;await Yi(h,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({client_id:s,type:o,token:r,always_raw:a})})},this.logger=b(t,this.context)}}var Lr=Object.defineProperty,Xt=Object.getOwnPropertySymbols,$r=Object.prototype.hasOwnProperty,Fr=Object.prototype.propertyIsEnumerable,Wt=(n,e,t)=>e in n?Lr(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Qt=(n,e)=>{for(var t in e||(e={}))$r.call(e,t)&&Wt(n,t,e[t]);if(Xt)for(var t of Xt(e))Fr.call(e,t)&&Wt(n,t,e[t]);return n};class ie extends ui{constructor(e){super(e),this.protocol=De,this.version=2,this.name=Z,this.events=new L,this.initialized=!1,this.on=(i,s)=>this.events.on(i,s),this.once=(i,s)=>this.events.once(i,s),this.off=(i,s)=>this.events.off(i,s),this.removeListener=(i,s)=>this.events.removeListener(i,s),this.projectId=e?.projectId,this.relayUrl=e?.relayUrl||me,this.customStoragePrefix=null!=e&&e.customStoragePrefix?`:${e.customStoragePrefix}`:"";const t=typeof e?.logger<"u"&&"string"!=typeof e?.logger?e.logger:Ee(we({level:e?.logger||tt.logger}));this.logger=b(t,this.name),this.heartbeat=new ti,this.crypto=new zt(this,this.logger,e?.keychain),this.history=new Gt(this,this.logger),this.expirer=new Yt(this,this.logger),this.storage=null!=e&&e.storage?e.storage:new ei(Qt(Qt({},it),e?.storageOptions)),this.relayer=new Mt({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new jt(this,this.logger),this.verify=new Ht(this.projectId||"",this.logger),this.echoClient=new Jt(this.projectId||"",this.logger)}static async init(e){const t=new ie(e);await t.initialize();const i=await t.crypto.getClientId();return await t.storage.setItem(ft,i),t}get context(){return w(this.logger)}async start(){this.initialized||await this.initialize()}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.initialized=!0,this.logger.info("Core Initialization Success")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}}const kr=ie;export{Z as CORE_CONTEXT,tt as CORE_DEFAULT,De as CORE_PROTOCOL,it as CORE_STORAGE_OPTIONS,z as CORE_STORAGE_PREFIX,et as CORE_VERSION,ye as CRYPTO_CLIENT_SEED,st as CRYPTO_CONTEXT,rt as CRYPTO_JWT_TTL,kr as Core,zt as Crypto,xt as ECHO_CONTEXT,Ot as ECHO_URL,Tt as EXPIRER_CONTEXT,wr as EXPIRER_DEFAULT_TTL,I as EXPIRER_EVENTS,St as EXPIRER_STORAGE_VERSION,Jt as EchoClient,Yt as Expirer,_t as HISTORY_CONTEXT,S as HISTORY_EVENTS,Rt as HISTORY_STORAGE_VERSION,Gt as JsonRpcHistory,nt as KEYCHAIN_CONTEXT,ot as KEYCHAIN_STORAGE_VERSION,At as KeyChain,at as MESSAGES_CONTEXT,ht as MESSAGES_STORAGE_VERSION,Nt as MessageTracker,It as PAIRING_CONTEXT,Er as PAIRING_DEFAULT_TTL,V as PAIRING_EVENTS,F as PAIRING_RPC_OPTS,Ct as PAIRING_STORAGE_VERSION,vt as PENDING_SUB_RESOLUTION_TIMEOUT,lt as PUBLISHER_CONTEXT,ct as PUBLISHER_DEFAULT_TTL,jt as Pairing,gt as RELAYER_CONTEXT,dt as RELAYER_DEFAULT_LOGGER,ut as RELAYER_DEFAULT_PROTOCOL,me as RELAYER_DEFAULT_RELAY_URL,v as RELAYER_EVENTS,be as RELAYER_FAILOVER_RELAY_URL,f as RELAYER_PROVIDER_EVENTS,Dt as RELAYER_RECONNECT_TIMEOUT,yt as RELAYER_SDK_VERSION,br as RELAYER_STORAGE_OPTIONS,pt as RELAYER_SUBSCRIBER_SUFFIX,mt as RELAYER_TRANSPORT_CUTOFF,Mt as Relayer,bt as STORE_STORAGE_VERSION,Et as SUBSCRIBER_CONTEXT,fr as SUBSCRIBER_DEFAULT_TTL,T as SUBSCRIBER_EVENTS,wt as SUBSCRIBER_STORAGE_VERSION,qt as Store,$t as Subscriber,Pt as TRUSTED_VERIFY_URLS,ee as VERIFY_CONTEXT,te as VERIFY_FALLBACK_SERVER,k as VERIFY_SERVER,Ht as Verify,ft as WALLETCONNECT_CLIENT_ID,ie as default};