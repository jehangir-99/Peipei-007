import{RELAYER_DEFAULT_PROTOCOL as Re,RELAYER_EVENTS as se,VERIFY_SERVER as Se,EXPIRER_EVENTS as Ee,PAIRING_EVENTS as te,Store as j,Core as Ie}from"@walletconnect/core";import{pino as _e,getDefaultLoggerOptions as qe,generateChildLogger as fe,getLoggerContext as Ne}from"@walletconnect/logger";import{IEngine as ve,ISignClient as Pe}from"@walletconnect/types";import{TYPE_1 as Oe,getInternalError as l,calcExpiry as N,createDelayedPromise as C,engineEvent as u,getSdkError as R,getDeepLink as Te,handleDeeplinkRedirect as De,isSessionCompatible as Ve,isBrowser as xe,hashMessage as z,isExpired as V,MemoryStore as b,isValidParams as S,isUndefined as A,isValidRelays as Ce,isValidObject as ie,isValidRequiredNamespaces as be,isValidNamespaces as Y,isConformingNamespaces as re,isValidString as $,isValidErrorReason as Ae,isValidRelay as $e,isValidController as Le,isValidNamespacesChainId as ne,isValidRequest as Me,isValidNamespacesRequest as Ge,isValidRequestExpiry as Ue,isValidResponse as ke,isValidEvent as Qe,isValidNamespacesEvent as Ke,parseExpirerTarget as Fe,isValidId as je,getAppMetadata as ze}from"@walletconnect/utils";import Ye,{EventEmitter as Je}from"events";import{THIRTY_DAYS as Xe,SEVEN_DAYS as oe,FIVE_MINUTES as I,ONE_DAY as O,ONE_SECOND as He,toMiliseconds as ae}from"@walletconnect/time";import{payloadId as M,getBigIntRpcId as G,isJsonRpcResult as T,isJsonRpcError as D,formatJsonRpcRequest as J,formatJsonRpcResult as Be,formatJsonRpcError as We,isJsonRpcRequest as Ze,isJsonRpcResponse as es}from"@walletconnect/jsonrpc-utils";const X="wc",H=2,B="client",U=`${X}@2:${B}:`,k={name:B,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},ss={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_request_expire:"session_request_expire"},ts={database:":memory:"},W="WALLETCONNECT_DEEPLINK_CHOICE",is={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},rs="history",ns="0.3",ce="proposal",os=Xe,le="Proposal expired",he="session",L=oe,pe="engine",_={wc_sessionPropose:{req:{ttl:I,prompt:!0,tag:1100},res:{ttl:I,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:I,prompt:!1,tag:1102},res:{ttl:I,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:O,prompt:!1,tag:1104},res:{ttl:O,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:O,prompt:!1,tag:1106},res:{ttl:O,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:I,prompt:!0,tag:1108},res:{ttl:I,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:I,prompt:!0,tag:1110},res:{ttl:I,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:O,prompt:!1,tag:1112},res:{ttl:O,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:O,prompt:!1,tag:1114},res:{ttl:O,prompt:!1,tag:1115}}},Q={min:I,max:oe},q={idle:"IDLE",active:"ACTIVE"},de="request",ue=["wc_sessionPropose","wc_sessionRequest","wc_authRequest"];var as=Object.defineProperty,cs=Object.defineProperties,ls=Object.getOwnPropertyDescriptors,ge=Object.getOwnPropertySymbols,hs=Object.prototype.hasOwnProperty,ps=Object.prototype.propertyIsEnumerable,we=(y,n,s)=>n in y?as(y,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):y[n]=s,w=(y,n)=>{for(var s in n||(n={}))hs.call(n,s)&&we(y,s,n[s]);if(ge)for(var s of ge(n))ps.call(n,s)&&we(y,s,n[s]);return y},x=(y,n)=>cs(y,ls(n));class ds extends ve{constructor(n){super(n),this.name=pe,this.events=new Ye,this.initialized=!1,this.ignoredPayloadTypes=[Oe],this.requestQueue={state:q.idle,queue:[]},this.sessionRequestQueue={state:q.idle,queue:[]},this.requestQueueDelay=He,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),this.client.core.pairing.register({methods:Object.keys(_)}),this.initialized=!0,setTimeout((()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()}),ae(this.requestQueueDelay)))},this.connect=async s=>{await this.isInitialized();const e=x(w({},s),{requiredNamespaces:s.requiredNamespaces||{},optionalNamespaces:s.optionalNamespaces||{}});await this.isValidConnect(e);const{pairingTopic:t,requiredNamespaces:i,optionalNamespaces:r,sessionProperties:o,relays:a}=e;let d,c=t,p=!1;try{c&&(p=this.client.core.pairing.pairings.get(c).active)}catch(P){throw this.client.logger.error(`connect() -> pairing.get(${c}) failed`),P}if(!c||!p){const{topic:P,uri:f}=await this.client.core.pairing.create();c=P,d=f}if(!c){const{message:P}=l("NO_MATCHING_KEY",`connect() pairing topic: ${c}`);throw new Error(P)}const h=await this.client.core.crypto.generateKeyPair(),g=_.wc_sessionPropose.req.ttl||I,m=N(g),v=w({requiredNamespaces:i,optionalNamespaces:r,relays:a??[{protocol:Re}],proposer:{publicKey:h,metadata:this.client.metadata},expiryTimestamp:m},o&&{sessionProperties:o}),{reject:F,resolve:E,done:me}=C(g,le);this.events.once(u("session_connect"),(async({error:P,session:f})=>{if(P)F(P);else if(f){f.self.publicKey=h;const ee=x(w({},f),{requiredNamespaces:v.requiredNamespaces,optionalNamespaces:v.optionalNamespaces});await this.client.session.set(f.topic,ee),await this.setExpiry(f.topic,f.expiry),c&&await this.client.core.pairing.updateMetadata({topic:c,metadata:f.peer.metadata}),E(ee)}}));const Z=await this.sendRequest({topic:c,method:"wc_sessionPropose",params:v,throwOnFailedPublish:!0});return await this.setProposal(Z,w({id:Z},v)),{uri:d,approval:me}},this.pair=async s=>{await this.isInitialized();try{return await this.client.core.pairing.pair(s)}catch(e){throw this.client.logger.error("pair() failed"),e}},this.approve=async s=>{await this.isInitialized();try{await this.isValidApprove(s)}catch(E){throw this.client.logger.error("approve() -> isValidApprove() failed"),E}const{id:e,relayProtocol:t,namespaces:i,sessionProperties:r}=s;let o;try{o=this.client.proposal.get(e)}catch(E){throw this.client.logger.error(`approve() -> proposal.get(${e}) failed`),E}let{pairingTopic:a,proposer:c,requiredNamespaces:d,optionalNamespaces:p}=o;a=a||"";const h=await this.client.core.crypto.generateKeyPair(),g=c.publicKey,m=await this.client.core.crypto.generateSharedKey(h,g),v=w({relay:{protocol:t??"irn"},namespaces:i,pairingTopic:a,controller:{publicKey:h,metadata:this.client.metadata},expiry:N(L)},r&&{sessionProperties:r});await this.client.core.relayer.subscribe(m);const F=x(w({},v),{topic:m,requiredNamespaces:d,optionalNamespaces:p,pairingTopic:a,acknowledged:!1,self:v.controller,peer:{publicKey:c.publicKey,metadata:c.metadata},controller:h});await this.client.session.set(m,F);try{await this.sendResult({id:e,topic:a,result:{relay:{protocol:t??"irn"},responderPublicKey:h},throwOnFailedPublish:!0}),await this.sendRequest({topic:m,method:"wc_sessionSettle",params:v,throwOnFailedPublish:!0})}catch(E){throw this.client.logger.error(E),this.client.session.delete(m,R("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(m),E}return await this.client.core.pairing.updateMetadata({topic:a,metadata:c.metadata}),await this.client.proposal.delete(e,R("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:a}),await this.setExpiry(m,N(L)),{topic:m,acknowledged:()=>new Promise((E=>setTimeout((()=>E(this.client.session.get(m))),500)))}},this.reject=async s=>{await this.isInitialized();try{await this.isValidReject(s)}catch(r){throw this.client.logger.error("reject() -> isValidReject() failed"),r}const{id:e,reason:t}=s;let i;try{i=this.client.proposal.get(e).pairingTopic}catch(r){throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`),r}i&&(await this.sendError(e,i,t),await this.client.proposal.delete(e,R("USER_DISCONNECTED")))},this.update=async s=>{await this.isInitialized();try{await this.isValidUpdate(s)}catch(p){throw this.client.logger.error("update() -> isValidUpdate() failed"),p}const{topic:e,namespaces:t}=s,{done:i,resolve:r,reject:o}=C(),a=M(),c=G().toString(),d=this.client.session.get(e).namespaces;return this.events.once(u("session_update",a),(async({error:p})=>{p?o(p):(await this.client.session.update(e,{namespaces:t}),r())})),this.sendRequest({topic:e,method:"wc_sessionUpdate",params:{namespaces:t},throwOnFailedPublish:!0,clientRpcId:a,relayRpcId:c}).catch((p=>{this.client.logger.error(p),this.client.session.update(e,{namespaces:d}),o(p)})),{acknowledged:i}},this.extend=async s=>{await this.isInitialized();try{await this.isValidExtend(s)}catch(a){throw this.client.logger.error("extend() -> isValidExtend() failed"),a}const{topic:e}=s,t=M(),{done:i,resolve:r,reject:o}=C();return this.events.once(u("session_extend",t),(({error:a})=>{a?o(a):r()})),await this.setExpiry(e,N(L)),this.sendRequest({topic:e,method:"wc_sessionExtend",params:{},clientRpcId:t,throwOnFailedPublish:!0}).catch((a=>{o(a)})),{acknowledged:i}},this.request=async s=>{await this.isInitialized();try{await this.isValidRequest(s)}catch(h){throw this.client.logger.error("request() -> isValidRequest() failed"),h}const{chainId:e,request:t,topic:i,expiry:r=_.wc_sessionRequest.req.ttl}=s,o=M(),a=G().toString(),{done:c,resolve:d,reject:p}=C(r,"Request expired. Please try again.");return this.events.once(u("session_request",o),(({error:h,result:g})=>{h?p(h):d(g)})),await Promise.all([new Promise((async h=>{await this.sendRequest({clientRpcId:o,relayRpcId:a,topic:i,method:"wc_sessionRequest",params:{request:x(w({},t),{expiryTimestamp:N(r)}),chainId:e},expiry:r,throwOnFailedPublish:!0}).catch((g=>p(g))),this.client.events.emit("session_request_sent",{topic:i,request:t,chainId:e,id:o}),h()})),new Promise((async h=>{const g=await Te(this.client.core.storage,W);De({id:o,topic:i,wcDeepLink:g}),h()})),c()]).then((h=>h[2]))},this.respond=async s=>{await this.isInitialized(),await this.isValidRespond(s);const{topic:e,response:t}=s,{id:i}=t;T(t)?await this.sendResult({id:i,topic:e,result:t.result,throwOnFailedPublish:!0}):D(t)&&await this.sendError(i,e,t.error),this.cleanupAfterResponse(s)},this.ping=async s=>{await this.isInitialized();try{await this.isValidPing(s)}catch(t){throw this.client.logger.error("ping() -> isValidPing() failed"),t}const{topic:e}=s;if(this.client.session.keys.includes(e)){const t=M(),i=G().toString(),{done:r,resolve:o,reject:a}=C();this.events.once(u("session_ping",t),(({error:c})=>{c?a(c):o()})),await Promise.all([this.sendRequest({topic:e,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:t,relayRpcId:i}),r()])}else this.client.core.pairing.pairings.keys.includes(e)&&await this.client.core.pairing.ping({topic:e})},this.emit=async s=>{await this.isInitialized(),await this.isValidEmit(s);const{topic:e,event:t,chainId:i}=s,r=G().toString();await this.sendRequest({topic:e,method:"wc_sessionEvent",params:{event:t,chainId:i},throwOnFailedPublish:!0,relayRpcId:r})},this.disconnect=async s=>{await this.isInitialized(),await this.isValidDisconnect(s);const{topic:e}=s;if(this.client.session.keys.includes(e))await this.sendRequest({topic:e,method:"wc_sessionDelete",params:R("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:e,emitEvent:!1});else{if(!this.client.core.pairing.pairings.keys.includes(e)){const{message:t}=l("MISMATCHED_TOPIC",`Session or pairing topic not found: ${e}`);throw new Error(t)}await this.client.core.pairing.disconnect({topic:e})}},this.find=s=>(this.isInitialized(),this.client.session.getAll().filter((e=>Ve(e,s)))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.cleanupDuplicatePairings=async s=>{if(s.pairingTopic)try{const e=this.client.core.pairing.pairings.get(s.pairingTopic),t=this.client.core.pairing.pairings.getAll().filter((i=>{var r,o;return(null==(r=i.peerMetadata)?void 0:r.url)&&(null==(o=i.peerMetadata)?void 0:o.url)===s.peer.metadata.url&&i.topic&&i.topic!==e.topic}));if(0===t.length)return;this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`),await Promise.all(t.map((i=>this.client.core.pairing.disconnect({topic:i.topic})))),this.client.logger.info("Duplicate pairings clean up finished")}catch(e){this.client.logger.error(e)}},this.deleteSession=async s=>{const{topic:e,expirerHasDeleted:t=!1,emitEvent:i=!0,id:r=0}=s,{self:o}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),await this.client.session.delete(e,R("USER_DISCONNECTED")),this.addToRecentlyDeleted(e,"session"),this.client.core.crypto.keychain.has(o.publicKey)&&await this.client.core.crypto.deleteKeyPair(o.publicKey),this.client.core.crypto.keychain.has(e)&&await this.client.core.crypto.deleteSymKey(e),t||this.client.core.expirer.del(e),this.client.core.storage.removeItem(W).catch((a=>this.client.logger.warn(a))),this.getPendingSessionRequests().forEach((a=>{a.topic===e&&this.deletePendingSessionRequest(a.id,R("USER_DISCONNECTED"))})),i&&this.client.events.emit("session_delete",{id:r,topic:e})},this.deleteProposal=async(s,e)=>{await Promise.all([this.client.proposal.delete(s,R("USER_DISCONNECTED")),e?Promise.resolve():this.client.core.expirer.del(s)]),this.addToRecentlyDeleted(s,"proposal")},this.deletePendingSessionRequest=async(s,e,t=!1)=>{await Promise.all([this.client.pendingRequest.delete(s,e),t?Promise.resolve():this.client.core.expirer.del(s)]),this.addToRecentlyDeleted(s,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter((i=>i.id!==s)),t&&(this.sessionRequestQueue.state=q.idle,this.client.events.emit("session_request_expire",{id:s}))},this.setExpiry=async(s,e)=>{this.client.session.keys.includes(s)&&await this.client.session.update(s,{expiry:e}),this.client.core.expirer.set(s,e)},this.setProposal=async(s,e)=>{await this.client.proposal.set(s,e),this.client.core.expirer.set(s,N(_.wc_sessionPropose.req.ttl))},this.setPendingSessionRequest=async s=>{const{id:e,topic:t,params:i,verifyContext:r}=s,o=i.request.expiryTimestamp||N(_.wc_sessionRequest.req.ttl);await this.client.pendingRequest.set(e,{id:e,topic:t,params:i,verifyContext:r}),o&&this.client.core.expirer.set(e,o)},this.sendRequest=async s=>{const{topic:e,method:t,params:i,expiry:r,relayRpcId:o,clientRpcId:a,throwOnFailedPublish:c}=s,d=J(t,i,a);if(xe()&&ue.includes(t)){const g=z(JSON.stringify(d));this.client.core.verify.register({attestationId:g})}let p;try{p=await this.client.core.crypto.encode(e,d)}catch(g){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`),g}const h=_[t].req;return r&&(h.ttl=r),o&&(h.id=o),this.client.core.history.set(e,d),c?(h.internal=x(w({},h.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(e,p,h)):this.client.core.relayer.publish(e,p,h).catch((g=>this.client.logger.error(g))),d.id},this.sendResult=async s=>{const{id:e,topic:t,result:i,throwOnFailedPublish:r}=s,o=Be(e,i);let a,c;try{a=await this.client.core.crypto.encode(t,o)}catch(p){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${t} failed`),p}try{c=await this.client.core.history.get(t,e)}catch(p){throw this.client.logger.error(`sendResult() -> history.get(${t}, ${e}) failed`),p}const d=_[c.request.method].res;r?(d.internal=x(w({},d.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(t,a,d)):this.client.core.relayer.publish(t,a,d).catch((p=>this.client.logger.error(p))),await this.client.core.history.resolve(o)},this.sendError=async(s,e,t)=>{const i=We(s,t);let r,o;try{r=await this.client.core.crypto.encode(e,i)}catch(c){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${e} failed`),c}try{o=await this.client.core.history.get(e,s)}catch(c){throw this.client.logger.error(`sendError() -> history.get(${e}, ${s}) failed`),c}const a=_[o.request.method].res;this.client.core.relayer.publish(e,r,a),await this.client.core.history.resolve(i)},this.cleanup=async()=>{const s=[],e=[];this.client.session.getAll().forEach((t=>{let i=!1;V(t.expiry)&&(i=!0),this.client.core.crypto.keychain.has(t.topic)||(i=!0),i&&s.push(t.topic)})),this.client.proposal.getAll().forEach((t=>{V(t.expiryTimestamp)&&e.push(t.id)})),await Promise.all([...s.map((t=>this.deleteSession({topic:t}))),...e.map((t=>this.deleteProposal(t)))])},this.onRelayEventRequest=async s=>{this.requestQueue.queue.push(s),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state!==q.active){for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=q.active;const s=this.requestQueue.queue.shift();if(s)try{this.processRequest(s),await new Promise((e=>setTimeout(e,300)))}catch(e){this.client.logger.warn(e)}}this.requestQueue.state=q.idle}else this.client.logger.info("Request queue already active, skipping...")},this.processRequest=s=>{const{topic:e,payload:t}=s,i=t.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeRequest(e,t);case"wc_sessionSettle":return this.onSessionSettleRequest(e,t);case"wc_sessionUpdate":return this.onSessionUpdateRequest(e,t);case"wc_sessionExtend":return this.onSessionExtendRequest(e,t);case"wc_sessionPing":return this.onSessionPingRequest(e,t);case"wc_sessionDelete":return this.onSessionDeleteRequest(e,t);case"wc_sessionRequest":return this.onSessionRequest(e,t);case"wc_sessionEvent":return this.onSessionEventRequest(e,t);default:return this.client.logger.info(`Unsupported request method ${i}`)}},this.onRelayEventResponse=async s=>{const{topic:e,payload:t}=s,i=(await this.client.core.history.get(e,t.id)).request.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeResponse(e,t);case"wc_sessionSettle":return this.onSessionSettleResponse(e,t);case"wc_sessionUpdate":return this.onSessionUpdateResponse(e,t);case"wc_sessionExtend":return this.onSessionExtendResponse(e,t);case"wc_sessionPing":return this.onSessionPingResponse(e,t);case"wc_sessionRequest":return this.onSessionRequestResponse(e,t);default:return this.client.logger.info(`Unsupported response method ${i}`)}},this.onRelayEventUnknownPayload=s=>{const{topic:e}=s,{message:t}=l("MISSING_OR_INVALID",`Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);throw new Error(t)},this.onSessionProposeRequest=async(s,e)=>{const{params:t,id:i}=e;try{this.isValidConnect(w({},e.params));const r=t.expiryTimestamp||N(_.wc_sessionPropose.req.ttl),o=w({id:i,pairingTopic:s,expiryTimestamp:r},t);await this.setProposal(i,o);const a=z(JSON.stringify(e)),c=await this.getVerifyContext(a,o.proposer.metadata);this.client.events.emit("session_proposal",{id:i,params:o,verifyContext:c})}catch(r){await this.sendError(i,s,r),this.client.logger.error(r)}},this.onSessionProposeResponse=async(s,e)=>{const{id:t}=e;if(T(e)){const{result:i}=e;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:i});const r=this.client.proposal.get(t);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:r});const o=r.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:o});const a=i.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:a});const c=await this.client.core.crypto.generateSharedKey(o,a);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:c});const d=await this.client.core.relayer.subscribe(c);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:d}),await this.client.core.pairing.activate({topic:s})}else if(D(e)){await this.client.proposal.delete(t,R("USER_DISCONNECTED"));const i=u("session_connect");if(0===this.events.listenerCount(i))throw new Error(`emitting ${i} without any listeners, 954`);this.events.emit(u("session_connect"),{error:e.error})}},this.onSessionSettleRequest=async(s,e)=>{const{id:t,params:i}=e;try{this.isValidSessionSettleRequest(i);const{relay:r,controller:o,expiry:a,namespaces:c,sessionProperties:d,pairingTopic:p}=e.params,h=w({topic:s,relay:r,expiry:a,namespaces:c,acknowledged:!0,pairingTopic:p,requiredNamespaces:{},optionalNamespaces:{},controller:o.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},d&&{sessionProperties:d});await this.sendResult({id:e.id,topic:s,result:!0,throwOnFailedPublish:!0});const g=u("session_connect");if(0===this.events.listenerCount(g))throw new Error(`emitting ${g} without any listeners 997`);this.events.emit(u("session_connect"),{session:h}),this.cleanupDuplicatePairings(h)}catch(r){await this.sendError(t,s,r),this.client.logger.error(r)}},this.onSessionSettleResponse=async(s,e)=>{const{id:t}=e;T(e)?(await this.client.session.update(s,{acknowledged:!0}),this.events.emit(u("session_approve",t),{})):D(e)&&(await this.client.session.delete(s,R("USER_DISCONNECTED")),this.events.emit(u("session_approve",t),{error:e.error}))},this.onSessionUpdateRequest=async(s,e)=>{const{params:t,id:i}=e;try{const r=`${s}_session_update`,o=b.get(r);if(o&&this.isRequestOutOfSync(o,i))return this.client.logger.info(`Discarding out of sync request - ${i}`),void this.sendError(i,s,R("INVALID_UPDATE_REQUEST"));this.isValidUpdate(w({topic:s},t));try{b.set(r,i),await this.client.session.update(s,{namespaces:t.namespaces}),await this.sendResult({id:i,topic:s,result:!0,throwOnFailedPublish:!0})}catch(a){throw b.delete(r),a}this.client.events.emit("session_update",{id:i,topic:s,params:t})}catch(r){await this.sendError(i,s,r),this.client.logger.error(r)}},this.isRequestOutOfSync=(s,e)=>parseInt(e.toString().slice(0,-3))<=parseInt(s.toString().slice(0,-3)),this.onSessionUpdateResponse=(s,e)=>{const{id:t}=e,i=u("session_update",t);if(0===this.events.listenerCount(i))throw new Error(`emitting ${i} without any listeners`);T(e)?this.events.emit(u("session_update",t),{}):D(e)&&this.events.emit(u("session_update",t),{error:e.error})},this.onSessionExtendRequest=async(s,e)=>{const{id:t}=e;try{this.isValidExtend({topic:s}),await this.setExpiry(s,N(L)),await this.sendResult({id:t,topic:s,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:t,topic:s})}catch(i){await this.sendError(t,s,i),this.client.logger.error(i)}},this.onSessionExtendResponse=(s,e)=>{const{id:t}=e,i=u("session_extend",t);if(0===this.events.listenerCount(i))throw new Error(`emitting ${i} without any listeners`);T(e)?this.events.emit(u("session_extend",t),{}):D(e)&&this.events.emit(u("session_extend",t),{error:e.error})},this.onSessionPingRequest=async(s,e)=>{const{id:t}=e;try{this.isValidPing({topic:s}),await this.sendResult({id:t,topic:s,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:t,topic:s})}catch(i){await this.sendError(t,s,i),this.client.logger.error(i)}},this.onSessionPingResponse=(s,e)=>{const{id:t}=e,i=u("session_ping",t);if(0===this.events.listenerCount(i))throw new Error(`emitting ${i} without any listeners`);setTimeout((()=>{T(e)?this.events.emit(u("session_ping",t),{}):D(e)&&this.events.emit(u("session_ping",t),{error:e.error})}),500)},this.onSessionDeleteRequest=async(s,e)=>{const{id:t}=e;try{this.isValidDisconnect({topic:s,reason:e.params}),await Promise.all([new Promise((i=>{this.client.core.relayer.once(se.publish,(async()=>{i(await this.deleteSession({topic:s,id:t}))}))})),this.sendResult({id:t,topic:s,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:s,error:R("USER_DISCONNECTED")})])}catch(i){this.client.logger.error(i)}},this.onSessionRequest=async(s,e)=>{const{id:t,params:i}=e;try{this.isValidRequest(w({topic:s},i));const r=z(JSON.stringify(J("wc_sessionRequest",i,t))),o=this.client.session.get(s),c={id:t,topic:s,params:i,verifyContext:await this.getVerifyContext(r,o.peer.metadata)};await this.setPendingSessionRequest(c),this.addSessionRequestToSessionRequestQueue(c),this.processSessionRequestQueue()}catch(r){await this.sendError(t,s,r),this.client.logger.error(r)}},this.onSessionRequestResponse=(s,e)=>{const{id:t}=e,i=u("session_request",t);if(0===this.events.listenerCount(i))throw new Error(`emitting ${i} without any listeners`);T(e)?this.events.emit(u("session_request",t),{result:e.result}):D(e)&&this.events.emit(u("session_request",t),{error:e.error})},this.onSessionEventRequest=async(s,e)=>{const{id:t,params:i}=e;try{const r=`${s}_session_event_${i.event.name}`,o=b.get(r);if(o&&this.isRequestOutOfSync(o,t))return void this.client.logger.info(`Discarding out of sync request - ${t}`);this.isValidEmit(w({topic:s},i)),this.client.events.emit("session_event",{id:t,topic:s,params:i}),b.set(r,t)}catch(r){await this.sendError(t,s,r),this.client.logger.error(r)}},this.addSessionRequestToSessionRequestQueue=s=>{this.sessionRequestQueue.queue.push(s)},this.cleanupAfterResponse=s=>{this.deletePendingSessionRequest(s.response.id,{message:"fulfilled",code:0}),setTimeout((()=>{this.sessionRequestQueue.state=q.idle,this.processSessionRequestQueue()}),ae(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:s,error:e})=>{const t=this.client.core.history.pending;t.length>0&&t.filter((i=>i.topic===s&&"wc_sessionRequest"===i.request.method)).forEach((i=>{const r=i.request.id,o=u("session_request",r);if(0===this.events.listenerCount(o))throw new Error(`emitting ${o} without any listeners`);this.events.emit(u("session_request",i.request.id),{error:e})}))},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===q.active)return void this.client.logger.info("session request queue is already active.");const s=this.sessionRequestQueue.queue[0];if(s)try{this.sessionRequestQueue.state=q.active,this.client.events.emit("session_request",s)}catch(e){this.client.logger.error(e)}else this.client.logger.info("session request queue is empty.")},this.onPairingCreated=s=>{if(s.active)return;const e=this.client.proposal.getAll().find((t=>t.pairingTopic===s.topic));e&&this.onSessionProposeRequest(s.topic,J("wc_sessionPropose",{requiredNamespaces:e.requiredNamespaces,optionalNamespaces:e.optionalNamespaces,relays:e.relays,proposer:e.proposer,sessionProperties:e.sessionProperties},e.id))},this.isValidConnect=async s=>{if(!S(s)){const{message:a}=l("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(s)}`);throw new Error(a)}const{pairingTopic:e,requiredNamespaces:t,optionalNamespaces:i,sessionProperties:r,relays:o}=s;if(A(e)||await this.isValidPairingTopic(e),!Ce(o,!0)){const{message:a}=l("MISSING_OR_INVALID",`connect() relays: ${o}`);throw new Error(a)}!A(t)&&0!==ie(t)&&this.validateNamespaces(t,"requiredNamespaces"),!A(i)&&0!==ie(i)&&this.validateNamespaces(i,"optionalNamespaces"),A(r)||this.validateSessionProps(r,"sessionProperties")},this.validateNamespaces=(s,e)=>{const t=be(s,"connect()",e);if(t)throw new Error(t.message)},this.isValidApprove=async s=>{if(!S(s))throw new Error(l("MISSING_OR_INVALID",`approve() params: ${s}`).message);const{id:e,namespaces:t,relayProtocol:i,sessionProperties:r}=s;this.checkRecentlyDeleted(e),await this.isValidProposalId(e);const o=this.client.proposal.get(e),a=Y(t,"approve()");if(a)throw new Error(a.message);const c=re(o.requiredNamespaces,t,"approve()");if(c)throw new Error(c.message);if(!$(i,!0)){const{message:d}=l("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(d)}A(r)||this.validateSessionProps(r,"sessionProperties")},this.isValidReject=async s=>{if(!S(s)){const{message:i}=l("MISSING_OR_INVALID",`reject() params: ${s}`);throw new Error(i)}const{id:e,reason:t}=s;if(this.checkRecentlyDeleted(e),await this.isValidProposalId(e),!Ae(t)){const{message:i}=l("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidSessionSettleRequest=s=>{if(!S(s)){const{message:c}=l("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${s}`);throw new Error(c)}const{relay:e,controller:t,namespaces:i,expiry:r}=s;if(!$e(e)){const{message:c}=l("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(c)}const o=Le(t,"onSessionSettleRequest()");if(o)throw new Error(o.message);const a=Y(i,"onSessionSettleRequest()");if(a)throw new Error(a.message);if(V(r)){const{message:c}=l("EXPIRED","onSessionSettleRequest()");throw new Error(c)}},this.isValidUpdate=async s=>{if(!S(s)){const{message:a}=l("MISSING_OR_INVALID",`update() params: ${s}`);throw new Error(a)}const{topic:e,namespaces:t}=s;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const i=this.client.session.get(e),r=Y(t,"update()");if(r)throw new Error(r.message);const o=re(i.requiredNamespaces,t,"update()");if(o)throw new Error(o.message)},this.isValidExtend=async s=>{if(!S(s)){const{message:t}=l("MISSING_OR_INVALID",`extend() params: ${s}`);throw new Error(t)}const{topic:e}=s;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e)},this.isValidRequest=async s=>{if(!S(s)){const{message:a}=l("MISSING_OR_INVALID",`request() params: ${s}`);throw new Error(a)}const{topic:e,request:t,chainId:i,expiry:r}=s;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const{namespaces:o}=this.client.session.get(e);if(!ne(o,i)){const{message:a}=l("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(a)}if(!Me(t)){const{message:a}=l("MISSING_OR_INVALID",`request() ${JSON.stringify(t)}`);throw new Error(a)}if(!Ge(o,i,t.method)){const{message:a}=l("MISSING_OR_INVALID",`request() method: ${t.method}`);throw new Error(a)}if(r&&!Ue(r,Q)){const{message:a}=l("MISSING_OR_INVALID",`request() expiry: ${r}. Expiry must be a number (in seconds) between ${Q.min} and ${Q.max}`);throw new Error(a)}},this.isValidRespond=async s=>{var e;if(!S(s)){const{message:r}=l("MISSING_OR_INVALID",`respond() params: ${s}`);throw new Error(r)}const{topic:t,response:i}=s;try{await this.isValidSessionTopic(t)}catch(r){throw null!=(e=s?.response)&&e.id&&this.cleanupAfterResponse(s),r}if(!ke(i)){const{message:r}=l("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(i)}`);throw new Error(r)}},this.isValidPing=async s=>{if(!S(s)){const{message:t}=l("MISSING_OR_INVALID",`ping() params: ${s}`);throw new Error(t)}const{topic:e}=s;await this.isValidSessionOrPairingTopic(e)},this.isValidEmit=async s=>{if(!S(s)){const{message:o}=l("MISSING_OR_INVALID",`emit() params: ${s}`);throw new Error(o)}const{topic:e,event:t,chainId:i}=s;await this.isValidSessionTopic(e);const{namespaces:r}=this.client.session.get(e);if(!ne(r,i)){const{message:o}=l("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(o)}if(!Qe(t)){const{message:o}=l("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}if(!Ke(r,i,t.name)){const{message:o}=l("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}},this.isValidDisconnect=async s=>{if(!S(s)){const{message:t}=l("MISSING_OR_INVALID",`disconnect() params: ${s}`);throw new Error(t)}const{topic:e}=s;await this.isValidSessionOrPairingTopic(e)},this.getVerifyContext=async(s,e)=>{const t={verified:{verifyUrl:e.verifyUrl||Se,validation:"UNKNOWN",origin:e.url||""}};try{const i=await this.client.core.verify.resolve({attestationId:s,verifyUrl:e.verifyUrl});i&&(t.verified.origin=i.origin,t.verified.isScam=i.isScam,t.verified.validation=i.origin===new URL(e.url).origin?"VALID":"INVALID")}catch(i){this.client.logger.info(i)}return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`),t},this.validateSessionProps=(s,e)=>{Object.values(s).forEach((t=>{if(!$(t,!1)){const{message:i}=l("MISSING_OR_INVALID",`${e} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);throw new Error(i)}}))},this.addToRecentlyDeleted=(s,e)=>{if(this.recentlyDeletedMap.set(s,e),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let t=0;const i=this.recentlyDeletedLimit/2;for(const r of this.recentlyDeletedMap.keys()){if(t++>=i)break;this.recentlyDeletedMap.delete(r)}}},this.checkRecentlyDeleted=s=>{const e=this.recentlyDeletedMap.get(s);if(e){const{message:t}=l("MISSING_OR_INVALID",`Record was recently deleted - ${e}: ${s}`);throw new Error(t)}}}async isInitialized(){if(!this.initialized){const{message:n}=l("NOT_INITIALIZED",this.name);throw new Error(n)}await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(se.message,(async n=>{const{topic:s,message:e}=n;if(this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(e)))return;const t=await this.client.core.crypto.decode(s,e);try{Ze(t)?(this.client.core.history.set(s,t),this.onRelayEventRequest({topic:s,payload:t})):es(t)?(await this.client.core.history.resolve(t),await this.onRelayEventResponse({topic:s,payload:t}),this.client.core.history.delete(s,t.id)):this.onRelayEventUnknownPayload({topic:s,payload:t})}catch(i){this.client.logger.error(i)}}))}registerExpirerEvents(){this.client.core.expirer.on(Ee.expired,(async n=>{const{topic:s,id:e}=Fe(n.target);if(e&&this.client.pendingRequest.keys.includes(e))return await this.deletePendingSessionRequest(e,l("EXPIRED"),!0);s?this.client.session.keys.includes(s)&&(await this.deleteSession({topic:s,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:s})):e&&(await this.deleteProposal(e,!0),this.client.events.emit("proposal_expire",{id:e}))}))}registerPairingEvents(){this.client.core.pairing.events.on(te.create,(n=>this.onPairingCreated(n))),this.client.core.pairing.events.on(te.delete,(n=>{this.addToRecentlyDeleted(n.topic,"pairing")}))}isValidPairingTopic(n){if(!$(n,!1)){const{message:s}=l("MISSING_OR_INVALID",`pairing topic should be a string: ${n}`);throw new Error(s)}if(!this.client.core.pairing.pairings.keys.includes(n)){const{message:s}=l("NO_MATCHING_KEY",`pairing topic doesn't exist: ${n}`);throw new Error(s)}if(V(this.client.core.pairing.pairings.get(n).expiry)){const{message:s}=l("EXPIRED",`pairing topic: ${n}`);throw new Error(s)}}async isValidSessionTopic(n){if(!$(n,!1)){const{message:s}=l("MISSING_OR_INVALID",`session topic should be a string: ${n}`);throw new Error(s)}if(this.checkRecentlyDeleted(n),!this.client.session.keys.includes(n)){const{message:s}=l("NO_MATCHING_KEY",`session topic doesn't exist: ${n}`);throw new Error(s)}if(V(this.client.session.get(n).expiry)){await this.deleteSession({topic:n});const{message:s}=l("EXPIRED",`session topic: ${n}`);throw new Error(s)}if(!this.client.core.crypto.keychain.has(n)){const{message:s}=l("MISSING_OR_INVALID",`session topic does not exist in keychain: ${n}`);throw await this.deleteSession({topic:n}),new Error(s)}}async isValidSessionOrPairingTopic(n){if(this.checkRecentlyDeleted(n),this.client.session.keys.includes(n))await this.isValidSessionTopic(n);else{if(!this.client.core.pairing.pairings.keys.includes(n)){if($(n,!1)){const{message:s}=l("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${n}`);throw new Error(s)}{const{message:s}=l("MISSING_OR_INVALID",`session or pairing topic should be a string: ${n}`);throw new Error(s)}}this.isValidPairingTopic(n)}}async isValidProposalId(n){if(!je(n)){const{message:s}=l("MISSING_OR_INVALID",`proposal id should be a number: ${n}`);throw new Error(s)}if(!this.client.proposal.keys.includes(n)){const{message:s}=l("NO_MATCHING_KEY",`proposal id doesn't exist: ${n}`);throw new Error(s)}if(V(this.client.proposal.get(n).expiryTimestamp)){await this.deleteProposal(n);const{message:s}=l("EXPIRED",`proposal id: ${n}`);throw new Error(s)}}}class us extends j{constructor(n,s){super(n,s,ce,U),this.core=n,this.logger=s}}class ye extends j{constructor(n,s){super(n,s,he,U),this.core=n,this.logger=s}}class gs extends j{constructor(n,s){super(n,s,de,U,(e=>e.id)),this.core=n,this.logger=s}}class K extends Pe{constructor(n){super(n),this.protocol=X,this.version=2,this.name=k.name,this.events=new Je,this.on=(e,t)=>this.events.on(e,t),this.once=(e,t)=>this.events.once(e,t),this.off=(e,t)=>this.events.off(e,t),this.removeListener=(e,t)=>this.events.removeListener(e,t),this.removeAllListeners=e=>this.events.removeAllListeners(e),this.connect=async e=>{try{return await this.engine.connect(e)}catch(t){throw this.logger.error(t.message),t}},this.pair=async e=>{try{return await this.engine.pair(e)}catch(t){throw this.logger.error(t.message),t}},this.approve=async e=>{try{return await this.engine.approve(e)}catch(t){throw this.logger.error(t.message),t}},this.reject=async e=>{try{return await this.engine.reject(e)}catch(t){throw this.logger.error(t.message),t}},this.update=async e=>{try{return await this.engine.update(e)}catch(t){throw this.logger.error(t.message),t}},this.extend=async e=>{try{return await this.engine.extend(e)}catch(t){throw this.logger.error(t.message),t}},this.request=async e=>{try{return await this.engine.request(e)}catch(t){throw this.logger.error(t.message),t}},this.respond=async e=>{try{return await this.engine.respond(e)}catch(t){throw this.logger.error(t.message),t}},this.ping=async e=>{try{return await this.engine.ping(e)}catch(t){throw this.logger.error(t.message),t}},this.emit=async e=>{try{return await this.engine.emit(e)}catch(t){throw this.logger.error(t.message),t}},this.disconnect=async e=>{try{return await this.engine.disconnect(e)}catch(t){throw this.logger.error(t.message),t}},this.find=e=>{try{return this.engine.find(e)}catch(t){throw this.logger.error(t.message),t}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(e){throw this.logger.error(e.message),e}},this.name=n?.name||k.name,this.metadata=n?.metadata||ze();const s=typeof n?.logger<"u"&&"string"!=typeof n?.logger?n.logger:_e(qe({level:n?.logger||k.logger}));this.core=n?.core||new Ie(n),this.logger=fe(s,this.name),this.session=new ye(this.core,this.logger),this.proposal=new us(this.core,this.logger),this.pendingRequest=new gs(this.core,this.logger),this.engine=new ds(this)}static async init(n){const s=new K(n);return await s.initialize(),s}get context(){return Ne(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info("SignClient Initialization Success")}catch(n){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(n.message),n}}}const ws=ye,ys=K;export{pe as ENGINE_CONTEXT,q as ENGINE_QUEUE_STATES,_ as ENGINE_RPC_OPTS,rs as HISTORY_CONTEXT,is as HISTORY_EVENTS,ns as HISTORY_STORAGE_VERSION,ue as METHODS_TO_VERIFY,ce as PROPOSAL_CONTEXT,os as PROPOSAL_EXPIRY,le as PROPOSAL_EXPIRY_MESSAGE,de as REQUEST_CONTEXT,he as SESSION_CONTEXT,L as SESSION_EXPIRY,Q as SESSION_REQUEST_EXPIRY_BOUNDARIES,B as SIGN_CLIENT_CONTEXT,k as SIGN_CLIENT_DEFAULT,ss as SIGN_CLIENT_EVENTS,X as SIGN_CLIENT_PROTOCOL,ts as SIGN_CLIENT_STORAGE_OPTIONS,U as SIGN_CLIENT_STORAGE_PREFIX,H as SIGN_CLIENT_VERSION,ws as SessionStore,ys as SignClient,W as WALLETCONNECT_DEEPLINK_CHOICE,K as default};