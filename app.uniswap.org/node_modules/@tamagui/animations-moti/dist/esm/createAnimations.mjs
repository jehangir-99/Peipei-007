import { PresenceContext, ResetPresence, usePresence } from "@tamagui/use-presence";
import { stylePropsAll } from "@tamagui/web";
import { useMotify } from "moti/author";
import { useContext, useMemo } from "react";
import Animated, { cancelAnimation, runOnJS, useAnimatedReaction, useAnimatedStyle, useDerivedValue, useSharedValue, withSpring, withTiming } from "react-native-reanimated";
const neverAnimate = {
  flexWrap: !0,
  flexFlow: !0,
  alignContent: !0,
  backfaceVisibility: !0,
  gap: !0,
  rowGap: !0,
  columnGap: !0,
  alignItems: !0,
  backdropFilter: !0,
  borderBottomStyle: !0,
  borderLeftStyle: !0,
  borderRightStyle: !0,
  borderStyle: !0,
  borderTopStyle: !0,
  boxSizing: !0,
  contain: !0,
  margin: !0,
  marginTop: !0,
  marginLeft: !0,
  marginRight: !0,
  marginBottom: !0,
  cursor: !0,
  display: !0,
  flexBasis: !0,
  flexDirection: !0,
  flexShrink: !0,
  justifyContent: !0,
  maxHeight: !0,
  maxWidth: !0,
  minHeight: !0,
  minWidth: !0,
  outlineStyle: !0,
  overflow: !0,
  overflowX: !0,
  overflowY: !0,
  pointerEvents: !0,
  position: !0,
  shadowColor: !0,
  zIndex: !0,
  // text
  userSelect: !0,
  fontFamily: !0,
  lineHeight: !0,
  textAlign: !0,
  textOverflow: !0,
  whiteSpace: !0,
  wordWrap: !0
};
function createAnimations(animations) {
  return {
    // View: isWeb ? AnimatedView : Animated.View,
    // Text: isWeb ? AnimatedText : Animated.Text,
    View: Animated.View,
    Text: Animated.Text,
    isReactNative: !0,
    animations,
    usePresence,
    ResetPresence,
    useAnimatedNumber(initial) {
      const sharedValue = useSharedValue(initial);
      return useMemo(() => ({
        getInstance() {
          "worklet";

          return sharedValue;
        },
        getValue() {
          "worklet";

          return sharedValue.value;
        },
        setValue(next, config = {
          type: "spring"
        }, onFinish) {
          "worklet";

          config.type === "direct" ? (sharedValue.value = next, onFinish?.()) : config.type === "spring" ? sharedValue.value = withSpring(next, config, onFinish ? () => {
            "worklet";

            runOnJS(onFinish)();
          } : void 0) : sharedValue.value = withTiming(next, config, onFinish ? () => {
            "worklet";

            runOnJS(onFinish)();
          } : void 0);
        },
        stop() {
          "worklet";

          cancelAnimation(sharedValue);
        }
      }), [sharedValue]);
    },
    useAnimatedNumberReaction({
      value
    }, onValue) {
      const instance = value.getInstance();
      return useAnimatedReaction(() => instance.value, (next, prev) => {
        prev !== next && runOnJS(onValue)(next);
      },
      // dependency array is very important here
      [onValue, instance]);
    },
    /**
     * `getStyle` must be a worklet
     */
    useAnimatedNumberStyle(val, getStyle) {
      const instance = val.getInstance(),
        derivedValue = useDerivedValue(() => instance.value, [instance, getStyle]);
      return useAnimatedStyle(() => getStyle(derivedValue.value), [val, getStyle, derivedValue, instance]);
    },
    useAnimations: animationProps => {
      const {
          props,
          presence,
          style,
          onDidAnimate,
          componentState
        } = animationProps,
        animationKey = Array.isArray(props.animation) ? props.animation[0] : props.animation,
        isHydrating = componentState.unmounted === "should-enter";
      let animate = {},
        dontAnimate = {};
      if (isHydrating) dontAnimate = style;else {
        const animateOnly = props.animateOnly;
        for (const key in style) {
          const value = style[key];
          !stylePropsAll[key] || neverAnimate[key] || value === "auto" || animateOnly && !animateOnly.includes(key) ? dontAnimate[key] = value : animate[key] = value;
        }
      }
      const animateStr = JSON.stringify(animate),
        styles = useMemo(() => JSON.parse(animateStr), [animateStr]),
        isExiting = !!presence?.[1],
        presenceContext = useContext(PresenceContext),
        usePresenceValue = presence || void 0,
        motiProps = {
          animate: isExiting || isHydrating ? {} : styles,
          transition: animations[animationKey],
          usePresenceValue,
          presenceContext,
          exit: isExiting ? styles : void 0
        },
        moti = useMotify(motiProps);
      return process.env.NODE_ENV === "development" && props.debug && console.info("useMotify(", JSON.stringify(motiProps, null, 2) + ")", {
        animationProps,
        motiProps,
        moti,
        style: [dontAnimate, moti.style]
      }), {
        style: [dontAnimate, moti.style]
      };
    }
  };
}
export { createAnimations };