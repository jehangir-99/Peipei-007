/**
 * React Router v6.10.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import{UNSAFE_invariant,joinPaths,matchPath,UNSAFE_getPathContributingMatches,UNSAFE_warning,resolveTo,parsePath,matchRoutes,Action,isRouteErrorResponse,createMemoryHistory,stripBasename,AbortedDeferredError,createRouter}from"@remix-run/router";export{AbortedDeferredError,Action as NavigationType,createPath,defer,generatePath,isRouteErrorResponse,json,matchPath,matchRoutes,parsePath,redirect,resolvePath}from"@remix-run/router";import*as React from"react";function isPolyfill(x,y){return x===y&&(0!==x||1/x==1/y)||x!=x&&y!=y}const is="function"==typeof Object.is?Object.is:isPolyfill,{useState:useState,useEffect:useEffect,useLayoutEffect:useLayoutEffect,useDebugValue:useDebugValue}=React;let didWarnOld18Alpha=!1,didWarnUncachedGetSnapshot=!1;function useSyncExternalStore$2(subscribe,getSnapshot,getServerSnapshot){"production"!==process.env.NODE_ENV&&(didWarnOld18Alpha||"startTransition"in React&&(didWarnOld18Alpha=!0,console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.")));const value=getSnapshot();if("production"!==process.env.NODE_ENV&&!didWarnUncachedGetSnapshot){const cachedValue=getSnapshot();is(value,cachedValue)||(console.error("The result of getSnapshot should be cached to avoid an infinite loop"),didWarnUncachedGetSnapshot=!0)}const[{inst:inst},forceUpdate]=useState({inst:{value:value,getSnapshot:getSnapshot}});return useLayoutEffect((()=>{inst.value=value,inst.getSnapshot=getSnapshot,checkIfSnapshotChanged(inst)&&forceUpdate({inst:inst})}),[subscribe,value,getSnapshot]),useEffect((()=>{checkIfSnapshotChanged(inst)&&forceUpdate({inst:inst});return subscribe((()=>{checkIfSnapshotChanged(inst)&&forceUpdate({inst:inst})}))}),[subscribe]),useDebugValue(value),value}function checkIfSnapshotChanged(inst){const latestGetSnapshot=inst.getSnapshot,prevValue=inst.value;try{const nextValue=latestGetSnapshot();return!is(prevValue,nextValue)}catch(error){return!0}}function useSyncExternalStore$1(subscribe,getSnapshot,getServerSnapshot){return getSnapshot()}const canUseDOM=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement),isServerEnvironment=!canUseDOM,shim=isServerEnvironment?useSyncExternalStore$1:useSyncExternalStore$2,useSyncExternalStore="useSyncExternalStore"in React?React.useSyncExternalStore:shim,DataRouterContext=React.createContext(null);"production"!==process.env.NODE_ENV&&(DataRouterContext.displayName="DataRouter");const DataRouterStateContext=React.createContext(null);"production"!==process.env.NODE_ENV&&(DataRouterStateContext.displayName="DataRouterState");const AwaitContext=React.createContext(null);"production"!==process.env.NODE_ENV&&(AwaitContext.displayName="Await");const NavigationContext=React.createContext(null);"production"!==process.env.NODE_ENV&&(NavigationContext.displayName="Navigation");const LocationContext=React.createContext(null);"production"!==process.env.NODE_ENV&&(LocationContext.displayName="Location");const RouteContext=React.createContext({outlet:null,matches:[]});"production"!==process.env.NODE_ENV&&(RouteContext.displayName="Route");const RouteErrorContext=React.createContext(null);function _extends(){return _extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}function useHref(to,_temp){let{relative:relative}=void 0===_temp?{}:_temp;useInRouterContext()||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"useHref() may be used only in the context of a <Router> component."):UNSAFE_invariant(!1));let{basename:basename,navigator:navigator}=React.useContext(NavigationContext),{hash:hash,pathname:pathname,search:search}=useResolvedPath(to,{relative:relative}),joinedPathname=pathname;return"/"!==basename&&(joinedPathname="/"===pathname?basename:joinPaths([basename,pathname])),navigator.createHref({pathname:joinedPathname,search:search,hash:hash})}function useInRouterContext(){return null!=React.useContext(LocationContext)}function useLocation(){return useInRouterContext()||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"useLocation() may be used only in the context of a <Router> component."):UNSAFE_invariant(!1)),React.useContext(LocationContext).location}function useNavigationType(){return React.useContext(LocationContext).navigationType}function useMatch(pattern){useInRouterContext()||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"useMatch() may be used only in the context of a <Router> component."):UNSAFE_invariant(!1));let{pathname:pathname}=useLocation();return React.useMemo((()=>matchPath(pattern,pathname)),[pathname,pattern])}function useNavigate(){useInRouterContext()||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"useNavigate() may be used only in the context of a <Router> component."):UNSAFE_invariant(!1));let{basename:basename,navigator:navigator}=React.useContext(NavigationContext),{matches:matches}=React.useContext(RouteContext),{pathname:locationPathname}=useLocation(),routePathnamesJson=JSON.stringify(UNSAFE_getPathContributingMatches(matches).map((match=>match.pathnameBase))),activeRef=React.useRef(!1);return React.useEffect((()=>{activeRef.current=!0})),React.useCallback((function(to,options){if(void 0===options&&(options={}),"production"!==process.env.NODE_ENV&&UNSAFE_warning(activeRef.current,"You should call navigate() in a React.useEffect(), not when your component is first rendered."),!activeRef.current)return;if("number"==typeof to)return void navigator.go(to);let path=resolveTo(to,JSON.parse(routePathnamesJson),locationPathname,"path"===options.relative);"/"!==basename&&(path.pathname="/"===path.pathname?basename:joinPaths([basename,path.pathname])),(options.replace?navigator.replace:navigator.push)(path,options.state,options)}),[basename,navigator,routePathnamesJson,locationPathname])}"production"!==process.env.NODE_ENV&&(RouteErrorContext.displayName="RouteError");const OutletContext=React.createContext(null);function useOutletContext(){return React.useContext(OutletContext)}function useOutlet(context){let outlet=React.useContext(RouteContext).outlet;return outlet?React.createElement(OutletContext.Provider,{value:context},outlet):outlet}function useParams(){let{matches:matches}=React.useContext(RouteContext),routeMatch=matches[matches.length-1];return routeMatch?routeMatch.params:{}}function useResolvedPath(to,_temp2){let{relative:relative}=void 0===_temp2?{}:_temp2,{matches:matches}=React.useContext(RouteContext),{pathname:locationPathname}=useLocation(),routePathnamesJson=JSON.stringify(UNSAFE_getPathContributingMatches(matches).map((match=>match.pathnameBase)));return React.useMemo((()=>resolveTo(to,JSON.parse(routePathnamesJson),locationPathname,"path"===relative)),[to,routePathnamesJson,locationPathname,relative])}function useRoutes(routes,locationArg){useInRouterContext()||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"useRoutes() may be used only in the context of a <Router> component."):UNSAFE_invariant(!1));let{navigator:navigator}=React.useContext(NavigationContext),dataRouterStateContext=React.useContext(DataRouterStateContext),{matches:parentMatches}=React.useContext(RouteContext),routeMatch=parentMatches[parentMatches.length-1],parentParams=routeMatch?routeMatch.params:{},parentPathname=routeMatch?routeMatch.pathname:"/",parentPathnameBase=routeMatch?routeMatch.pathnameBase:"/",parentRoute=routeMatch&&routeMatch.route;if("production"!==process.env.NODE_ENV){let parentPath=parentRoute&&parentRoute.path||"";warningOnce(parentPathname,!parentRoute||parentPath.endsWith("*"),'You rendered descendant <Routes> (or called `useRoutes()`) at "'+parentPathname+'" (under <Route path="'+parentPath+'">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won\'t match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="'+parentPath+'"> to <Route path="'+("/"===parentPath?"*":parentPath+"/*")+'">.')}let location,locationFromContext=useLocation();if(locationArg){var _parsedLocationArg$pa;let parsedLocationArg="string"==typeof locationArg?parsePath(locationArg):locationArg;"/"===parentPathnameBase||(null==(_parsedLocationArg$pa=parsedLocationArg.pathname)?void 0:_parsedLocationArg$pa.startsWith(parentPathnameBase))||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,'When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "'+parentPathnameBase+'" but pathname "'+parsedLocationArg.pathname+'" was given in the `location` prop.'):UNSAFE_invariant(!1)),location=parsedLocationArg}else location=locationFromContext;let pathname=location.pathname||"/",remainingPathname="/"===parentPathnameBase?pathname:pathname.slice(parentPathnameBase.length)||"/",matches=matchRoutes(routes,{pathname:remainingPathname});"production"!==process.env.NODE_ENV&&("production"!==process.env.NODE_ENV&&UNSAFE_warning(parentRoute||null!=matches,'No routes matched location "'+location.pathname+location.search+location.hash+'" '),"production"!==process.env.NODE_ENV&&UNSAFE_warning(null==matches||void 0!==matches[matches.length-1].route.element||void 0!==matches[matches.length-1].route.Component,'Matched leaf route at location "'+location.pathname+location.search+location.hash+'" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));let renderedMatches=_renderMatches(matches&&matches.map((match=>Object.assign({},match,{params:Object.assign({},parentParams,match.params),pathname:joinPaths([parentPathnameBase,navigator.encodeLocation?navigator.encodeLocation(match.pathname).pathname:match.pathname]),pathnameBase:"/"===match.pathnameBase?parentPathnameBase:joinPaths([parentPathnameBase,navigator.encodeLocation?navigator.encodeLocation(match.pathnameBase).pathname:match.pathnameBase])}))),parentMatches,dataRouterStateContext||void 0);return locationArg&&renderedMatches?React.createElement(LocationContext.Provider,{value:{location:_extends({pathname:"/",search:"",hash:"",state:null,key:"default"},location),navigationType:Action.Pop}},renderedMatches):renderedMatches}function DefaultErrorComponent(){let error=useRouteError(),message=isRouteErrorResponse(error)?error.status+" "+error.statusText:error instanceof Error?error.message:JSON.stringify(error),stack=error instanceof Error?error.stack:null,preStyles={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"},codeStyles={padding:"2px 4px",backgroundColor:"rgba(200,200,200, 0.5)"},devInfo=null;return"production"!==process.env.NODE_ENV&&(devInfo=React.createElement(React.Fragment,null,React.createElement("p",null,"ðŸ’¿ Hey developer ðŸ‘‹"),React.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your ownÂ ",React.createElement("code",{style:codeStyles},"ErrorBoundary")," prop onÂ ",React.createElement("code",{style:codeStyles},"<Route>")))),React.createElement(React.Fragment,null,React.createElement("h2",null,"Unexpected Application Error!"),React.createElement("h3",{style:{fontStyle:"italic"}},message),stack?React.createElement("pre",{style:preStyles},stack):null,devInfo)}class RenderErrorBoundary extends React.Component{constructor(props){super(props),this.state={location:props.location,error:props.error}}static getDerivedStateFromError(error){return{error:error}}static getDerivedStateFromProps(props,state){return state.location!==props.location?{error:props.error,location:props.location}:{error:props.error||state.error,location:state.location}}componentDidCatch(error,errorInfo){console.error("React Router caught the following error during render",error,errorInfo)}render(){return this.state.error?React.createElement(RouteContext.Provider,{value:this.props.routeContext},React.createElement(RouteErrorContext.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function RenderedRoute(_ref){let{routeContext:routeContext,match:match,children:children}=_ref,dataRouterContext=React.useContext(DataRouterContext);return dataRouterContext&&dataRouterContext.static&&dataRouterContext.staticContext&&(match.route.errorElement||match.route.ErrorBoundary)&&(dataRouterContext.staticContext._deepestRenderedBoundaryId=match.route.id),React.createElement(RouteContext.Provider,{value:routeContext},children)}function _renderMatches(matches,parentMatches,dataRouterState){if(void 0===parentMatches&&(parentMatches=[]),null==matches){if(null==dataRouterState||!dataRouterState.errors)return null;matches=dataRouterState.matches}let renderedMatches=matches,errors=null==dataRouterState?void 0:dataRouterState.errors;if(null!=errors){let errorIndex=renderedMatches.findIndex((m=>m.route.id&&(null==errors?void 0:errors[m.route.id])));errorIndex>=0||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"Could not find a matching route for the current errors: "+errors):UNSAFE_invariant(!1)),renderedMatches=renderedMatches.slice(0,Math.min(renderedMatches.length,errorIndex+1))}return renderedMatches.reduceRight(((outlet,match,index)=>{let error=match.route.id?null==errors?void 0:errors[match.route.id]:null,errorElement=null;dataRouterState&&(errorElement=match.route.ErrorBoundary?React.createElement(match.route.ErrorBoundary,null):match.route.errorElement?match.route.errorElement:React.createElement(DefaultErrorComponent,null));let matches=parentMatches.concat(renderedMatches.slice(0,index+1)),getChildren=()=>{let children=outlet;return error?children=errorElement:match.route.Component?children=React.createElement(match.route.Component,null):match.route.element&&(children=match.route.element),React.createElement(RenderedRoute,{match:match,routeContext:{outlet:outlet,matches:matches},children:children})};return dataRouterState&&(match.route.ErrorBoundary||match.route.errorElement||0===index)?React.createElement(RenderErrorBoundary,{location:dataRouterState.location,component:errorElement,error:error,children:getChildren(),routeContext:{outlet:null,matches:matches}}):getChildren()}),null)}var DataRouterHook,DataRouterStateHook;function getDataRouterConsoleError(hookName){return hookName+" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router."}function useDataRouterContext(hookName){let ctx=React.useContext(DataRouterContext);return ctx||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,getDataRouterConsoleError(hookName)):UNSAFE_invariant(!1)),ctx}function useDataRouterState(hookName){let state=React.useContext(DataRouterStateContext);return state||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,getDataRouterConsoleError(hookName)):UNSAFE_invariant(!1)),state}function useRouteContext(hookName){let route=React.useContext(RouteContext);return route||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,getDataRouterConsoleError(hookName)):UNSAFE_invariant(!1)),route}function useCurrentRouteId(hookName){let route=useRouteContext(hookName),thisRoute=route.matches[route.matches.length-1];return thisRoute.route.id||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,hookName+' can only be used on routes that contain a unique "id"'):UNSAFE_invariant(!1)),thisRoute.route.id}function useNavigation(){return useDataRouterState(DataRouterStateHook.UseNavigation).navigation}function useRevalidator(){let dataRouterContext=useDataRouterContext(DataRouterHook.UseRevalidator),state=useDataRouterState(DataRouterStateHook.UseRevalidator);return{revalidate:dataRouterContext.router.revalidate,state:state.revalidation}}function useMatches(){let{matches:matches,loaderData:loaderData}=useDataRouterState(DataRouterStateHook.UseMatches);return React.useMemo((()=>matches.map((match=>{let{pathname:pathname,params:params}=match;return{id:match.route.id,pathname:pathname,params:params,data:loaderData[match.route.id],handle:match.route.handle}}))),[matches,loaderData])}function useLoaderData(){let state=useDataRouterState(DataRouterStateHook.UseLoaderData),routeId=useCurrentRouteId(DataRouterStateHook.UseLoaderData);if(!state.errors||null==state.errors[routeId])return state.loaderData[routeId];console.error("You cannot `useLoaderData` in an errorElement (routeId: "+routeId+")")}function useRouteLoaderData(routeId){return useDataRouterState(DataRouterStateHook.UseRouteLoaderData).loaderData[routeId]}function useActionData(){let state=useDataRouterState(DataRouterStateHook.UseActionData);return React.useContext(RouteContext)||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"useActionData must be used inside a RouteContext"):UNSAFE_invariant(!1)),Object.values((null==state?void 0:state.actionData)||{})[0]}function useRouteError(){var _state$errors;let error=React.useContext(RouteErrorContext),state=useDataRouterState(DataRouterStateHook.UseRouteError),routeId=useCurrentRouteId(DataRouterStateHook.UseRouteError);return error||(null==(_state$errors=state.errors)?void 0:_state$errors[routeId])}function useAsyncValue(){let value=React.useContext(AwaitContext);return null==value?void 0:value._data}function useAsyncError(){let value=React.useContext(AwaitContext);return null==value?void 0:value._error}!function(DataRouterHook){DataRouterHook.UseBlocker="useBlocker",DataRouterHook.UseRevalidator="useRevalidator"}(DataRouterHook||(DataRouterHook={})),function(DataRouterStateHook){DataRouterStateHook.UseBlocker="useBlocker",DataRouterStateHook.UseLoaderData="useLoaderData",DataRouterStateHook.UseActionData="useActionData",DataRouterStateHook.UseRouteError="useRouteError",DataRouterStateHook.UseNavigation="useNavigation",DataRouterStateHook.UseRouteLoaderData="useRouteLoaderData",DataRouterStateHook.UseMatches="useMatches",DataRouterStateHook.UseRevalidator="useRevalidator"}(DataRouterStateHook||(DataRouterStateHook={}));let blockerId=0;function useBlocker(shouldBlock){let{router:router}=useDataRouterContext(DataRouterHook.UseBlocker),state=useDataRouterState(DataRouterStateHook.UseBlocker),[blockerKey]=React.useState((()=>String(++blockerId))),blockerFunction=React.useCallback((args=>"function"==typeof shouldBlock?!!shouldBlock(args):!!shouldBlock),[shouldBlock]),blocker=router.getBlocker(blockerKey,blockerFunction);return React.useEffect((()=>()=>router.deleteBlocker(blockerKey)),[router,blockerKey]),state.blockers.get(blockerKey)||blocker}const alreadyWarned={};function warningOnce(key,cond,message){cond||alreadyWarned[key]||(alreadyWarned[key]=!0,"production"!==process.env.NODE_ENV&&UNSAFE_warning(!1,message))}function RouterProvider(_ref){let{fallbackElement:fallbackElement,router:router}=_ref,getState=React.useCallback((()=>router.state),[router]),state=useSyncExternalStore(router.subscribe,getState,getState),navigator=React.useMemo((()=>({createHref:router.createHref,encodeLocation:router.encodeLocation,go:n=>router.navigate(n),push:(to,state,opts)=>router.navigate(to,{state:state,preventScrollReset:null==opts?void 0:opts.preventScrollReset}),replace:(to,state,opts)=>router.navigate(to,{replace:!0,state:state,preventScrollReset:null==opts?void 0:opts.preventScrollReset})})),[router]),basename=router.basename||"/",dataRouterContext=React.useMemo((()=>({router:router,navigator:navigator,static:!1,basename:basename})),[router,navigator,basename]);return React.createElement(React.Fragment,null,React.createElement(DataRouterContext.Provider,{value:dataRouterContext},React.createElement(DataRouterStateContext.Provider,{value:state},React.createElement(Router,{basename:router.basename,location:router.state.location,navigationType:router.state.historyAction,navigator:navigator},router.state.initialized?React.createElement(Routes,null):fallbackElement))),null)}function MemoryRouter(_ref2){let{basename:basename,children:children,initialEntries:initialEntries,initialIndex:initialIndex}=_ref2,historyRef=React.useRef();null==historyRef.current&&(historyRef.current=createMemoryHistory({initialEntries:initialEntries,initialIndex:initialIndex,v5Compat:!0}));let history=historyRef.current,[state,setState]=React.useState({action:history.action,location:history.location});return React.useLayoutEffect((()=>history.listen(setState)),[history]),React.createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history})}function Navigate(_ref3){let{to:to,replace:replace,state:state,relative:relative}=_ref3;useInRouterContext()||("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"<Navigate> may be used only in the context of a <Router> component."):UNSAFE_invariant(!1)),"production"!==process.env.NODE_ENV&&UNSAFE_warning(!React.useContext(NavigationContext).static,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let dataRouterState=React.useContext(DataRouterStateContext),navigate=useNavigate();return React.useEffect((()=>{dataRouterState&&"idle"!==dataRouterState.navigation.state||navigate(to,{replace:replace,state:state,relative:relative})})),null}function Outlet(props){return useOutlet(props.context)}function Route(_props){"production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>."):UNSAFE_invariant(!1)}function Router(_ref4){let{basename:basenameProp="/",children:children=null,location:locationProp,navigationType:navigationType=Action.Pop,navigator:navigator,static:staticProp=!1}=_ref4;useInRouterContext()&&("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"You cannot render a <Router> inside another <Router>. You should never have more than one in your app."):UNSAFE_invariant(!1));let basename=basenameProp.replace(/^\/*/,"/"),navigationContext=React.useMemo((()=>({basename:basename,navigator:navigator,static:staticProp})),[basename,navigator,staticProp]);"string"==typeof locationProp&&(locationProp=parsePath(locationProp));let{pathname:pathname="/",search:search="",hash:hash="",state:state=null,key:key="default"}=locationProp,locationContext=React.useMemo((()=>{let trailingPathname=stripBasename(pathname,basename);return null==trailingPathname?null:{location:{pathname:trailingPathname,search:search,hash:hash,state:state,key:key},navigationType:navigationType}}),[basename,pathname,search,hash,state,key,navigationType]);return"production"!==process.env.NODE_ENV&&UNSAFE_warning(null!=locationContext,'<Router basename="'+basename+'"> is not able to match the URL "'+pathname+search+hash+"\" because it does not start with the basename, so the <Router> won't render anything."),null==locationContext?null:React.createElement(NavigationContext.Provider,{value:navigationContext},React.createElement(LocationContext.Provider,{children:children,value:locationContext}))}function Routes(_ref5){let{children:children,location:location}=_ref5,dataRouterContext=React.useContext(DataRouterContext);return useRoutes(dataRouterContext&&!children?dataRouterContext.router.routes:createRoutesFromChildren(children),location)}function Await(_ref6){let{children:children,errorElement:errorElement,resolve:resolve}=_ref6;return React.createElement(AwaitErrorBoundary,{resolve:resolve,errorElement:errorElement},React.createElement(ResolveAwait,null,children))}var AwaitRenderStatus;!function(AwaitRenderStatus){AwaitRenderStatus[AwaitRenderStatus.pending=0]="pending",AwaitRenderStatus[AwaitRenderStatus.success=1]="success",AwaitRenderStatus[AwaitRenderStatus.error=2]="error"}(AwaitRenderStatus||(AwaitRenderStatus={}));const neverSettledPromise=new Promise((()=>{}));class AwaitErrorBoundary extends React.Component{constructor(props){super(props),this.state={error:null}}static getDerivedStateFromError(error){return{error:error}}componentDidCatch(error,errorInfo){console.error("<Await> caught the following error during render",error,errorInfo)}render(){let{children:children,errorElement:errorElement,resolve:resolve}=this.props,promise=null,status=AwaitRenderStatus.pending;if(resolve instanceof Promise)if(this.state.error){status=AwaitRenderStatus.error;let renderError=this.state.error;promise=Promise.reject().catch((()=>{})),Object.defineProperty(promise,"_tracked",{get:()=>!0}),Object.defineProperty(promise,"_error",{get:()=>renderError})}else resolve._tracked?(promise=resolve,status=void 0!==promise._error?AwaitRenderStatus.error:void 0!==promise._data?AwaitRenderStatus.success:AwaitRenderStatus.pending):(status=AwaitRenderStatus.pending,Object.defineProperty(resolve,"_tracked",{get:()=>!0}),promise=resolve.then((data=>Object.defineProperty(resolve,"_data",{get:()=>data})),(error=>Object.defineProperty(resolve,"_error",{get:()=>error}))));else status=AwaitRenderStatus.success,promise=Promise.resolve(),Object.defineProperty(promise,"_tracked",{get:()=>!0}),Object.defineProperty(promise,"_data",{get:()=>resolve});if(status===AwaitRenderStatus.error&&promise._error instanceof AbortedDeferredError)throw neverSettledPromise;if(status===AwaitRenderStatus.error&&!errorElement)throw promise._error;if(status===AwaitRenderStatus.error)return React.createElement(AwaitContext.Provider,{value:promise,children:errorElement});if(status===AwaitRenderStatus.success)return React.createElement(AwaitContext.Provider,{value:promise,children:children});throw promise}}function ResolveAwait(_ref7){let{children:children}=_ref7,data=useAsyncValue(),toRender="function"==typeof children?children(data):children;return React.createElement(React.Fragment,null,toRender)}function createRoutesFromChildren(children,parentPath){void 0===parentPath&&(parentPath=[]);let routes=[];return React.Children.forEach(children,((element,index)=>{if(!React.isValidElement(element))return;let treePath=[...parentPath,index];if(element.type===React.Fragment)return void routes.push.apply(routes,createRoutesFromChildren(element.props.children,treePath));element.type!==Route&&("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"["+("string"==typeof element.type?element.type:element.type.name)+"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>"):UNSAFE_invariant(!1)),element.props.index&&element.props.children&&("production"!==process.env.NODE_ENV?UNSAFE_invariant(!1,"An index route cannot have child routes."):UNSAFE_invariant(!1));let route={id:element.props.id||treePath.join("-"),caseSensitive:element.props.caseSensitive,element:element.props.element,Component:element.props.Component,index:element.props.index,path:element.props.path,loader:element.props.loader,action:element.props.action,errorElement:element.props.errorElement,ErrorBoundary:element.props.ErrorBoundary,hasErrorBoundary:null!=element.props.ErrorBoundary||null!=element.props.errorElement,shouldRevalidate:element.props.shouldRevalidate,handle:element.props.handle,lazy:element.props.lazy};element.props.children&&(route.children=createRoutesFromChildren(element.props.children,treePath)),routes.push(route)})),routes}function renderMatches(matches){return _renderMatches(matches)}function detectErrorBoundary(route){return"production"!==process.env.NODE_ENV&&(route.Component&&route.element&&"production"!==process.env.NODE_ENV&&UNSAFE_warning(!1,"You should not include both `Component` and `element` on your route - `element` will be ignored."),route.ErrorBoundary&&route.errorElement&&"production"!==process.env.NODE_ENV&&UNSAFE_warning(!1,"You should not include both `ErrorBoundary` and `errorElement` on your route - `errorElement` will be ignored.")),Boolean(route.ErrorBoundary)||Boolean(route.errorElement)}function createMemoryRouter(routes,opts){return createRouter({basename:null==opts?void 0:opts.basename,future:null==opts?void 0:opts.future,history:createMemoryHistory({initialEntries:null==opts?void 0:opts.initialEntries,initialIndex:null==opts?void 0:opts.initialIndex}),hydrationData:null==opts?void 0:opts.hydrationData,routes:routes,detectErrorBoundary:detectErrorBoundary}).initialize()}export{Await,MemoryRouter,Navigate,Outlet,Route,Router,RouterProvider,Routes,DataRouterContext as UNSAFE_DataRouterContext,DataRouterStateContext as UNSAFE_DataRouterStateContext,LocationContext as UNSAFE_LocationContext,NavigationContext as UNSAFE_NavigationContext,RouteContext as UNSAFE_RouteContext,detectErrorBoundary as UNSAFE_detectErrorBoundary,createMemoryRouter,createRoutesFromChildren,createRoutesFromChildren as createRoutesFromElements,renderMatches,useBlocker as unstable_useBlocker,useActionData,useAsyncError,useAsyncValue,useHref,useInRouterContext,useLoaderData,useLocation,useMatch,useMatches,useNavigate,useNavigation,useNavigationType,useOutlet,useOutletContext,useParams,useResolvedPath,useRevalidator,useRouteError,useRouteLoaderData,useRoutes};