import*as React from"react";import{QueriesObserver,QueryObserver,notifyManager}from"@tanstack/query-core";import{useQueryClient}from"./QueryClientProvider.js";import{useIsRestoring}from"./isRestoring.js";import{useQueryErrorResetBoundary}from"./QueryErrorResetBoundary.js";import{ensurePreventErrorBoundaryRetry,getHasError,useClearResetErrorBoundary}from"./errorBoundaryUtils.js";import{ensureStaleTime,fetchOptimistic,shouldSuspend,willFetch}from"./suspense.js";function useQueries({queries:queries,...options},queryClient){const client=useQueryClient(queryClient),isRestoring=useIsRestoring(),errorResetBoundary=useQueryErrorResetBoundary(),defaultedQueries=React.useMemo((()=>queries.map((opts=>{const defaultedOptions=client.defaultQueryOptions(opts);return defaultedOptions._optimisticResults=isRestoring?"isRestoring":"optimistic",defaultedOptions}))),[queries,client,isRestoring]);defaultedQueries.forEach((query=>{ensureStaleTime(query),ensurePreventErrorBoundaryRetry(query,errorResetBoundary)})),useClearResetErrorBoundary(errorResetBoundary);const[observer]=React.useState((()=>new QueriesObserver(client,defaultedQueries,options))),[optimisticResult,getCombinedResult,trackResult]=observer.getOptimisticResult(defaultedQueries,options.combine);React.useSyncExternalStore(React.useCallback((onStoreChange=>isRestoring?()=>{}:observer.subscribe(notifyManager.batchCalls(onStoreChange))),[observer,isRestoring]),(()=>observer.getCurrentResult()),(()=>observer.getCurrentResult())),React.useEffect((()=>{observer.setQueries(defaultedQueries,options,{listeners:!1})}),[defaultedQueries,options,observer]);const suspensePromises=optimisticResult.some(((result,index)=>shouldSuspend(defaultedQueries[index],result)))?optimisticResult.flatMap(((result,index)=>{const opts=defaultedQueries[index];if(opts){const queryObserver=new QueryObserver(client,opts);if(shouldSuspend(opts,result))return fetchOptimistic(opts,queryObserver,errorResetBoundary);willFetch(result,isRestoring)&&fetchOptimistic(opts,queryObserver,errorResetBoundary)}return[]})):[];if(suspensePromises.length>0)throw Promise.all(suspensePromises);const firstSingleResultWhichShouldThrow=optimisticResult.find(((result,index)=>{const query=defaultedQueries[index];return query&&getHasError({result:result,errorResetBoundary:errorResetBoundary,throwOnError:query.throwOnError,query:client.getQueryCache().get(query.queryHash)})}));if(firstSingleResultWhichShouldThrow?.error)throw firstSingleResultWhichShouldThrow.error;return getCombinedResult(trackResult())}export{useQueries};