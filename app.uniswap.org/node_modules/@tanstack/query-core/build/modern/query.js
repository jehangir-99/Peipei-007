import{noop,replaceData,skipToken,timeUntilStale}from"./utils.js";import{notifyManager}from"./notifyManager.js";import{canFetch,createRetryer,isCancelledError}from"./retryer.js";import{Removable}from"./removable.js";var Query=class extends Removable{#initialState;#revertState;#cache;#retryer;#observers;#defaultOptions;#abortSignalConsumed;constructor(config){super(),this.#abortSignalConsumed=!1,this.#defaultOptions=config.defaultOptions,this.setOptions(config.options),this.#observers=[],this.#cache=config.cache,this.queryKey=config.queryKey,this.queryHash=config.queryHash,this.#initialState=config.state||getDefaultState(this.options),this.state=this.#initialState,this.scheduleGc()}get meta(){return this.options.meta}setOptions(options){this.options={...this.#defaultOptions,...options},this.updateGcTime(this.options.gcTime)}optionalRemove(){this.#observers.length||"idle"!==this.state.fetchStatus||this.#cache.remove(this)}setData(newData,options){const data=replaceData(this.state.data,newData,this.options);return this.#dispatch({data:data,type:"success",dataUpdatedAt:options?.updatedAt,manual:options?.manual}),data}setState(state,setStateOptions){this.#dispatch({type:"setState",state:state,setStateOptions:setStateOptions})}cancel(options){const promise=this.#retryer?.promise;return this.#retryer?.cancel(options),promise?promise.then(noop).catch(noop):Promise.resolve()}destroy(){super.destroy(),this.cancel({silent:!0})}reset(){this.destroy(),this.setState(this.#initialState)}isActive(){return this.#observers.some((observer=>!1!==observer.options.enabled))}isDisabled(){return this.getObserversCount()>0&&!this.isActive()}isStale(){return!!this.state.isInvalidated||(this.getObserversCount()>0?this.#observers.some((observer=>observer.getCurrentResult().isStale)):void 0===this.state.data)}isStaleByTime(staleTime=0){return this.state.isInvalidated||void 0===this.state.data||!timeUntilStale(this.state.dataUpdatedAt,staleTime)}onFocus(){const observer=this.#observers.find((x=>x.shouldFetchOnWindowFocus()));observer?.refetch({cancelRefetch:!1}),this.#retryer?.continue()}onOnline(){const observer=this.#observers.find((x=>x.shouldFetchOnReconnect()));observer?.refetch({cancelRefetch:!1}),this.#retryer?.continue()}addObserver(observer){this.#observers.includes(observer)||(this.#observers.push(observer),this.clearGcTimeout(),this.#cache.notify({type:"observerAdded",query:this,observer:observer}))}removeObserver(observer){this.#observers.includes(observer)&&(this.#observers=this.#observers.filter((x=>x!==observer)),this.#observers.length||(this.#retryer&&(this.#abortSignalConsumed?this.#retryer.cancel({revert:!0}):this.#retryer.cancelRetry()),this.scheduleGc()),this.#cache.notify({type:"observerRemoved",query:this,observer:observer}))}getObserversCount(){return this.#observers.length}invalidate(){this.state.isInvalidated||this.#dispatch({type:"invalidate"})}fetch(options,fetchOptions){if("idle"!==this.state.fetchStatus)if(void 0!==this.state.data&&fetchOptions?.cancelRefetch)this.cancel({silent:!0});else if(this.#retryer)return this.#retryer.continueRetry(),this.#retryer.promise;if(options&&this.setOptions(options),!this.options.queryFn){const observer=this.#observers.find((x=>x.options.queryFn));observer&&this.setOptions(observer.options)}"production"!==process.env.NODE_ENV&&(Array.isArray(this.options.queryKey)||console.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"));const abortController=new AbortController,queryFnContext={queryKey:this.queryKey,meta:this.meta},addSignalProperty=object=>{Object.defineProperty(object,"signal",{enumerable:!0,get:()=>(this.#abortSignalConsumed=!0,abortController.signal)})};addSignalProperty(queryFnContext);const context={fetchOptions:fetchOptions,options:this.options,queryKey:this.queryKey,state:this.state,fetchFn:()=>("production"!==process.env.NODE_ENV&&this.options.queryFn===skipToken&&console.error(`Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${this.options.queryHash}'`),this.options.queryFn&&this.options.queryFn!==skipToken?(this.#abortSignalConsumed=!1,this.options.persister?this.options.persister(this.options.queryFn,queryFnContext,this):this.options.queryFn(queryFnContext)):Promise.reject(new Error(`Missing queryFn: '${this.options.queryHash}'`)))};addSignalProperty(context),this.options.behavior?.onFetch(context,this),this.#revertState=this.state,"idle"!==this.state.fetchStatus&&this.state.fetchMeta===context.fetchOptions?.meta||this.#dispatch({type:"fetch",meta:context.fetchOptions?.meta});const onError=error=>{isCancelledError(error)&&error.silent||this.#dispatch({type:"error",error:error}),isCancelledError(error)||(this.#cache.config.onError?.(error,this),this.#cache.config.onSettled?.(this.state.data,error,this)),this.isFetchingOptimistic||this.scheduleGc(),this.isFetchingOptimistic=!1};return this.#retryer=createRetryer({fn:context.fetchFn,abort:abortController.abort.bind(abortController),onSuccess:data=>{if(void 0===data)return"production"!==process.env.NODE_ENV&&console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`),void onError(new Error(`${this.queryHash} data is undefined`));this.setData(data),this.#cache.config.onSuccess?.(data,this),this.#cache.config.onSettled?.(data,this.state.error,this),this.isFetchingOptimistic||this.scheduleGc(),this.isFetchingOptimistic=!1},onError:onError,onFail:(failureCount,error)=>{this.#dispatch({type:"failed",failureCount:failureCount,error:error})},onPause:()=>{this.#dispatch({type:"pause"})},onContinue:()=>{this.#dispatch({type:"continue"})},retry:context.options.retry,retryDelay:context.options.retryDelay,networkMode:context.options.networkMode}),this.#retryer.promise}#dispatch(action){this.state=(state=>{switch(action.type){case"failed":return{...state,fetchFailureCount:action.failureCount,fetchFailureReason:action.error};case"pause":return{...state,fetchStatus:"paused"};case"continue":return{...state,fetchStatus:"fetching"};case"fetch":return{...state,...fetchState(state.data,this.options),fetchMeta:action.meta??null};case"success":return{...state,data:action.data,dataUpdateCount:state.dataUpdateCount+1,dataUpdatedAt:action.dataUpdatedAt??Date.now(),error:null,isInvalidated:!1,status:"success",...!action.manual&&{fetchStatus:"idle",fetchFailureCount:0,fetchFailureReason:null}};case"error":const error=action.error;return isCancelledError(error)&&error.revert&&this.#revertState?{...this.#revertState,fetchStatus:"idle"}:{...state,error:error,errorUpdateCount:state.errorUpdateCount+1,errorUpdatedAt:Date.now(),fetchFailureCount:state.fetchFailureCount+1,fetchFailureReason:error,fetchStatus:"idle",status:"error"};case"invalidate":return{...state,isInvalidated:!0};case"setState":return{...state,...action.state}}})(this.state),notifyManager.batch((()=>{this.#observers.forEach((observer=>{observer.onQueryUpdate()})),this.#cache.notify({query:this,type:"updated",action:action})}))}};function fetchState(data,options){return{fetchFailureCount:0,fetchFailureReason:null,fetchStatus:canFetch(options.networkMode)?"fetching":"paused",...void 0===data&&{error:null,status:"pending"}}}function getDefaultState(options){const data="function"==typeof options.initialData?options.initialData():options.initialData,hasData=void 0!==data,initialDataUpdatedAt=hasData?"function"==typeof options.initialDataUpdatedAt?options.initialDataUpdatedAt():options.initialDataUpdatedAt:0;return{data:data,dataUpdateCount:0,dataUpdatedAt:hasData?initialDataUpdatedAt??Date.now():0,error:null,errorUpdateCount:0,errorUpdatedAt:0,fetchFailureCount:0,fetchFailureReason:null,fetchMeta:null,isInvalidated:!1,status:hasData?"success":"pending",fetchStatus:"idle"}}export{Query,fetchState};