function noop(){}const defaultDispose=noop,_WeakRef="undefined"!=typeof WeakRef?WeakRef:function(value){return{deref:()=>value}},_WeakMap="undefined"!=typeof WeakMap?WeakMap:Map,_FinalizationRegistry="undefined"!=typeof FinalizationRegistry?FinalizationRegistry:function(){return{register:noop,unregister:noop}},finalizationBatchSize=10024;export class WeakCache{constructor(max=1/0,dispose=defaultDispose){this.max=max,this.dispose=dispose,this.map=new _WeakMap,this.newest=null,this.oldest=null,this.unfinalizedNodes=new Set,this.finalizationScheduled=!1,this.size=0,this.finalize=()=>{const iterator=this.unfinalizedNodes.values();for(let i=0;i<10024;i++){const node=iterator.next().value;if(!node)break;this.unfinalizedNodes.delete(node);const key=node.key;delete node.key,node.keyRef=new _WeakRef(key),this.registry.register(key,node,node)}this.unfinalizedNodes.size>0?queueMicrotask(this.finalize):this.finalizationScheduled=!1},this.registry=new _FinalizationRegistry(this.deleteNode.bind(this))}has(key){return this.map.has(key)}get(key){const node=this.getNode(key);return node&&node.value}getNode(key){const node=this.map.get(key);if(node&&node!==this.newest){const{older:older,newer:newer}=node;newer&&(newer.older=older),older&&(older.newer=newer),node.older=this.newest,node.older.newer=node,node.newer=null,this.newest=node,node===this.oldest&&(this.oldest=newer)}return node}set(key,value){let node=this.getNode(key);return node?node.value=value:(node={key:key,value:value,newer:null,older:this.newest},this.newest&&(this.newest.newer=node),this.newest=node,this.oldest=this.oldest||node,this.scheduleFinalization(node),this.map.set(key,node),this.size++,node.value)}clean(){for(;this.oldest&&this.size>this.max;)this.deleteNode(this.oldest)}deleteNode(node){node===this.newest&&(this.newest=node.older),node===this.oldest&&(this.oldest=node.newer),node.newer&&(node.newer.older=node.older),node.older&&(node.older.newer=node.newer),this.size--;const key=node.key||node.keyRef&&node.keyRef.deref();this.dispose(node.value,key),node.keyRef?this.registry.unregister(node):this.unfinalizedNodes.delete(node),key&&this.map.delete(key)}delete(key){const node=this.map.get(key);return!!node&&(this.deleteNode(node),!0)}scheduleFinalization(node){this.unfinalizedNodes.add(node),this.finalizationScheduled||(this.finalizationScheduled=!0,queueMicrotask(this.finalize))}}