import{useContext,useCallback,useMemo}from"react";import{SECRET_INTERNAL_getScopeContext,useAtom,atom}from"jotai";const RESET=Symbol(),WRITE_ATOM="w",RESTORE_ATOMS="h";function useUpdateAtom(anAtom,scope){const ScopeContext=SECRET_INTERNAL_getScopeContext(scope),store=useContext(ScopeContext).s;return useCallback((update=>store[WRITE_ATOM](anAtom,update)),[store,anAtom])}function useAtomValue(anAtom,scope){return useAtom(anAtom,scope)[0]}function atomWithReset(initialValue){const anAtom=atom(initialValue,((get,set,update)=>{set(anAtom,update===RESET?initialValue:"function"==typeof update?update(get(anAtom)):update)}));return anAtom}function useResetAtom(anAtom,scope){const ScopeContext=SECRET_INTERNAL_getScopeContext(scope),store=useContext(ScopeContext).s;return useCallback((()=>store[WRITE_ATOM](anAtom,RESET)),[store,anAtom])}function useReducerAtom(anAtom,reducer,scope){const[state,setState]=useAtom(anAtom,scope);return[state,useCallback((action=>{setState((prev=>reducer(prev,action)))}),[setState,reducer])]}function atomWithReducer(initialValue,reducer){const anAtom=atom(initialValue,((get,set,action)=>set(anAtom,reducer(get(anAtom),action))));return anAtom}function atomFamily(initializeAtom,areEqual){let shouldRemove=null;const atoms=new Map,createAtom=param=>{let item;if(void 0===areEqual)item=atoms.get(param);else for(let[key,value]of atoms)if(areEqual(key,param)){item=value;break}if(void 0!==item){if(!(null==shouldRemove?void 0:shouldRemove(item[1],param)))return item[0];atoms.delete(param)}const newAtom=initializeAtom(param);return atoms.set(param,[newAtom,Date.now()]),newAtom};return createAtom.remove=param=>{if(void 0===areEqual)atoms.delete(param);else for(let[key]of atoms)if(areEqual(key,param)){atoms.delete(key);break}},createAtom.setShouldRemove=fn=>{if(shouldRemove=fn,shouldRemove)for(let[key,value]of atoms)shouldRemove(value[1],key)&&atoms.delete(key)},createAtom}const getWeakCacheItem=(cache,deps)=>{for(;;){const[dep,...rest]=deps,entry=cache.get(dep);if(!entry)return;if(!rest.length)return entry[1];cache=entry[0],deps=rest}},setWeakCacheItem=(cache,deps,item)=>{for(;;){const[dep,...rest]=deps;let entry=cache.get(dep);if(entry||(entry=[new WeakMap],cache.set(dep,entry)),!rest.length)return void(entry[1]=item);cache=entry[0],deps=rest}},createMemoizeAtom=()=>{const cache=new WeakMap;return(createAtom,deps)=>{const cachedAtom=getWeakCacheItem(cache,deps);if(cachedAtom)return cachedAtom;const createdAtom=createAtom();return setWeakCacheItem(cache,deps,createdAtom),createdAtom}},memoizeAtom$4=createMemoizeAtom();function selectAtom(anAtom,selector,equalityFn=Object.is){return memoizeAtom$4((()=>{const refAtom=atom((()=>({})));return atom((get=>{const slice=selector(get(anAtom)),ref=get(refAtom);return"prev"in ref&&equalityFn(ref.prev,slice)?ref.prev:(ref.prev=slice,slice)}))}),[anAtom,selector,equalityFn])}function useAtomCallback(callback,scope){const invoke=useUpdateAtom(useMemo((()=>atom(null,((get,set,[arg,resolve,reject])=>{try{resolve(callback(get,set,arg))}catch(e){reject(e)}}))),[callback]),scope);return useCallback((arg=>new Promise(((resolve,reject)=>{invoke([arg,resolve,reject])}))),[invoke])}const memoizeAtom$3=createMemoizeAtom(),deepFreeze=obj=>{if("object"!=typeof obj||null===obj)return;Object.freeze(obj);const propNames=Object.getOwnPropertyNames(obj);for(const name of propNames){const value=obj[name];deepFreeze(value)}return obj};function freezeAtom(anAtom){return memoizeAtom$3((()=>atom((get=>deepFreeze(get(anAtom))),((_get,set,arg)=>set(anAtom,arg)))),[anAtom])}function freezeAtomCreator(createAtom){return(...params)=>{const anAtom=createAtom(...params),origRead=anAtom.read;return anAtom.read=get=>deepFreeze(origRead(get)),anAtom}}const memoizeAtom$2=createMemoizeAtom(),isWritable=atom2=>!!atom2.write,isFunction=x=>"function"==typeof x;function splitAtom(arrAtom,keyExtractor){return memoizeAtom$2((()=>{const refAtom=atom((()=>({}))),read=get=>{const ref=get(refAtom);let nextAtomList=[],nextKeyList=[];return get(arrAtom).forEach(((item,index)=>{var _a,_b,_c;const key=keyExtractor?keyExtractor(item):index;nextKeyList[index]=key;const cachedAtom=null==(_c=ref.atomList)?void 0:_c[null!=(_b=null==(_a=ref.keyList)?void 0:_a.indexOf(key))?_b:-1];if(cachedAtom)return void(nextAtomList[index]=cachedAtom);const read2=get2=>{var _a2,_b2;const index2=null!=(_b2=null==(_a2=ref.keyList)?void 0:_a2.indexOf(key))?_b2:-1;return-1===index2&&"object"==typeof process&&"production"!==process.env.NODE_ENV&&console.warn("splitAtom: array index out of bounds, returning undefined",atom),get2(arrAtom)[index2]},itemAtom=isWritable(arrAtom)?atom(read2,((get2,set,update)=>{var _a2,_b2;const index2=null!=(_b2=null==(_a2=ref.keyList)?void 0:_a2.indexOf(key))?_b2:-1;if(-1===index2)throw new Error("splitAtom: array index not found");const prev=get2(arrAtom),nextItem=isFunction(update)?update(prev[index2]):update;set(arrAtom,[...prev.slice(0,index2),nextItem,...prev.slice(index2+1)])})):atom(read2);nextAtomList[index]=itemAtom})),ref.keyList=nextKeyList,ref.atomList&&ref.atomList.length===nextAtomList.length&&ref.atomList.every(((x,i)=>x===nextAtomList[i]))?ref.atomList:ref.atomList=nextAtomList},splittedAtom=isWritable(arrAtom)?atom(read,((get,set,atomToRemove)=>{const index=get(splittedAtom).indexOf(atomToRemove);if(index>=0){const prev=get(arrAtom);set(arrAtom,[...prev.slice(0,index),...prev.slice(index+1)])}})):atom(read);return splittedAtom}),keyExtractor?[arrAtom,keyExtractor]:[arrAtom])}function atomWithDefault(getDefault){const EMPTY=Symbol(),overwrittenAtom=atom(EMPTY),anAtom=atom((get=>{const overwritten=get(overwrittenAtom);return overwritten!==EMPTY?overwritten:getDefault(get)}),((get,set,update)=>{set(overwrittenAtom,update===RESET?EMPTY:"function"==typeof update?update(get(anAtom)):update)}));return anAtom}var __defProp=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp=(obj,key,value)=>key in obj?__defProp(obj,key,{enumerable:!0,configurable:!0,writable:!0,value:value}):obj[key]=value,__spreadValues=(a,b)=>{for(var prop in b||(b={}))__hasOwnProp.call(b,prop)&&__defNormalProp(a,prop,b[prop]);if(__getOwnPropSymbols)for(var prop of __getOwnPropSymbols(b))__propIsEnum.call(b,prop)&&__defNormalProp(a,prop,b[prop]);return a},__spreadProps=(a,b)=>__defProps(a,__getOwnPropDescs(b));const memoizeAtom$1=createMemoizeAtom();function waitForAll(atoms){const createAtom=()=>{const unwrappedAtoms=unwrapAtoms(atoms);return atom((get=>{const promises=[],values=unwrappedAtoms.map(((anAtom,index)=>{try{return get(anAtom)}catch(e){if(!(e instanceof Promise))throw e;promises[index]=e}}));if(promises.length)throw Promise.all(promises);return wrapResults(atoms,values)}))};return Array.isArray(atoms)?memoizeAtom$1(createAtom,atoms):createAtom()}const unwrapAtoms=atoms=>Array.isArray(atoms)?atoms:Object.getOwnPropertyNames(atoms).map((key=>atoms[key])),wrapResults=(atoms,results)=>Array.isArray(atoms)?results:Object.getOwnPropertyNames(atoms).reduce(((out,key,idx)=>__spreadProps(__spreadValues({},out),{[key]:results[idx]})),{}),createJSONStorage=getStringStorage=>({getItem:key=>{const value=getStringStorage().getItem(key);return value instanceof Promise?value.then((v=>JSON.parse(v||""))):JSON.parse(value||"")},setItem:(key,newValue)=>{getStringStorage().setItem(key,JSON.stringify(newValue))}}),defaultStorage=createJSONStorage((()=>localStorage));function atomWithStorage(key,initialValue,storage=defaultStorage){const getInitialValue=()=>{try{const value=storage.getItem(key);return value instanceof Promise?value.catch((()=>initialValue)):value}catch{return initialValue}},baseAtom=atom(storage.delayInit?initialValue:getInitialValue());baseAtom.onMount=setAtom=>{let unsub;if(storage.subscribe&&(unsub=storage.subscribe(key,setAtom)),storage.delayInit){const value=getInitialValue();value instanceof Promise?value.then(setAtom):setAtom(value)}return unsub};return atom((get=>get(baseAtom)),((get,set,update)=>{const newValue="function"==typeof update?update(get(baseAtom)):update;set(baseAtom,newValue),storage.setItem(key,newValue)}))}function atomWithHash(key,initialValue,serialize=JSON.stringify,deserialize=JSON.parse){return atomWithStorage(key,initialValue,{getItem:key2=>{const storedValue=new URLSearchParams(location.hash.slice(1)).get(key2);if(null===storedValue)throw new Error("no value stored");return deserialize(storedValue)},setItem:(key2,newValue)=>{const searchParams=new URLSearchParams(location.hash.slice(1));searchParams.set(key2,serialize(newValue)),location.hash=searchParams.toString()},delayInit:!0,subscribe:(key2,setValue)=>{const callback=()=>{const str=new URLSearchParams(location.hash.slice(1)).get(key2);null!==str&&setValue(deserialize(str))};return window.addEventListener("hashchange",callback),()=>{window.removeEventListener("hashchange",callback)}}})}function atomWithObservable(createObservable){const observableResultAtom=atom((get=>{let settlePromise=null,observable=createObservable(get);const returnsItself=observable[Symbol.observable];returnsItself&&(observable=returnsItself());const dataAtom=atom(new Promise(((resolve,reject)=>{settlePromise=(data,err)=>{err?reject(err):resolve(data)}})));let setData=()=>{throw new Error("setting data without mount")};const dataListener=data=>{settlePromise?(settlePromise(data),settlePromise=null,subscription&&!setData&&(subscription.unsubscribe(),subscription=null)):setData(data)},errorListener=error=>{settlePromise?(settlePromise(null,error),settlePromise=null,subscription&&!setData&&(subscription.unsubscribe(),subscription=null)):setData(Promise.reject(error))};let subscription=null;return subscription=observable.subscribe(dataListener,errorListener),settlePromise||(subscription.unsubscribe(),subscription=null),dataAtom.onMount=update=>(setData=update,subscription||(subscription=observable.subscribe(dataListener,errorListener)),()=>null==subscription?void 0:subscription.unsubscribe()),{dataAtom:dataAtom,observable:observable}}));return atom((get=>{const{dataAtom:dataAtom}=get(observableResultAtom);return get(dataAtom)}),((get,_set,data)=>{const{observable:observable}=get(observableResultAtom);if(!("next"in observable))throw new Error("observable is not subject");observable.next(data)}))}const hydratedMap=new WeakMap;function useHydrateAtoms(values,scope){const ScopeContext=SECRET_INTERNAL_getScopeContext(scope),scopeContainer=useContext(ScopeContext),store=scopeContainer.s,hydratedSet=getHydratedSet(scopeContainer),tuplesToRestore=[];for(const tuple of values){const atom=tuple[0];hydratedSet.has(atom)||(hydratedSet.add(atom),tuplesToRestore.push(tuple))}tuplesToRestore.length&&store.h(tuplesToRestore)}function getHydratedSet(scopeContainer){let hydratedSet=hydratedMap.get(scopeContainer);return hydratedSet||(hydratedSet=new WeakSet,hydratedMap.set(scopeContainer,hydratedSet)),hydratedSet}const memoizeAtom=createMemoizeAtom();function loadable(anAtom){return memoizeAtom((()=>{const refAtom=atom((()=>({})));return atom((get=>{const ref=get(refAtom);let curr=ref.prev;try{const value=get(anAtom);"hasData"===(null==curr?void 0:curr.state)&&Object.is(curr.data,value)||(curr={state:"hasData",data:value})}catch(error){error instanceof Promise?"loading"!==(null==curr?void 0:curr.state)&&(curr={state:"loading"}):"hasError"===(null==curr?void 0:curr.state)&&Object.is(curr.error,error)||(curr={state:"hasError",error:error})}return ref.prev=curr,curr}))}),[anAtom])}export{RESET,atomFamily,atomWithDefault,atomWithHash,atomWithObservable,atomWithReducer,atomWithReset,atomWithStorage,createJSONStorage,freezeAtom,freezeAtomCreator,loadable,selectAtom,splitAtom,useAtomCallback,useAtomValue,useHydrateAtoms,useReducerAtom,useResetAtom,useUpdateAtom,waitForAll};