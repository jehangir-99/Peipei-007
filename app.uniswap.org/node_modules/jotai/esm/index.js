import{createContext,useRef,createElement,useState,useEffect,useDebugValue,useContext,useCallback,useReducer}from"react";var __defProp=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp=(obj,key,value)=>key in obj?__defProp(obj,key,{enumerable:!0,configurable:!0,writable:!0,value:value}):obj[key]=value,__spreadValues=(a,b)=>{for(var prop in b||(b={}))__hasOwnProp.call(b,prop)&&__defNormalProp(a,prop,b[prop]);if(__getOwnPropSymbols)for(var prop of __getOwnPropSymbols(b))__propIsEnum.call(b,prop)&&__defNormalProp(a,prop,b[prop]);return a},__spreadProps=(a,b)=>__defProps(a,__getOwnPropDescs(b));const hasInitialValue=atom=>"init"in atom,IS_EQUAL_PROMISE=Symbol(),INTERRUPT_PROMISE=Symbol(),isInterruptablePromise=promise=>!!promise[INTERRUPT_PROMISE],createInterruptablePromise=promise=>{let interrupt;const interruptablePromise=new Promise(((resolve,reject)=>{interrupt=resolve,promise.then(resolve,reject)}));return interruptablePromise[IS_EQUAL_PROMISE]=p=>interruptablePromise===p||promise===p||isInterruptablePromise(promise)&&promise[IS_EQUAL_PROMISE](p),interruptablePromise[INTERRUPT_PROMISE]=interrupt,interruptablePromise},READ_ATOM="r",WRITE_ATOM="w",COMMIT_ATOM="c",SUBSCRIBE_ATOM="s",RESTORE_ATOMS="h",DEV_SUBSCRIBE_STATE="n",DEV_GET_MOUNTED_ATOMS="l",DEV_GET_ATOM_STATE="a",DEV_GET_MOUNTED="m",createStore=initialValues=>{const atomStateMap=new WeakMap,mountedMap=new WeakMap,pendingMap=new Map;let stateListeners,mountedAtoms;if("object"==typeof process&&"production"!==process.env.NODE_ENV&&(stateListeners=new Set,mountedAtoms=new Set),initialValues)for(const[atom,value]of initialValues){const atomState={v:value,r:0,d:new Map};"object"==typeof process&&"production"!==process.env.NODE_ENV&&(Object.freeze(atomState),hasInitialValue(atom)||console.warn("Found initial value for derived atom which can cause unexpected behavior",atom)),atomStateMap.set(atom,atomState)}const getAtomState=atom=>atomStateMap.get(atom),setAtomState=(atom,atomState,prevDependencies)=>{"object"==typeof process&&"production"!==process.env.NODE_ENV&&Object.freeze(atomState);const isNewAtom=!atomStateMap.has(atom);atomStateMap.set(atom,atomState),pendingMap.has(atom)||pendingMap.set(atom,[prevDependencies,isNewAtom])},prepareNextAtomState=(atom,dependencies)=>{const atomState=getAtomState(atom);return[__spreadProps(__spreadValues({r:0},atomState),{d:dependencies?new Map(Array.from(dependencies).map((a=>{var _a,_b;return[a,null!=(_b=null==(_a=getAtomState(a))?void 0:_a.r)?_b:0]}))):(null==atomState?void 0:atomState.d)||new Map}),(null==atomState?void 0:atomState.d)||new Map]},setAtomValue=(atom,value,dependencies,promise)=>{var _a,_b;const[atomState,prevDependencies]=prepareNextAtomState(atom,dependencies);promise&&!(null==(_a=atomState.p)?void 0:_a[IS_EQUAL_PROMISE](promise))||(null==(_b=atomState.c)||_b.call(atomState),!("e"in atomState)&&!atomState.p&&"v"in atomState&&Object.is(atomState.v,value)||(++atomState.r,atomState.d.has(atom)&&atomState.d.set(atom,atomState.r)),atomState.v=value,delete atomState.e,delete atomState.p,delete atomState.c,delete atomState.i,setAtomState(atom,atomState,dependencies&&prevDependencies))},setAtomReadError=(atom,error,dependencies,promise)=>{var _a,_b;const[atomState,prevDependencies]=prepareNextAtomState(atom,dependencies);promise&&!(null==(_a=atomState.p)?void 0:_a[IS_EQUAL_PROMISE](promise))||(null==(_b=atomState.c)||_b.call(atomState),delete atomState.p,delete atomState.c,delete atomState.i,atomState.e=error,setAtomState(atom,atomState,prevDependencies))},setAtomReadPromise=(atom,promise,dependencies)=>{var _a,_b;const[atomState,prevDependencies]=prepareNextAtomState(atom,dependencies);if(null==(_a=atomState.p)?void 0:_a[IS_EQUAL_PROMISE](promise))return;null==(_b=atomState.c)||_b.call(atomState),delete atomState.e;const interruptablePromise=createInterruptablePromise(promise);atomState.p=interruptablePromise,atomState.c=interruptablePromise[INTERRUPT_PROMISE],setAtomState(atom,atomState,prevDependencies)},setAtomWritePromise=(atom,promise,prevPromise)=>{const[atomState]=prepareNextAtomState(atom);promise?atomState.w=promise:atomState.w===prevPromise&&delete atomState.w,setAtomState(atom,atomState)},readAtomState=(atom,force)=>{if(!force){const atomState=getAtomState(atom);if(atomState&&(atomState.d.forEach(((_,a)=>{if(a!==atom){const aState=getAtomState(a);!aState||"e"in aState||aState.p||aState.r!==aState.i||readAtomState(a,!0)}})),Array.from(atomState.d.entries()).every((([a,r])=>{const aState=getAtomState(a);return aState&&!("e"in aState)&&!aState.p&&aState.r!==aState.i&&aState.r===r}))))return atomState}let error,promise,value;const dependencies=new Set;try{const promiseOrValue=atom.read((a=>{dependencies.add(a);const aState=a===atom?getAtomState(a):readAtomState(a);if(aState){if("e"in aState)throw aState.e;if(aState.p)throw aState.p;return aState.v}if(hasInitialValue(a))return a.init;throw new Error("no atom init")}));promiseOrValue instanceof Promise?promise=promiseOrValue.then((value2=>{setAtomValue(atom,value2,dependencies,promise),flushPending()})).catch((e=>{if(e instanceof Promise)return((atom,promise)=>{promise.finally((()=>{readAtomState(atom,!0)}))})(atom,e),e;setAtomReadError(atom,e,dependencies,promise),flushPending()})):value=promiseOrValue}catch(errorOrPromise){errorOrPromise instanceof Promise?promise=errorOrPromise:error=errorOrPromise}return error?setAtomReadError(atom,error,dependencies):promise?setAtomReadPromise(atom,promise,dependencies):setAtomValue(atom,value,dependencies),getAtomState(atom)},readAtom=readingAtom=>readAtomState(readingAtom),canUnmountAtom=(atom,mounted)=>!mounted.l.size&&(!mounted.d.size||1===mounted.d.size&&mounted.d.has(atom)),invalidateDependents=atom=>{const mounted=mountedMap.get(atom);null==mounted||mounted.d.forEach((dependent=>{dependent!==atom&&((atom=>{const[atomState]=prepareNextAtomState(atom);atomState.i=atomState.r,setAtomState(atom,atomState)})(dependent),invalidateDependents(dependent))}))},writeAtomState=(atom,update)=>{const writeGetter=(a,unstable_promise=!1)=>{const aState=readAtomState(a);if("e"in aState)throw aState.e;if(aState.p){if("object"==typeof process&&"production"!==process.env.NODE_ENV&&(unstable_promise?console.info("promise option in getter is an experimental feature.",a):console.warn("Reading pending atom state in write operation. We throw a promise for now.",a)),unstable_promise)return aState.p.then((()=>writeGetter(a,unstable_promise)));throw aState.p}if("v"in aState)return aState.v;throw"object"==typeof process&&"production"!==process.env.NODE_ENV&&console.warn("[Bug] no value found while reading atom in write operation. This is probably a bug.",a),new Error("no value found")},promiseOrVoid=atom.write(writeGetter,((a,v)=>{let promiseOrVoid2;if(a===atom){if(!hasInitialValue(a))throw new Error("no atom init");v instanceof Promise?(promiseOrVoid2=v.then((resolvedValue=>{setAtomValue(a,resolvedValue),invalidateDependents(a),flushPending()})).catch((e=>{setAtomReadError(atom,e),flushPending()})),setAtomReadPromise(atom,promiseOrVoid2)):setAtomValue(a,v),invalidateDependents(a),flushPending()}else promiseOrVoid2=writeAtomState(a,v);return promiseOrVoid2}),update);if(promiseOrVoid instanceof Promise){const promise=promiseOrVoid.finally((()=>{setAtomWritePromise(atom,null,promise),flushPending()}));setAtomWritePromise(atom,promise)}return flushPending(),promiseOrVoid},writeAtom=(writingAtom,update)=>writeAtomState(writingAtom,update),mountAtom=(atom,initialDependent)=>{readAtomState(atom).d.forEach(((_,a)=>{if(a!==atom){const aMounted=mountedMap.get(a);aMounted?aMounted.d.add(atom):mountAtom(a,atom)}}));const mounted={d:new Set(initialDependent&&[initialDependent]),l:new Set,u:void 0};if(mountedMap.set(atom,mounted),"object"==typeof process&&"production"!==process.env.NODE_ENV&&mountedAtoms.add(atom),(atom=>!!atom.write)(atom)&&atom.onMount){const setAtom=update=>writeAtom(atom,update);mounted.u=atom.onMount(setAtom)}return mounted},unmountAtom=atom=>{var _a;const onUnmount=null==(_a=mountedMap.get(atom))?void 0:_a.u;onUnmount&&onUnmount(),mountedMap.delete(atom),"object"==typeof process&&"production"!==process.env.NODE_ENV&&mountedAtoms.delete(atom);const atomState=getAtomState(atom);atomState?atomState.d.forEach(((_,a)=>{if(a!==atom){const mounted=mountedMap.get(a);mounted&&(mounted.d.delete(atom),canUnmountAtom(a,mounted)&&unmountAtom(a))}})):"object"==typeof process&&"production"!==process.env.NODE_ENV&&console.warn("[Bug] could not find atom state to unmount",atom)},flushPending=()=>{const pending=Array.from(pendingMap);pendingMap.clear(),pending.forEach((([atom,[prevDependencies,isNewAtom]])=>{if(prevDependencies){const atomState=getAtomState(atom);atomState&&((atom,atomState,prevDependencies)=>{const dependencies=new Set(atomState.d.keys());prevDependencies.forEach(((_,a)=>{if(dependencies.has(a))return void dependencies.delete(a);const mounted=mountedMap.get(a);mounted&&(mounted.d.delete(atom),canUnmountAtom(a,mounted)&&unmountAtom(a))})),dependencies.forEach((a=>{const mounted=mountedMap.get(a);mounted?mounted.d.add(atom):mountAtom(a,atom)}))})(atom,atomState,prevDependencies)}const mounted=mountedMap.get(atom);null==mounted||mounted.l.forEach((listener=>listener())),"object"==typeof process&&"production"!==process.env.NODE_ENV&&stateListeners.forEach((l=>l(atom,isNewAtom)))}))},commitAtom=_atom=>{flushPending()},subscribeAtom=(atom,callback)=>{const listeners=(addingAtom=>{let mounted=mountedMap.get(addingAtom);return mounted||(mounted=mountAtom(addingAtom)),mounted})(atom).l;return listeners.add(callback),()=>{listeners.delete(callback),(deletingAtom=>{const mounted=mountedMap.get(deletingAtom);mounted&&canUnmountAtom(deletingAtom,mounted)&&unmountAtom(deletingAtom)})(atom)}},restoreAtoms=values=>{for(const[atom,value]of values)hasInitialValue(atom)&&(setAtomValue(atom,value),invalidateDependents(atom));flushPending()};return"object"==typeof process&&"production"!==process.env.NODE_ENV?{r:readAtom,w:writeAtom,c:commitAtom,s:subscribeAtom,h:restoreAtoms,n:l=>(stateListeners.add(l),()=>{stateListeners.delete(l)}),l:()=>mountedAtoms.values(),a:a=>atomStateMap.get(a),m:a=>mountedMap.get(a)}:{r:readAtom,w:writeAtom,c:commitAtom,s:subscribeAtom,h:restoreAtoms}},createScopeContainer=initialValues=>({s:createStore(initialValues)}),ScopeContextMap=new Map,getScopeContext=scope=>(ScopeContextMap.has(scope)||ScopeContextMap.set(scope,createContext(createScopeContainer())),ScopeContextMap.get(scope)),Provider=({initialValues:initialValues,scope:scope,children:children})=>{const scopeContainerRef=useRef();scopeContainerRef.current||(scopeContainerRef.current=createScopeContainer(initialValues)),"object"==typeof process&&"production"!==process.env.NODE_ENV&&"test"!==process.env.NODE_ENV&&useDebugState(scopeContainerRef.current);const ScopeContainerContext=getScopeContext(scope);return createElement(ScopeContainerContext.Provider,{value:scopeContainerRef.current},children)},atomToPrintable=atom=>atom.debugLabel||atom.toString(),stateToPrintable=([store,atoms])=>Object.fromEntries(atoms.flatMap((atom=>{var _a,_b;const mounted=null==(_a=store.m)?void 0:_a.call(store,atom);if(!mounted)return[];const dependents=mounted.d,atomState=(null==(_b=store.a)?void 0:_b.call(store,atom))||{};return[[atomToPrintable(atom),{value:atomState.e||atomState.p||atomState.w||atomState.v,dependents:Array.from(dependents).map(atomToPrintable)}]]}))),useDebugState=scopeContainer=>{const store=scopeContainer.s,[atoms,setAtoms]=useState([]);useEffect((()=>{var _a;const callback=()=>{var _a2;setAtoms(Array.from((null==(_a2=store.l)?void 0:_a2.call(store))||[]))},unsubscribe=null==(_a=store.n)?void 0:_a.call(store,callback);return callback(),unsubscribe}),[store]),useDebugValue([store,atoms],stateToPrintable)};let keyCount=0;function atom(read,write){const key="atom"+ ++keyCount,config={toString:()=>key};return"function"==typeof read?config.read=read:(config.init=read,config.read=get=>get(config),config.write=(get,set,update)=>{set(config,"function"==typeof update?update(get(config)):update)}),write&&(config.write=write),config}const isWritable=atom=>!!atom.write;function useAtom(atom,scope){"scope"in atom&&(console.warn("atom.scope is deprecated. Please do useAtom(atom, scope) instead."),scope=atom.scope);const ScopeContext=getScopeContext(scope),store=useContext(ScopeContext).s,getAtomValue=useCallback((()=>{const atomState=store.r(atom);if("e"in atomState)throw atomState.e;if(atomState.p)throw atomState.p;if(atomState.w)throw atomState.w;if("v"in atomState)return atomState.v;throw new Error("no atom value")}),[store,atom]),[value,forceUpdate]=useReducer(getAtomValue,void 0,getAtomValue);useEffect((()=>{const unsubscribe=store.s(atom,forceUpdate);return forceUpdate(),unsubscribe}),[store,atom]),useEffect((()=>{store.c(atom)}));const setAtom=useCallback((update=>{if(isWritable(atom))return store.w(atom,update);throw new Error("not writable atom")}),[store,atom]);return useDebugValue(value),[value,setAtom]}export{Provider,getScopeContext as SECRET_INTERNAL_getScopeContext,atom,useAtom};