"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RelayEventWatcher=exports.UniswapXEventWatcher=void 0;const tslib_1=require("tslib"),ethers_1=require("ethers"),MockERC20_json_1=tslib_1.__importDefault(require("../../abis/MockERC20.json")),contracts_1=require("../contracts"),TRANSFER="Transfer";class EventWatcher{constructor(reactor){this.reactor=reactor}getFillEvents(fromBlock,toBlock){return tslib_1.__awaiter(this,void 0,void 0,(function*(){return(yield this.getFillLogs(fromBlock,toBlock)).map((log=>log.args))}))}getFillInfo(fromBlock,toBlock){return tslib_1.__awaiter(this,void 0,void 0,(function*(){const logs=yield this.getFillLogs(fromBlock,toBlock),events=logs.map((log=>log.args)),txs=logs.reduce(((acc,log)=>acc.add(this.reactor.provider.getTransactionReceipt(log.transactionHash))),new Set),txReceipts=yield Promise.all(txs);return events.map(((e,i)=>({orderHash:e.orderHash,swapper:e.swapper,filler:e.filler,nonce:e.nonce,txLogs:txReceipts[i].logs,blockNumber:txReceipts[i].blockNumber,txHash:txReceipts[i].transactionHash}))).map((fill=>{const outputs=this.getTokenTransfers(fill.txLogs,fill.swapper),inputs=this.getTokenTransfers(fill.txLogs,fill.filler);return{orderHash:fill.orderHash,swapper:fill.swapper,filler:fill.filler,nonce:fill.nonce,blockNumber:fill.blockNumber,txHash:fill.txHash,inputs:inputs,outputs:outputs}}))}))}getTokenTransfers(logs,recipient){const ERC20Interface=new ethers_1.utils.Interface(MockERC20_json_1.default.abi);return logs.reduce(((logAcc,log)=>{try{const parsedLog=ERC20Interface.parseLog(log);return parsedLog.name===TRANSFER&&parsedLog.args.to===recipient&&logAcc.push({token:log.address,amount:parsedLog.args.amount}),logAcc}catch(e){return logAcc}}),[])}}class UniswapXEventWatcher extends EventWatcher{constructor(provider,reactorAddress){super(contracts_1.ExclusiveDutchOrderReactor__factory.connect(reactorAddress,provider))}getFillLogs(fromBlock,toBlock){return tslib_1.__awaiter(this,void 0,void 0,(function*(){return yield this.reactor.queryFilter(this.reactor.filters.Fill(),fromBlock,toBlock)}))}onFill(callback){this.reactor.on(this.reactor.filters.Fill(),((orderHash,filler,swapper,nonce,event)=>{callback({orderHash:orderHash,filler:filler,nonce:nonce,swapper:swapper},event)}))}}exports.UniswapXEventWatcher=UniswapXEventWatcher;class RelayEventWatcher extends EventWatcher{constructor(provider,reactorAddress){super(contracts_1.RelayOrderReactor__factory.connect(reactorAddress,provider))}getFillLogs(fromBlock,toBlock){return tslib_1.__awaiter(this,void 0,void 0,(function*(){return yield this.reactor.queryFilter(this.reactor.filters.Relay(),fromBlock,toBlock)}))}onFill(callback){this.reactor.on(this.reactor.filters.Relay(),((orderHash,filler,swapper,nonce,event)=>{callback({orderHash:orderHash,filler:filler,nonce:nonce,swapper:swapper},event)}))}}exports.RelayEventWatcher=RelayEventWatcher;