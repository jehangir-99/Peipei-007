"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createDataView=exports.concatBytes=exports.valueToBytes=exports.stringToBytes=exports.numberToBytes=exports.signedBigIntToBytes=exports.bigIntToBytes=exports.hexToBytes=exports.bytesToString=exports.bytesToNumber=exports.bytesToSignedBigInt=exports.bytesToBigInt=exports.bytesToHex=exports.assertIsBytes=exports.isBytes=void 0;const assert_1=require("./assert"),hex_1=require("./hex"),HEX_MINIMUM_NUMBER_CHARACTER=48,HEX_MAXIMUM_NUMBER_CHARACTER=58,HEX_CHARACTER_OFFSET=87;function getPrecomputedHexValuesBuilder(){const lookupTable=[];return()=>{if(0===lookupTable.length)for(let i=0;i<256;i++)lookupTable.push(i.toString(16).padStart(2,"0"));return lookupTable}}const getPrecomputedHexValues=getPrecomputedHexValuesBuilder();function isBytes(value){return value instanceof Uint8Array}function assertIsBytes(value){(0,assert_1.assert)(isBytes(value),"Value must be a Uint8Array.")}function bytesToHex(bytes){if(assertIsBytes(bytes),0===bytes.length)return"0x";const lookupTable=getPrecomputedHexValues(),hexadecimal=new Array(bytes.length);for(let i=0;i<bytes.length;i++)hexadecimal[i]=lookupTable[bytes[i]];return(0,hex_1.add0x)(hexadecimal.join(""))}function bytesToBigInt(bytes){assertIsBytes(bytes);const hexadecimal=bytesToHex(bytes);return BigInt(hexadecimal)}function bytesToSignedBigInt(bytes){assertIsBytes(bytes);let value=BigInt(0);for(const byte of bytes)value=(value<<BigInt(8))+BigInt(byte);return BigInt.asIntN(8*bytes.length,value)}function bytesToNumber(bytes){assertIsBytes(bytes);const bigint=bytesToBigInt(bytes);return(0,assert_1.assert)(bigint<=BigInt(Number.MAX_SAFE_INTEGER),"Number is not a safe integer. Use `bytesToBigInt` instead."),Number(bigint)}function bytesToString(bytes){return assertIsBytes(bytes),(new TextDecoder).decode(bytes)}function hexToBytes(value){var _a;if("0x"===(null===(_a=null==value?void 0:value.toLowerCase)||void 0===_a?void 0:_a.call(value)))return new Uint8Array;(0,hex_1.assertIsHexString)(value);const strippedValue=(0,hex_1.remove0x)(value).toLowerCase(),normalizedValue=strippedValue.length%2==0?strippedValue:`0${strippedValue}`,bytes=new Uint8Array(normalizedValue.length/2);for(let i=0;i<bytes.length;i++){const c1=normalizedValue.charCodeAt(2*i),c2=normalizedValue.charCodeAt(2*i+1),n1=c1-(c1<HEX_MAXIMUM_NUMBER_CHARACTER?HEX_MINIMUM_NUMBER_CHARACTER:HEX_CHARACTER_OFFSET),n2=c2-(c2<HEX_MAXIMUM_NUMBER_CHARACTER?HEX_MINIMUM_NUMBER_CHARACTER:HEX_CHARACTER_OFFSET);bytes[i]=16*n1+n2}return bytes}function bigIntToBytes(value){(0,assert_1.assert)("bigint"==typeof value,"Value must be a bigint."),(0,assert_1.assert)(value>=BigInt(0),"Value must be a non-negative bigint.");return hexToBytes(value.toString(16))}function bigIntFits(value,bytes){(0,assert_1.assert)(bytes>0);const mask=value>>BigInt(31);return!((~value&mask)+(value&~mask)>>BigInt(8*bytes-1))}function signedBigIntToBytes(value,byteLength){(0,assert_1.assert)("bigint"==typeof value,"Value must be a bigint."),(0,assert_1.assert)("number"==typeof byteLength,"Byte length must be a number."),(0,assert_1.assert)(byteLength>0,"Byte length must be greater than 0."),(0,assert_1.assert)(bigIntFits(value,byteLength),"Byte length is too small to represent the given value.");let numberValue=value;const bytes=new Uint8Array(byteLength);for(let i=0;i<bytes.length;i++)bytes[i]=Number(BigInt.asUintN(8,numberValue)),numberValue>>=BigInt(8);return bytes.reverse()}function numberToBytes(value){(0,assert_1.assert)("number"==typeof value,"Value must be a number."),(0,assert_1.assert)(value>=0,"Value must be a non-negative number."),(0,assert_1.assert)(Number.isSafeInteger(value),"Value is not a safe integer. Use `bigIntToBytes` instead.");return hexToBytes(value.toString(16))}function stringToBytes(value){return(0,assert_1.assert)("string"==typeof value,"Value must be a string."),(new TextEncoder).encode(value)}function valueToBytes(value){if("bigint"==typeof value)return bigIntToBytes(value);if("number"==typeof value)return numberToBytes(value);if("string"==typeof value)return value.startsWith("0x")?hexToBytes(value):stringToBytes(value);if(isBytes(value))return value;throw new TypeError(`Unsupported value type: "${typeof value}".`)}function concatBytes(values){const normalizedValues=new Array(values.length);let byteLength=0;for(let i=0;i<values.length;i++){const value=valueToBytes(values[i]);normalizedValues[i]=value,byteLength+=value.length}const bytes=new Uint8Array(byteLength);for(let i=0,offset=0;i<normalizedValues.length;i++)bytes.set(normalizedValues[i],offset),offset+=normalizedValues[i].length;return bytes}function createDataView(bytes){if("undefined"!=typeof Buffer&&bytes instanceof Buffer){const buffer=bytes.buffer.slice(bytes.byteOffset,bytes.byteOffset+bytes.byteLength);return new DataView(buffer)}return new DataView(bytes.buffer,bytes.byteOffset,bytes.byteLength)}exports.isBytes=isBytes,exports.assertIsBytes=assertIsBytes,exports.bytesToHex=bytesToHex,exports.bytesToBigInt=bytesToBigInt,exports.bytesToSignedBigInt=bytesToSignedBigInt,exports.bytesToNumber=bytesToNumber,exports.bytesToString=bytesToString,exports.hexToBytes=hexToBytes,exports.bigIntToBytes=bigIntToBytes,exports.signedBigIntToBytes=signedBigIntToBytes,exports.numberToBytes=numberToBytes,exports.stringToBytes=stringToBytes,exports.valueToBytes=valueToBytes,exports.concatBytes=concatBytes,exports.createDataView=createDataView;