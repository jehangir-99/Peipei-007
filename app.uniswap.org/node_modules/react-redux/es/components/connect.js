import _extends from"@babel/runtime/helpers/esm/extends";import _objectWithoutPropertiesLoose from"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";const _excluded=["reactReduxForwardedRef"];import hoistStatics from"hoist-non-react-statics";import React,{useContext,useMemo,useRef}from"react";import{isValidElementType,isContextConsumer}from"react-is";import defaultSelectorFactory from"../connect/selectorFactory";import{mapDispatchToPropsFactory}from"../connect/mapDispatchToProps";import{mapStateToPropsFactory}from"../connect/mapStateToProps";import{mergePropsFactory}from"../connect/mergeProps";import{createSubscription}from"../utils/Subscription";import{useIsomorphicLayoutEffect}from"../utils/useIsomorphicLayoutEffect";import shallowEqual from"../utils/shallowEqual";import warning from"../utils/warning";import{ReactReduxContext}from"./Context";import{notInitialized}from"../utils/useSyncExternalStore";let useSyncExternalStore=notInitialized;export const initializeConnect=fn=>{useSyncExternalStore=fn};const EMPTY_ARRAY=[null,0],NO_SUBSCRIPTION_ARRAY=[null,null],stringifyComponent=Comp=>{try{return JSON.stringify(Comp)}catch(err){return String(Comp)}};function useIsomorphicLayoutEffectWithArgs(effectFunc,effectArgs,dependencies){useIsomorphicLayoutEffect((()=>effectFunc(...effectArgs)),dependencies)}function captureWrapperProps(lastWrapperProps,lastChildProps,renderIsScheduled,wrapperProps,childPropsFromStoreUpdate,notifyNestedSubs){lastWrapperProps.current=wrapperProps,renderIsScheduled.current=!1,childPropsFromStoreUpdate.current&&(childPropsFromStoreUpdate.current=null,notifyNestedSubs())}function subscribeUpdates(shouldHandleStateChanges,store,subscription,childPropsSelector,lastWrapperProps,lastChildProps,renderIsScheduled,isMounted,childPropsFromStoreUpdate,notifyNestedSubs,additionalSubscribeListener){if(!shouldHandleStateChanges)return()=>{};let didUnsubscribe=!1,lastThrownError=null;const checkForUpdates=()=>{if(didUnsubscribe||!isMounted.current)return;const latestStoreState=store.getState();let newChildProps,error;try{newChildProps=childPropsSelector(latestStoreState,lastWrapperProps.current)}catch(e){error=e,lastThrownError=e}error||(lastThrownError=null),newChildProps===lastChildProps.current?renderIsScheduled.current||notifyNestedSubs():(lastChildProps.current=newChildProps,childPropsFromStoreUpdate.current=newChildProps,renderIsScheduled.current=!0,additionalSubscribeListener())};subscription.onStateChange=checkForUpdates,subscription.trySubscribe(),checkForUpdates();return()=>{if(didUnsubscribe=!0,subscription.tryUnsubscribe(),subscription.onStateChange=null,lastThrownError)throw lastThrownError}}const initStateUpdates=()=>EMPTY_ARRAY;function strictEqual(a,b){return a===b}let hasWarnedAboutDeprecatedPureOption=!1;function connect(mapStateToProps,mapDispatchToProps,mergeProps,{pure:pure,areStatesEqual:areStatesEqual=strictEqual,areOwnPropsEqual:areOwnPropsEqual=shallowEqual,areStatePropsEqual:areStatePropsEqual=shallowEqual,areMergedPropsEqual:areMergedPropsEqual=shallowEqual,forwardRef:forwardRef=!1,context:context=ReactReduxContext}={}){"production"!==process.env.NODE_ENV&&(void 0===pure||hasWarnedAboutDeprecatedPureOption||(hasWarnedAboutDeprecatedPureOption=!0,warning('The `pure` option has been removed. `connect` is now always a "pure/memoized" component')));const Context=context,initMapStateToProps=mapStateToPropsFactory(mapStateToProps),initMapDispatchToProps=mapDispatchToPropsFactory(mapDispatchToProps),initMergeProps=mergePropsFactory(mergeProps),shouldHandleStateChanges=Boolean(mapStateToProps);return WrappedComponent=>{if("production"!==process.env.NODE_ENV&&!isValidElementType(WrappedComponent))throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);const wrappedComponentName=WrappedComponent.displayName||WrappedComponent.name||"Component",displayName=`Connect(${wrappedComponentName})`,selectorFactoryOptions={shouldHandleStateChanges:shouldHandleStateChanges,displayName:displayName,wrappedComponentName:wrappedComponentName,WrappedComponent:WrappedComponent,initMapStateToProps:initMapStateToProps,initMapDispatchToProps:initMapDispatchToProps,initMergeProps:initMergeProps,areStatesEqual:areStatesEqual,areStatePropsEqual:areStatePropsEqual,areOwnPropsEqual:areOwnPropsEqual,areMergedPropsEqual:areMergedPropsEqual};function ConnectFunction(props){const[propsContext,reactReduxForwardedRef,wrapperProps]=useMemo((()=>{const{reactReduxForwardedRef:reactReduxForwardedRef}=props,wrapperProps=_objectWithoutPropertiesLoose(props,_excluded);return[props.context,reactReduxForwardedRef,wrapperProps]}),[props]),ContextToUse=useMemo((()=>propsContext&&propsContext.Consumer&&isContextConsumer(React.createElement(propsContext.Consumer,null))?propsContext:Context),[propsContext,Context]),contextValue=useContext(ContextToUse),didStoreComeFromProps=Boolean(props.store)&&Boolean(props.store.getState)&&Boolean(props.store.dispatch),didStoreComeFromContext=Boolean(contextValue)&&Boolean(contextValue.store);if("production"!==process.env.NODE_ENV&&!didStoreComeFromProps&&!didStoreComeFromContext)throw new Error(`Could not find "store" in the context of "${displayName}". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`);const store=didStoreComeFromProps?props.store:contextValue.store,getServerState=didStoreComeFromContext?contextValue.getServerState:store.getState,childPropsSelector=useMemo((()=>defaultSelectorFactory(store.dispatch,selectorFactoryOptions)),[store]),[subscription,notifyNestedSubs]=useMemo((()=>{if(!shouldHandleStateChanges)return NO_SUBSCRIPTION_ARRAY;const subscription=createSubscription(store,didStoreComeFromProps?void 0:contextValue.subscription),notifyNestedSubs=subscription.notifyNestedSubs.bind(subscription);return[subscription,notifyNestedSubs]}),[store,didStoreComeFromProps,contextValue]),overriddenContextValue=useMemo((()=>didStoreComeFromProps?contextValue:_extends({},contextValue,{subscription:subscription})),[didStoreComeFromProps,contextValue,subscription]),lastChildProps=useRef(),lastWrapperProps=useRef(wrapperProps),childPropsFromStoreUpdate=useRef(),renderIsScheduled=useRef(!1),isMounted=(useRef(!1),useRef(!1)),latestSubscriptionCallbackError=useRef();useIsomorphicLayoutEffect((()=>(isMounted.current=!0,()=>{isMounted.current=!1})),[]);const actualChildPropsSelector=useMemo((()=>()=>childPropsFromStoreUpdate.current&&wrapperProps===lastWrapperProps.current?childPropsFromStoreUpdate.current:childPropsSelector(store.getState(),wrapperProps)),[store,wrapperProps]),subscribeForReact=useMemo((()=>reactListener=>subscription?subscribeUpdates(shouldHandleStateChanges,store,subscription,childPropsSelector,lastWrapperProps,lastChildProps,renderIsScheduled,isMounted,childPropsFromStoreUpdate,notifyNestedSubs,reactListener):()=>{}),[subscription]);let actualChildProps;useIsomorphicLayoutEffectWithArgs(captureWrapperProps,[lastWrapperProps,lastChildProps,renderIsScheduled,wrapperProps,childPropsFromStoreUpdate,notifyNestedSubs]);try{actualChildProps=useSyncExternalStore(subscribeForReact,actualChildPropsSelector,getServerState?()=>childPropsSelector(getServerState(),wrapperProps):actualChildPropsSelector)}catch(err){throw latestSubscriptionCallbackError.current&&(err.message+=`\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`),err}useIsomorphicLayoutEffect((()=>{latestSubscriptionCallbackError.current=void 0,childPropsFromStoreUpdate.current=void 0,lastChildProps.current=actualChildProps}));const renderedWrappedComponent=useMemo((()=>React.createElement(WrappedComponent,_extends({},actualChildProps,{ref:reactReduxForwardedRef}))),[reactReduxForwardedRef,WrappedComponent,actualChildProps]);return useMemo((()=>shouldHandleStateChanges?React.createElement(ContextToUse.Provider,{value:overriddenContextValue},renderedWrappedComponent):renderedWrappedComponent),[ContextToUse,renderedWrappedComponent,overriddenContextValue])}const Connect=React.memo(ConnectFunction);if(Connect.WrappedComponent=WrappedComponent,Connect.displayName=ConnectFunction.displayName=displayName,forwardRef){const forwarded=React.forwardRef((function(props,ref){return React.createElement(Connect,_extends({},props,{reactReduxForwardedRef:ref}))}));return forwarded.displayName=displayName,forwarded.WrappedComponent=WrappedComponent,hoistStatics(forwarded,WrappedComponent)}return hoistStatics(Connect,WrappedComponent)}}export default connect;