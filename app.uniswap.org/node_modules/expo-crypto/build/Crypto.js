import{toByteArray}from"base64-js";import{UnavailabilityError}from"expo-modules-core";import{CryptoDigestAlgorithm,CryptoEncoding}from"./Crypto.types";import ExpoCrypto from"./ExpoCrypto";export*from"./Crypto.types";class CryptoError extends TypeError{code="ERR_CRYPTO";constructor(message){super(`expo-crypto: ${message}`)}}export function getRandomBytes(byteCount){assertByteCount(byteCount,"getRandomBytes");const validByteCount=Math.floor(byteCount);if(__DEV__&&(!global.nativeCallSyncHook||global.__REMOTEDEV__)){const array=new Uint8Array(validByteCount);for(let i=0;i<validByteCount;i++)array[i]=Math.floor(256*Math.random());return array}if(ExpoCrypto.getRandomValues){const byteArray=new Uint8Array(validByteCount);return ExpoCrypto.getRandomValues(byteArray),byteArray}if(ExpoCrypto.getRandomBase64String){const base64=ExpoCrypto.getRandomBase64String(validByteCount);return toByteArray(base64)}throw new UnavailabilityError("expo-crypto","getRandomBytes")}export async function getRandomBytesAsync(byteCount){assertByteCount(byteCount,"getRandomBytesAsync");const validByteCount=Math.floor(byteCount);if(ExpoCrypto.getRandomValues){const byteArray=new Uint8Array(validByteCount);return ExpoCrypto.getRandomValues(byteArray),byteArray}if(ExpoCrypto.getRandomBase64StringAsync){const base64=await ExpoCrypto.getRandomBase64StringAsync(validByteCount);return toByteArray(base64)}throw new UnavailabilityError("expo-crypto","getRandomBytesAsync")}function assertByteCount(value,methodName){if("number"!=typeof value||isNaN(value)||Math.floor(value)<0||Math.floor(value)>1024)throw new TypeError(`expo-crypto: ${methodName}(${value}) expected a valid number from range 0...1024`)}function assertAlgorithm(algorithm){if(!Object.values(CryptoDigestAlgorithm).includes(algorithm))throw new CryptoError(`Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(CryptoDigestAlgorithm).join(", AlgCryptoDigestAlgorithmorithm.")}`)}function assertData(data){if("string"!=typeof data)throw new CryptoError("Invalid data provided. Expected a string.")}function assertEncoding(encoding){if(!Object.values(CryptoEncoding).includes(encoding))throw new CryptoError(`Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(CryptoEncoding).join(", CryptoEncoding.")}`)}export async function digestStringAsync(algorithm,data,options={encoding:CryptoEncoding.HEX}){if(!ExpoCrypto.digestStringAsync)throw new UnavailabilityError("expo-crypto","digestStringAsync");return assertAlgorithm(algorithm),assertData(data),assertEncoding(options.encoding),await ExpoCrypto.digestStringAsync(algorithm,data,options)}export function getRandomValues(typedArray){return ExpoCrypto.getRandomValues(typedArray),typedArray}export function randomUUID(){return ExpoCrypto.randomUUID()}const digestLengths={[CryptoDigestAlgorithm.SHA1]:20,[CryptoDigestAlgorithm.SHA256]:32,[CryptoDigestAlgorithm.SHA384]:48,[CryptoDigestAlgorithm.SHA512]:64,[CryptoDigestAlgorithm.MD2]:16,[CryptoDigestAlgorithm.MD4]:16,[CryptoDigestAlgorithm.MD5]:16};export function digest(algorithm,data){return new Promise(((resolve,reject)=>{try{if("function"==typeof ExpoCrypto.digestAsync)resolve(ExpoCrypto.digestAsync(algorithm,data));else{const output=new Uint8Array(digestLengths[algorithm]);ExpoCrypto.digest(algorithm,output,data),resolve(output.buffer)}}catch(error){reject(error)}}))}