const EthQuery=require("eth-query"),pify=require("pify"),BaseFilterWithHistory=require("./base-filter-history"),{bnToHex:bnToHex,hexToInt:hexToInt,incrementHexInt:incrementHexInt,minBlockRef:minBlockRef,blockRefIsNumber:blockRefIsNumber}=require("./hexUtils");class LogFilter extends BaseFilterWithHistory{constructor({provider:provider,params:params}){super(),this.type="log",this.ethQuery=new EthQuery(provider),this.params=Object.assign({fromBlock:"latest",toBlock:"latest",address:void 0,topics:[]},params),this.params.address&&(Array.isArray(this.params.address)||(this.params.address=[this.params.address]),this.params.address=this.params.address.map((address=>address.toLowerCase())))}async initialize({currentBlock:currentBlock}){let fromBlock=this.params.fromBlock;["latest","pending"].includes(fromBlock)&&(fromBlock=currentBlock),"earliest"===fromBlock&&(fromBlock="0x0"),this.params.fromBlock=fromBlock;const toBlock=minBlockRef(this.params.toBlock,currentBlock),params=Object.assign({},this.params,{toBlock:toBlock}),newLogs=await this._fetchLogs(params);this.addInitialResults(newLogs)}async update({oldBlock:oldBlock,newBlock:newBlock}){const toBlock=newBlock;let fromBlock;fromBlock=oldBlock?incrementHexInt(oldBlock):newBlock;const params=Object.assign({},this.params,{fromBlock:fromBlock,toBlock:toBlock}),matchingLogs=(await this._fetchLogs(params)).filter((log=>this.matchLog(log)));this.addResults(matchingLogs)}async _fetchLogs(params){return await pify((cb=>this.ethQuery.getLogs(params,cb)))()}matchLog(log){if(hexToInt(this.params.fromBlock)>=hexToInt(log.blockNumber))return!1;if(blockRefIsNumber(this.params.toBlock)&&hexToInt(this.params.toBlock)<=hexToInt(log.blockNumber))return!1;const normalizedLogAddress=log.address&&log.address.toLowerCase();if(this.params.address&&normalizedLogAddress&&!this.params.address.includes(normalizedLogAddress))return!1;return this.params.topics.every(((topicPattern,index)=>{let logTopic=log.topics[index];if(!logTopic)return!1;logTopic=logTopic.toLowerCase();let subtopicsToMatch=Array.isArray(topicPattern)?topicPattern:[topicPattern];if(subtopicsToMatch.includes(null))return!0;subtopicsToMatch=subtopicsToMatch.map((topic=>topic.toLowerCase()));return subtopicsToMatch.includes(logTopic)}))}}module.exports=LogFilter;