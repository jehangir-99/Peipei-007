"use strict";const processFn=(fn,options,proxy,unwrapped)=>function(...arguments_){return new(0,options.promiseModule)(((resolve,reject)=>{options.multiArgs?arguments_.push(((...result)=>{options.errorFirst?result[0]?reject(result):(result.shift(),resolve(result)):resolve(result)})):options.errorFirst?arguments_.push(((error,result)=>{error?reject(error):resolve(result)})):arguments_.push(resolve);const self=this===proxy?unwrapped:this;Reflect.apply(fn,self,arguments_)}))},filterCache=new WeakMap;module.exports=(input,options)=>{options={exclude:[/.+(?:Sync|Stream)$/],errorFirst:!0,promiseModule:Promise,...options};const objectType=typeof input;if(null===input||"object"!==objectType&&"function"!==objectType)throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${null===input?"null":objectType}\``);const cache=new WeakMap,proxy=new Proxy(input,{apply(target,thisArg,args){const cached=cache.get(target);if(cached)return Reflect.apply(cached,thisArg,args);const pified=options.excludeMain?target:processFn(target,options,proxy,target);return cache.set(target,pified),Reflect.apply(pified,thisArg,args)},get(target,key){const property=target[key];if(!((target,key)=>{let cached=filterCache.get(target);if(cached||(cached={},filterCache.set(target,cached)),key in cached)return cached[key];const match=pattern=>"string"==typeof pattern||"symbol"==typeof key?key===pattern:pattern.test(key),desc=Reflect.getOwnPropertyDescriptor(target,key),writableOrConfigurableOwn=void 0===desc||desc.writable||desc.configurable,shouldFilter=(options.include?options.include.some(match):!options.exclude.some(match))&&writableOrConfigurableOwn;return cached[key]=shouldFilter,shouldFilter})(target,key)||property===Function.prototype[key])return property;const cached=cache.get(property);if(cached)return cached;if("function"==typeof property){const pified=processFn(property,options,proxy,target);return cache.set(property,pified),pified}return property}});return proxy};