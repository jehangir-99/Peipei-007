import{CommonActions}from"@react-navigation/routers";import*as React from"react";import checkDuplicateRouteNames from"./checkDuplicateRouteNames";import checkSerializable from"./checkSerializable";import{NOT_INITIALIZED_ERROR}from"./createNavigationContainerRef";import EnsureSingleNavigator from"./EnsureSingleNavigator";import findFocusedRoute from"./findFocusedRoute";import NavigationBuilderContext from"./NavigationBuilderContext";import NavigationContainerRefContext from"./NavigationContainerRefContext";import NavigationContext from"./NavigationContext";import NavigationRouteContext from"./NavigationRouteContext";import NavigationStateContext from"./NavigationStateContext";import UnhandledActionContext from"./UnhandledActionContext";import useChildListeners from"./useChildListeners";import useEventEmitter from"./useEventEmitter";import useKeyedChildListeners from"./useKeyedChildListeners";import useOptionsGetters from"./useOptionsGetters";import{ScheduleUpdateContext}from"./useScheduleUpdate";import useSyncState from"./useSyncState";const serializableWarnings=[],duplicateNameWarnings=[],getPartialState=state=>{if(void 0===state)return;const{key:key,routeNames:routeNames,...partialState}=state;return{...partialState,stale:!0,routes:state.routes.map((route=>void 0===route.state?route:{...route,state:getPartialState(route.state)}))}},BaseNavigationContainer=React.forwardRef((function(_ref,ref){let{initialState:initialState,onStateChange:onStateChange,onUnhandledAction:onUnhandledAction,independent:independent,children:children}=_ref;if(!React.useContext(NavigationStateContext).isDefault&&!independent)throw new Error("Looks like you have nested a 'NavigationContainer' inside another. Normally you need only one container at the root of the app, so this was probably an error. If this was intentional, pass 'independent={true}' explicitly. Note that this will make the child navigators disconnected from the parent and you won't be able to navigate between them.");const[state,getState,setState,scheduleUpdate,flushUpdates]=useSyncState((()=>getPartialState(null==initialState?void 0:initialState))),isFirstMountRef=React.useRef(!0),navigatorKeyRef=React.useRef(),getKey=React.useCallback((()=>navigatorKeyRef.current),[]),setKey=React.useCallback((key=>{navigatorKeyRef.current=key}),[]),{listeners:listeners,addListener:addListener}=useChildListeners(),{keyedListeners:keyedListeners,addKeyedListener:addKeyedListener}=useKeyedChildListeners(),dispatch=React.useCallback((action=>{null==listeners.focus[0]?console.error(NOT_INITIALIZED_ERROR):listeners.focus[0]((navigation=>navigation.dispatch(action)))}),[listeners.focus]),canGoBack=React.useCallback((()=>{if(null==listeners.focus[0])return!1;const{result:result,handled:handled}=listeners.focus[0]((navigation=>navigation.canGoBack()));return!!handled&&result}),[listeners.focus]),resetRoot=React.useCallback((state=>{var _state$key,_keyedListeners$getSt,_keyedListeners$getSt2;const target=null!==(_state$key=null==state?void 0:state.key)&&void 0!==_state$key?_state$key:null===(_keyedListeners$getSt=(_keyedListeners$getSt2=keyedListeners.getState).root)||void 0===_keyedListeners$getSt?void 0:_keyedListeners$getSt.call(_keyedListeners$getSt2).key;null==target?console.error(NOT_INITIALIZED_ERROR):listeners.focus[0]((navigation=>navigation.dispatch({...CommonActions.reset(state),target:target})))}),[keyedListeners.getState,listeners.focus]),getRootState=React.useCallback((()=>{var _keyedListeners$getSt3,_keyedListeners$getSt4;return null===(_keyedListeners$getSt3=(_keyedListeners$getSt4=keyedListeners.getState).root)||void 0===_keyedListeners$getSt3?void 0:_keyedListeners$getSt3.call(_keyedListeners$getSt4)}),[keyedListeners.getState]),getCurrentRoute=React.useCallback((()=>{const state=getRootState();if(null==state)return;return findFocusedRoute(state)}),[getRootState]),emitter=useEventEmitter(),{addOptionsGetter:addOptionsGetter,getCurrentOptions:getCurrentOptions}=useOptionsGetters({}),navigation=React.useMemo((()=>({...Object.keys(CommonActions).reduce(((acc,name)=>(acc[name]=function(){return dispatch(CommonActions[name](...arguments))},acc)),{}),...emitter.create("root"),dispatch:dispatch,resetRoot:resetRoot,isFocused:()=>!0,canGoBack:canGoBack,getParent:()=>{},getState:()=>stateRef.current,getRootState:getRootState,getCurrentRoute:getCurrentRoute,getCurrentOptions:getCurrentOptions,isReady:()=>null!=listeners.focus[0]})),[canGoBack,dispatch,emitter,getCurrentOptions,getCurrentRoute,getRootState,listeners.focus,resetRoot]);React.useImperativeHandle(ref,(()=>navigation),[navigation]);const onDispatchAction=React.useCallback(((action,noop)=>{emitter.emit({type:"__unsafe_action__",data:{action:action,noop:noop,stack:stackRef.current}})}),[emitter]),lastEmittedOptionsRef=React.useRef(),onOptionsChange=React.useCallback((options=>{lastEmittedOptionsRef.current!==options&&(lastEmittedOptionsRef.current=options,emitter.emit({type:"options",data:{options:options}}))}),[emitter]),stackRef=React.useRef(),builderContext=React.useMemo((()=>({addListener:addListener,addKeyedListener:addKeyedListener,onDispatchAction:onDispatchAction,onOptionsChange:onOptionsChange,stackRef:stackRef})),[addListener,addKeyedListener,onDispatchAction,onOptionsChange]),scheduleContext=React.useMemo((()=>({scheduleUpdate:scheduleUpdate,flushUpdates:flushUpdates})),[scheduleUpdate,flushUpdates]),isInitialRef=React.useRef(!0),getIsInitial=React.useCallback((()=>isInitialRef.current),[]),context=React.useMemo((()=>({state:state,getState:getState,setState:setState,getKey:getKey,setKey:setKey,getIsInitial:getIsInitial,addOptionsGetter:addOptionsGetter})),[state,getState,setState,getKey,setKey,getIsInitial,addOptionsGetter]),onStateChangeRef=React.useRef(onStateChange),stateRef=React.useRef(state);React.useEffect((()=>{isInitialRef.current=!1,onStateChangeRef.current=onStateChange,stateRef.current=state})),React.useEffect((()=>{const hydratedState=getRootState();if("production"!==process.env.NODE_ENV&&void 0!==hydratedState){const serializableResult=checkSerializable(hydratedState);if(!serializableResult.serializable){const{location:location,reason:reason}=serializableResult;let path="",pointer=hydratedState,params=!1;for(let i=0;i<location.length;i++){const curr=location[i],prev=location[i-1];if(pointer=pointer[curr],params||"state"!==curr)if(params||"routes"!==curr)if(params||"number"!=typeof curr||"routes"!==prev)params?"number"==typeof curr||/^[0-9]+$/.test(curr)?path+=`[${curr}]`:/^[a-z$_]+$/i.test(curr)?path+=`.${curr}`:path+=`[${JSON.stringify(curr)}]`:(path+=` > ${curr}`,params=!0);else{var _pointer;path+=null===(_pointer=pointer)||void 0===_pointer?void 0:_pointer.name}else path&&(path+=" > ")}const message=`Non-serializable values were found in the navigation state. Check:\n\n${path} (${reason})\n\nThis can break usage such as persisting and restoring state. This might happen if you passed non-serializable values such as function, class instances etc. in params. If you need to use components with callbacks in your options, you can use 'navigation.setOptions' instead. See https://reactnavigation.org/docs/troubleshooting#i-get-the-warning-non-serializable-values-were-found-in-the-navigation-state for more details.`;serializableWarnings.includes(message)||(serializableWarnings.push(message),console.warn(message))}const duplicateRouteNamesResult=checkDuplicateRouteNames(hydratedState);if(duplicateRouteNamesResult.length){const message=`Found screens with the same name nested inside one another. Check:\n${duplicateRouteNamesResult.map((locations=>`\n${locations.join(", ")}`))}\n\nThis can cause confusing behavior during navigation. Consider using unique names for each screen instead.`;duplicateNameWarnings.includes(message)||(duplicateNameWarnings.push(message),console.warn(message))}}emitter.emit({type:"state",data:{state:state}}),!isFirstMountRef.current&&onStateChangeRef.current&&onStateChangeRef.current(hydratedState),isFirstMountRef.current=!1}),[getRootState,emitter,state]);const defaultOnUnhandledAction=React.useCallback((action=>{if("production"===process.env.NODE_ENV)return;const payload=action.payload;let message=`The action '${action.type}'${payload?` with payload ${JSON.stringify(action.payload)}`:""} was not handled by any navigator.`;switch(action.type){case"NAVIGATE":case"PUSH":case"REPLACE":case"JUMP_TO":null!=payload&&payload.name?message+=`\n\nDo you have a screen named '${payload.name}'?\n\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.`:message+="\n\nYou need to pass the name of the screen to navigate to.\n\nSee https://reactnavigation.org/docs/navigation-actions for usage.";break;case"GO_BACK":case"POP":case"POP_TO_TOP":message+="\n\nIs there any screen to go back to?";break;case"OPEN_DRAWER":case"CLOSE_DRAWER":case"TOGGLE_DRAWER":message+="\n\nIs your screen inside a Drawer navigator?"}message+="\n\nThis is a development-only warning and won't be shown in production.",console.error(message)}),[]);let element=React.createElement(NavigationContainerRefContext.Provider,{value:navigation},React.createElement(ScheduleUpdateContext.Provider,{value:scheduleContext},React.createElement(NavigationBuilderContext.Provider,{value:builderContext},React.createElement(NavigationStateContext.Provider,{value:context},React.createElement(UnhandledActionContext.Provider,{value:null!=onUnhandledAction?onUnhandledAction:defaultOnUnhandledAction},React.createElement(EnsureSingleNavigator,null,children))))));return independent&&(element=React.createElement(NavigationRouteContext.Provider,{value:void 0},React.createElement(NavigationContext.Provider,{value:void 0},element))),element}));export default BaseNavigationContainer;