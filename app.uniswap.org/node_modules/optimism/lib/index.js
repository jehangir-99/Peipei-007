import{Trie}from"@wry/trie";import{StrongCache}from"@wry/caches";import{Entry}from"./entry.js";import{parentEntrySlot}from"./context.js";export{bindContext,noContext,nonReactive,setTimeout,asyncFromGen,Slot}from"./context.js";export{dep}from"./dep.js";let defaultKeyTrie;export function defaultMakeCacheKey(...args){return(defaultKeyTrie||(defaultKeyTrie=new Trie("function"==typeof WeakMap))).lookupArray(args)}export{Trie as KeyTrie};const caches=new Set;export function wrap(originalFunction,{max:max=Math.pow(2,16),keyArgs:keyArgs,makeCacheKey:makeCacheKey=defaultMakeCacheKey,normalizeResult:normalizeResult,subscribe:subscribe,cache:cacheOption=StrongCache}=Object.create(null)){const cache="function"==typeof cacheOption?new cacheOption(max,(entry=>entry.dispose())):cacheOption,optimistic=function(){const key=makeCacheKey.apply(null,keyArgs?keyArgs.apply(null,arguments):arguments);if(void 0===key)return originalFunction.apply(null,arguments);let entry=cache.get(key);entry||(cache.set(key,entry=new Entry(originalFunction)),entry.normalizeResult=normalizeResult,entry.subscribe=subscribe,entry.forget=()=>cache.delete(key));const value=entry.recompute(Array.prototype.slice.call(arguments));return cache.set(key,entry),caches.add(cache),parentEntrySlot.hasValue()||(caches.forEach((cache=>cache.clean())),caches.clear()),value};function dirtyKey(key){const entry=key&&cache.get(key);entry&&entry.setDirty()}function peekKey(key){const entry=key&&cache.get(key);if(entry)return entry.peek()}function forgetKey(key){return!!key&&cache.delete(key)}return Object.defineProperty(optimistic,"size",{get:()=>cache.size,configurable:!1,enumerable:!1}),Object.freeze(optimistic.options={max:max,keyArgs:keyArgs,makeCacheKey:makeCacheKey,normalizeResult:normalizeResult,subscribe:subscribe,cache:cache}),optimistic.dirtyKey=dirtyKey,optimistic.dirty=function(){dirtyKey(makeCacheKey.apply(null,arguments))},optimistic.peekKey=peekKey,optimistic.peek=function(){return peekKey(makeCacheKey.apply(null,arguments))},optimistic.forgetKey=forgetKey,optimistic.forget=function(){return forgetKey(makeCacheKey.apply(null,arguments))},optimistic.makeCacheKey=makeCacheKey,optimistic.getKey=keyArgs?function(){return makeCacheKey.apply(null,keyArgs.apply(null,arguments))}:makeCacheKey,Object.freeze(optimistic)}