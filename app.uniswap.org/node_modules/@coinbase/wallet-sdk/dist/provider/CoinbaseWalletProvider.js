"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.CoinbaseWalletProvider=void 0;const bn_js_1=__importDefault(require("bn.js")),eventemitter3_1=require("eventemitter3"),error_1=require("../core/error"),util_1=require("../core/util"),MobileRelay_1=require("../relay/mobile/MobileRelay"),RelayAbstract_1=require("../relay/RelayAbstract"),Session_1=require("../relay/Session"),Web3Response_1=require("../relay/walletlink/type/Web3Response"),eth_eip712_util_1=__importDefault(require("../vendor-js/eth-eip712-util")),DiagnosticLogger_1=require("./DiagnosticLogger"),FilterPolyfill_1=require("./FilterPolyfill"),SubscriptionManager_1=require("./SubscriptionManager"),DEFAULT_CHAIN_ID_KEY="DefaultChainId",DEFAULT_JSON_RPC_URL="DefaultJsonRpcUrl";class CoinbaseWalletProvider extends eventemitter3_1.EventEmitter{constructor(options){var _a,_b;super(),this._filterPolyfill=new FilterPolyfill_1.FilterPolyfill(this),this._subscriptionManager=new SubscriptionManager_1.SubscriptionManager(this),this._relay=null,this._addresses=[],this.hasMadeFirstChainChangedEmission=!1,this.setProviderInfo=this.setProviderInfo.bind(this),this.updateProviderInfo=this.updateProviderInfo.bind(this),this.getChainId=this.getChainId.bind(this),this.setAppInfo=this.setAppInfo.bind(this),this.enable=this.enable.bind(this),this.close=this.close.bind(this),this.send=this.send.bind(this),this.sendAsync=this.sendAsync.bind(this),this.request=this.request.bind(this),this._setAddresses=this._setAddresses.bind(this),this.scanQRCode=this.scanQRCode.bind(this),this.genericRequest=this.genericRequest.bind(this),this._chainIdFromOpts=options.chainId,this._jsonRpcUrlFromOpts=options.jsonRpcUrl,this._overrideIsMetaMask=options.overrideIsMetaMask,this._relayProvider=options.relayProvider,this._storage=options.storage,this._relayEventManager=options.relayEventManager,this.diagnostic=options.diagnosticLogger,this.reloadOnDisconnect=!0,this.isCoinbaseWallet=null===(_a=options.overrideIsCoinbaseWallet)||void 0===_a||_a,this.isCoinbaseBrowser=null!==(_b=options.overrideIsCoinbaseBrowser)&&void 0!==_b&&_b,this.qrUrl=options.qrUrl;const chainId=this.getChainId(),chainIdStr=(0,util_1.prepend0x)(chainId.toString(16));this.emit("connect",{chainIdStr:chainIdStr});const cachedAddresses=this._storage.getItem(RelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);if(cachedAddresses){const addresses=cachedAddresses.split(" ");""!==addresses[0]&&(this._addresses=addresses.map((address=>(0,util_1.ensureAddressString)(address))),this.emit("accountsChanged",addresses))}this._subscriptionManager.events.on("notification",(notification=>{this.emit("message",{type:notification.method,data:notification.params})})),this._isAuthorized()&&this.initializeRelay(),window.addEventListener("message",(event=>{var _a;if(event.origin===location.origin&&event.source===window&&"walletLinkMessage"===event.data.type&&"dappChainSwitched"===event.data.data.action){const _chainId=event.data.data.chainId,jsonRpcUrl=null!==(_a=event.data.data.jsonRpcUrl)&&void 0!==_a?_a:this.jsonRpcUrl;this.updateProviderInfo(jsonRpcUrl,Number(_chainId))}}))}get selectedAddress(){return this._addresses[0]||void 0}get networkVersion(){return this.getChainId().toString(10)}get chainId(){return(0,util_1.prepend0x)(this.getChainId().toString(16))}get isWalletLink(){return!0}get isMetaMask(){return this._overrideIsMetaMask}get host(){return this.jsonRpcUrl}get connected(){return!0}isConnected(){return!0}get jsonRpcUrl(){var _a;return null!==(_a=this._storage.getItem("DefaultJsonRpcUrl"))&&void 0!==_a?_a:this._jsonRpcUrlFromOpts}set jsonRpcUrl(value){this._storage.setItem("DefaultJsonRpcUrl",value)}disableReloadOnDisconnect(){this.reloadOnDisconnect=!1}setProviderInfo(jsonRpcUrl,chainId){this.isCoinbaseBrowser||(this._chainIdFromOpts=chainId,this._jsonRpcUrlFromOpts=jsonRpcUrl),this.updateProviderInfo(this.jsonRpcUrl,this.getChainId())}updateProviderInfo(jsonRpcUrl,chainId){this.jsonRpcUrl=jsonRpcUrl;const originalChainId=this.getChainId();this._storage.setItem("DefaultChainId",chainId.toString(10));!((0,util_1.ensureIntNumber)(chainId)!==originalChainId)&&this.hasMadeFirstChainChangedEmission||(this.emit("chainChanged",this.getChainId()),this.hasMadeFirstChainChangedEmission=!0)}async watchAsset(type,address,symbol,decimals,image,chainId){const relay=await this.initializeRelay(),result=await relay.watchAsset(type,address,symbol,decimals,image,null==chainId?void 0:chainId.toString()).promise;return!(0,Web3Response_1.isErrorResponse)(result)&&!!result.result}async addEthereumChain(chainId,rpcUrls,blockExplorerUrls,chainName,iconUrls,nativeCurrency){var _a,_b;if((0,util_1.ensureIntNumber)(chainId)===this.getChainId())return!1;const relay=await this.initializeRelay(),isWhitelistedNetworkOrStandalone=relay.inlineAddEthereumChain(chainId.toString());this._isAuthorized()||isWhitelistedNetworkOrStandalone||await relay.requestEthereumAccounts().promise;const res=await relay.addEthereumChain(chainId.toString(),rpcUrls,iconUrls,blockExplorerUrls,chainName,nativeCurrency).promise;return!(0,Web3Response_1.isErrorResponse)(res)&&(!0===(null===(_a=res.result)||void 0===_a?void 0:_a.isApproved)&&this.updateProviderInfo(rpcUrls[0],chainId),!0===(null===(_b=res.result)||void 0===_b?void 0:_b.isApproved))}async switchEthereumChain(chainId){const relay=await this.initializeRelay(),res=await relay.switchEthereumChain(chainId.toString(10),this.selectedAddress||void 0).promise;if((0,Web3Response_1.isErrorResponse)(res)){if(!res.errorCode)return;throw res.errorCode===error_1.standardErrorCodes.provider.unsupportedChain?error_1.standardErrors.provider.unsupportedChain():error_1.standardErrors.provider.custom({message:res.errorMessage,code:res.errorCode})}const switchResponse=res.result;switchResponse.isApproved&&switchResponse.rpcUrl.length>0&&this.updateProviderInfo(switchResponse.rpcUrl,chainId)}setAppInfo(appName,appLogoUrl){this.initializeRelay().then((relay=>relay.setAppInfo(appName,appLogoUrl)))}async enable(){var _a;return null===(_a=this.diagnostic)||void 0===_a||_a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE,{method:"provider::enable",addresses_length:this._addresses.length,sessionIdHash:this._relay?Session_1.Session.hash(this._relay.session.id):void 0}),this._isAuthorized()?[...this._addresses]:await this.send("eth_requestAccounts")}async close(){(await this.initializeRelay()).resetAndReload()}send(requestOrMethod,callbackOrParams){try{const result=this._send(requestOrMethod,callbackOrParams);if(result instanceof Promise)return result.catch((error=>{throw(0,error_1.serializeError)(error,requestOrMethod)}))}catch(error){throw(0,error_1.serializeError)(error,requestOrMethod)}}_send(requestOrMethod,callbackOrParams){if("string"==typeof requestOrMethod){const request={jsonrpc:"2.0",id:0,method:requestOrMethod,params:Array.isArray(callbackOrParams)?callbackOrParams:void 0!==callbackOrParams?[callbackOrParams]:[]};return this._sendRequestAsync(request).then((res=>res.result))}if("function"==typeof callbackOrParams){const request=requestOrMethod,callback=callbackOrParams;return this._sendAsync(request,callback)}if(Array.isArray(requestOrMethod)){return requestOrMethod.map((r=>this._sendRequest(r)))}const req=requestOrMethod;return this._sendRequest(req)}async sendAsync(request,callback){try{return this._sendAsync(request,callback).catch((error=>{throw(0,error_1.serializeError)(error,request)}))}catch(error){return Promise.reject((0,error_1.serializeError)(error,request))}}async _sendAsync(request,callback){if("function"!=typeof callback)throw new Error("callback is required");if(Array.isArray(request)){const arrayCb=callback;return void this._sendMultipleRequestsAsync(request).then((responses=>arrayCb(null,responses))).catch((err=>arrayCb(err,null)))}const cb=callback;return this._sendRequestAsync(request).then((response=>cb(null,response))).catch((err=>cb(err,null)))}async request(args){try{return this._request(args).catch((error=>{throw(0,error_1.serializeError)(error,args.method)}))}catch(error){return Promise.reject((0,error_1.serializeError)(error,args.method))}}async _request(args){if(!args||"object"!=typeof args||Array.isArray(args))throw error_1.standardErrors.rpc.invalidRequest({message:"Expected a single, non-array, object argument.",data:args});const{method:method,params:params}=args;if("string"!=typeof method||0===method.length)throw error_1.standardErrors.rpc.invalidRequest({message:"'args.method' must be a non-empty string.",data:args});if(void 0!==params&&!Array.isArray(params)&&("object"!=typeof params||null===params))throw error_1.standardErrors.rpc.invalidRequest({message:"'args.params' must be an object or array if provided.",data:args});const newParams=void 0===params?[]:params,id=this._relayEventManager.makeRequestId();return(await this._sendRequestAsync({method:method,params:newParams,jsonrpc:"2.0",id:id})).result}async scanQRCode(match){const relay=await this.initializeRelay(),res=await relay.scanQRCode((0,util_1.ensureRegExpString)(match)).promise;if((0,Web3Response_1.isErrorResponse)(res))throw(0,error_1.serializeError)(res.errorMessage,"scanQRCode");if("string"!=typeof res.result)throw(0,error_1.serializeError)("result was not a string","scanQRCode");return res.result}async genericRequest(data,action){const relay=await this.initializeRelay(),res=await relay.genericRequest(data,action).promise;if((0,Web3Response_1.isErrorResponse)(res))throw(0,error_1.serializeError)(res.errorMessage,"generic");if("string"!=typeof res.result)throw(0,error_1.serializeError)("result was not a string","generic");return res.result}async connectAndSignIn(params){var _a;let res;null===(_a=this.diagnostic)||void 0===_a||_a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE,{method:"provider::connectAndSignIn",sessionIdHash:this._relay?Session_1.Session.hash(this._relay.session.id):void 0});try{const relay=await this.initializeRelay();if(!(relay instanceof MobileRelay_1.MobileRelay))throw new Error("connectAndSignIn is only supported on mobile");if(res=await relay.connectAndSignIn(params).promise,(0,Web3Response_1.isErrorResponse)(res))throw new Error(res.errorMessage)}catch(err){if("string"==typeof err.message&&err.message.match(/(denied|rejected)/i))throw error_1.standardErrors.provider.userRejectedRequest("User denied account authorization");throw err}if(!res.result)throw new Error("accounts received is empty");const{accounts:accounts}=res.result;return this._setAddresses(accounts),this.isCoinbaseBrowser||await this.switchEthereumChain(this.getChainId()),res.result}async selectProvider(providerOptions){const relay=await this.initializeRelay(),res=await relay.selectProvider(providerOptions).promise;if((0,Web3Response_1.isErrorResponse)(res))throw(0,error_1.serializeError)(res.errorMessage,"selectProvider");if("string"!=typeof res.result)throw(0,error_1.serializeError)("result was not a string","selectProvider");return res.result}supportsSubscriptions(){return!1}subscribe(){throw new Error("Subscriptions are not supported")}unsubscribe(){throw new Error("Subscriptions are not supported")}disconnect(){return!0}_sendRequest(request){const response={jsonrpc:"2.0",id:request.id},{method:method}=request;if(response.result=this._handleSynchronousMethods(request),void 0===response.result)throw new Error(`Coinbase Wallet does not support calling ${method} synchronously without a callback. Please provide a callback parameter to call ${method} asynchronously.`);return response}_setAddresses(addresses,_){if(!Array.isArray(addresses))throw new Error("addresses is not an array");const newAddresses=addresses.map((address=>(0,util_1.ensureAddressString)(address)));JSON.stringify(newAddresses)!==JSON.stringify(this._addresses)&&(this._addresses=newAddresses,this.emit("accountsChanged",this._addresses),this._storage.setItem(RelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY,newAddresses.join(" ")))}_sendRequestAsync(request){return new Promise(((resolve,reject)=>{try{const syncResult=this._handleSynchronousMethods(request);if(void 0!==syncResult)return resolve({jsonrpc:"2.0",id:request.id,result:syncResult});const filterPromise=this._handleAsynchronousFilterMethods(request);if(void 0!==filterPromise)return void filterPromise.then((res=>resolve(Object.assign(Object.assign({},res),{id:request.id})))).catch((err=>reject(err)));const subscriptionPromise=this._handleSubscriptionMethods(request);if(void 0!==subscriptionPromise)return void subscriptionPromise.then((res=>resolve({jsonrpc:"2.0",id:request.id,result:res.result}))).catch((err=>reject(err)))}catch(err){return reject(err)}this._handleAsynchronousMethods(request).then((res=>res&&resolve(Object.assign(Object.assign({},res),{id:request.id})))).catch((err=>reject(err)))}))}_sendMultipleRequestsAsync(requests){return Promise.all(requests.map((r=>this._sendRequestAsync(r))))}_handleSynchronousMethods(request){const{method:method}=request,params=request.params||[];switch(method){case"eth_accounts":return this._eth_accounts();case"eth_coinbase":return this._eth_coinbase();case"eth_uninstallFilter":return this._eth_uninstallFilter(params);case"net_version":return this._net_version();case"eth_chainId":return this._eth_chainId();default:return}}async _handleAsynchronousMethods(request){const{method:method}=request,params=request.params||[];switch(method){case"eth_requestAccounts":return this._eth_requestAccounts();case"eth_sign":return this._eth_sign(params);case"eth_ecRecover":return this._eth_ecRecover(params);case"personal_sign":return this._personal_sign(params);case"personal_ecRecover":return this._personal_ecRecover(params);case"eth_signTransaction":return this._eth_signTransaction(params);case"eth_sendRawTransaction":return this._eth_sendRawTransaction(params);case"eth_sendTransaction":return this._eth_sendTransaction(params);case"eth_signTypedData_v1":return this._eth_signTypedData_v1(params);case"eth_signTypedData_v2":return this._throwUnsupportedMethodError();case"eth_signTypedData_v3":return this._eth_signTypedData_v3(params);case"eth_signTypedData_v4":case"eth_signTypedData":return this._eth_signTypedData_v4(params);case"cbWallet_arbitrary":return this._cbwallet_arbitrary(params);case"wallet_addEthereumChain":return this._wallet_addEthereumChain(params);case"wallet_switchEthereumChain":return this._wallet_switchEthereumChain(params);case"wallet_watchAsset":return this._wallet_watchAsset(params)}return(await this.initializeRelay()).makeEthereumJSONRPCRequest(request,this.jsonRpcUrl).catch((err=>{var _a;throw err.code!==error_1.standardErrorCodes.rpc.methodNotFound&&err.code!==error_1.standardErrorCodes.rpc.methodNotSupported||null===(_a=this.diagnostic)||void 0===_a||_a.log(DiagnosticLogger_1.EVENTS.METHOD_NOT_IMPLEMENTED,{method:request.method,sessionIdHash:this._relay?Session_1.Session.hash(this._relay.session.id):void 0}),err}))}_handleAsynchronousFilterMethods(request){const{method:method}=request,params=request.params||[];switch(method){case"eth_newFilter":return this._eth_newFilter(params);case"eth_newBlockFilter":return this._eth_newBlockFilter();case"eth_newPendingTransactionFilter":return this._eth_newPendingTransactionFilter();case"eth_getFilterChanges":return this._eth_getFilterChanges(params);case"eth_getFilterLogs":return this._eth_getFilterLogs(params)}}_handleSubscriptionMethods(request){switch(request.method){case"eth_subscribe":case"eth_unsubscribe":return this._subscriptionManager.handleRequest(request)}}_isKnownAddress(addressString){try{const addressStr=(0,util_1.ensureAddressString)(addressString);return this._addresses.map((address=>(0,util_1.ensureAddressString)(address))).includes(addressStr)}catch(_a){}return!1}_ensureKnownAddress(addressString){var _a;if(!this._isKnownAddress(addressString))throw null===(_a=this.diagnostic)||void 0===_a||_a.log(DiagnosticLogger_1.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED),new Error("Unknown Ethereum address")}_prepareTransactionParams(tx){const fromAddress=tx.from?(0,util_1.ensureAddressString)(tx.from):this.selectedAddress;if(!fromAddress)throw new Error("Ethereum address is unavailable");this._ensureKnownAddress(fromAddress);return{fromAddress:fromAddress,toAddress:tx.to?(0,util_1.ensureAddressString)(tx.to):null,weiValue:null!=tx.value?(0,util_1.ensureBN)(tx.value):new bn_js_1.default(0),data:tx.data?(0,util_1.ensureBuffer)(tx.data):Buffer.alloc(0),nonce:null!=tx.nonce?(0,util_1.ensureIntNumber)(tx.nonce):null,gasPriceInWei:null!=tx.gasPrice?(0,util_1.ensureBN)(tx.gasPrice):null,maxFeePerGas:null!=tx.maxFeePerGas?(0,util_1.ensureBN)(tx.maxFeePerGas):null,maxPriorityFeePerGas:null!=tx.maxPriorityFeePerGas?(0,util_1.ensureBN)(tx.maxPriorityFeePerGas):null,gasLimit:null!=tx.gas?(0,util_1.ensureBN)(tx.gas):null,chainId:tx.chainId?(0,util_1.ensureIntNumber)(tx.chainId):this.getChainId()}}_isAuthorized(){return this._addresses.length>0}_requireAuthorization(){if(!this._isAuthorized())throw error_1.standardErrors.provider.unauthorized({})}_throwUnsupportedMethodError(){throw error_1.standardErrors.provider.unsupportedMethod({})}async _signEthereumMessage(message,address,addPrefix,typedDataJson){this._ensureKnownAddress(address);try{const relay=await this.initializeRelay(),res=await relay.signEthereumMessage(message,address,addPrefix,typedDataJson).promise;if((0,Web3Response_1.isErrorResponse)(res))throw new Error(res.errorMessage);return{jsonrpc:"2.0",id:0,result:res.result}}catch(err){if("string"==typeof err.message&&err.message.match(/(denied|rejected)/i))throw error_1.standardErrors.provider.userRejectedRequest("User denied message signature");throw err}}async _ethereumAddressFromSignedMessage(message,signature,addPrefix){const relay=await this.initializeRelay(),res=await relay.ethereumAddressFromSignedMessage(message,signature,addPrefix).promise;if((0,Web3Response_1.isErrorResponse)(res))throw new Error(res.errorMessage);return{jsonrpc:"2.0",id:0,result:res.result}}_eth_accounts(){return[...this._addresses]}_eth_coinbase(){return this.selectedAddress||null}_net_version(){return this.getChainId().toString(10)}_eth_chainId(){return(0,util_1.hexStringFromIntNumber)(this.getChainId())}getChainId(){const chainIdStr=this._storage.getItem("DefaultChainId");if(!chainIdStr)return(0,util_1.ensureIntNumber)(this._chainIdFromOpts);const chainId=parseInt(chainIdStr,10);return(0,util_1.ensureIntNumber)(chainId)}async _eth_requestAccounts(){var _a;if(null===(_a=this.diagnostic)||void 0===_a||_a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE,{method:"provider::_eth_requestAccounts",addresses_length:this._addresses.length,sessionIdHash:this._relay?Session_1.Session.hash(this._relay.session.id):void 0}),this._isAuthorized())return Promise.resolve({jsonrpc:"2.0",id:0,result:this._addresses});let res;try{const relay=await this.initializeRelay();if(res=await relay.requestEthereumAccounts().promise,(0,Web3Response_1.isErrorResponse)(res))throw new Error(res.errorMessage)}catch(err){if("string"==typeof err.message&&err.message.match(/(denied|rejected)/i))throw error_1.standardErrors.provider.userRejectedRequest("User denied account authorization");throw err}if(!res.result)throw new Error("accounts received is empty");return this._setAddresses(res.result),this.isCoinbaseBrowser||await this.switchEthereumChain(this.getChainId()),{jsonrpc:"2.0",id:0,result:this._addresses}}_eth_sign(params){this._requireAuthorization();const address=(0,util_1.ensureAddressString)(params[0]),message=(0,util_1.ensureBuffer)(params[1]);return this._signEthereumMessage(message,address,!1)}_eth_ecRecover(params){const message=(0,util_1.ensureBuffer)(params[0]),signature=(0,util_1.ensureBuffer)(params[1]);return this._ethereumAddressFromSignedMessage(message,signature,!1)}_personal_sign(params){this._requireAuthorization();const message=(0,util_1.ensureBuffer)(params[0]),address=(0,util_1.ensureAddressString)(params[1]);return this._signEthereumMessage(message,address,!0)}_personal_ecRecover(params){const message=(0,util_1.ensureBuffer)(params[0]),signature=(0,util_1.ensureBuffer)(params[1]);return this._ethereumAddressFromSignedMessage(message,signature,!0)}async _eth_signTransaction(params){this._requireAuthorization();const tx=this._prepareTransactionParams(params[0]||{});try{const relay=await this.initializeRelay(),res=await relay.signEthereumTransaction(tx).promise;if((0,Web3Response_1.isErrorResponse)(res))throw new Error(res.errorMessage);return{jsonrpc:"2.0",id:0,result:res.result}}catch(err){if("string"==typeof err.message&&err.message.match(/(denied|rejected)/i))throw error_1.standardErrors.provider.userRejectedRequest("User denied transaction signature");throw err}}async _eth_sendRawTransaction(params){const signedTransaction=(0,util_1.ensureBuffer)(params[0]),relay=await this.initializeRelay(),res=await relay.submitEthereumTransaction(signedTransaction,this.getChainId()).promise;if((0,Web3Response_1.isErrorResponse)(res))throw new Error(res.errorMessage);return{jsonrpc:"2.0",id:0,result:res.result}}async _eth_sendTransaction(params){this._requireAuthorization();const tx=this._prepareTransactionParams(params[0]||{});try{const relay=await this.initializeRelay(),res=await relay.signAndSubmitEthereumTransaction(tx).promise;if((0,Web3Response_1.isErrorResponse)(res))throw new Error(res.errorMessage);return{jsonrpc:"2.0",id:0,result:res.result}}catch(err){if("string"==typeof err.message&&err.message.match(/(denied|rejected)/i))throw error_1.standardErrors.provider.userRejectedRequest("User denied transaction signature");throw err}}async _eth_signTypedData_v1(params){this._requireAuthorization();const typedData=(0,util_1.ensureParsedJSONObject)(params[0]),address=(0,util_1.ensureAddressString)(params[1]);this._ensureKnownAddress(address);const message=eth_eip712_util_1.default.hashForSignTypedDataLegacy({data:typedData}),typedDataJSON=JSON.stringify(typedData,null,2);return this._signEthereumMessage(message,address,!1,typedDataJSON)}async _eth_signTypedData_v3(params){this._requireAuthorization();const address=(0,util_1.ensureAddressString)(params[0]),typedData=(0,util_1.ensureParsedJSONObject)(params[1]);this._ensureKnownAddress(address);const message=eth_eip712_util_1.default.hashForSignTypedData_v3({data:typedData}),typedDataJSON=JSON.stringify(typedData,null,2);return this._signEthereumMessage(message,address,!1,typedDataJSON)}async _eth_signTypedData_v4(params){this._requireAuthorization();const address=(0,util_1.ensureAddressString)(params[0]),typedData=(0,util_1.ensureParsedJSONObject)(params[1]);this._ensureKnownAddress(address);const message=eth_eip712_util_1.default.hashForSignTypedData_v4({data:typedData}),typedDataJSON=JSON.stringify(typedData,null,2);return this._signEthereumMessage(message,address,!1,typedDataJSON)}async _cbwallet_arbitrary(params){const action=params[0],data=params[1];if("string"!=typeof data)throw new Error("parameter must be a string");if("object"!=typeof action||null===action)throw new Error("parameter must be an object");return{jsonrpc:"2.0",id:0,result:await this.genericRequest(action,data)}}async _wallet_addEthereumChain(params){var _a,_b,_c,_d;const request=params[0];if(0===(null===(_a=request.rpcUrls)||void 0===_a?void 0:_a.length))return{jsonrpc:"2.0",id:0,error:{code:2,message:"please pass in at least 1 rpcUrl"}};if(!request.chainName||""===request.chainName.trim())throw error_1.standardErrors.rpc.invalidParams("chainName is a required field");if(!request.nativeCurrency)throw error_1.standardErrors.rpc.invalidParams("nativeCurrency is a required field");const chainIdNumber=parseInt(request.chainId,16);return await this.addEthereumChain(chainIdNumber,null!==(_b=request.rpcUrls)&&void 0!==_b?_b:[],null!==(_c=request.blockExplorerUrls)&&void 0!==_c?_c:[],request.chainName,null!==(_d=request.iconUrls)&&void 0!==_d?_d:[],request.nativeCurrency)?{jsonrpc:"2.0",id:0,result:null}:{jsonrpc:"2.0",id:0,error:{code:2,message:"unable to add ethereum chain"}}}async _wallet_switchEthereumChain(params){const request=params[0];return await this.switchEthereumChain(parseInt(request.chainId,16)),{jsonrpc:"2.0",id:0,result:null}}async _wallet_watchAsset(params){const request=Array.isArray(params)?params[0]:params;if(!request.type)throw error_1.standardErrors.rpc.invalidParams("Type is required");if("ERC20"!==(null==request?void 0:request.type))throw error_1.standardErrors.rpc.invalidParams(`Asset of type '${request.type}' is not supported`);if(!(null==request?void 0:request.options))throw error_1.standardErrors.rpc.invalidParams("Options are required");if(!(null==request?void 0:request.options.address))throw error_1.standardErrors.rpc.invalidParams("Address is required");const chainId=this.getChainId(),{address:address,symbol:symbol,image:image,decimals:decimals}=request.options;return{jsonrpc:"2.0",id:0,result:await this.watchAsset(request.type,address,symbol,decimals,image,chainId)}}_eth_uninstallFilter(params){const filterId=(0,util_1.ensureHexString)(params[0]);return this._filterPolyfill.uninstallFilter(filterId)}async _eth_newFilter(params){const param=params[0];return{jsonrpc:"2.0",id:0,result:await this._filterPolyfill.newFilter(param)}}async _eth_newBlockFilter(){return{jsonrpc:"2.0",id:0,result:await this._filterPolyfill.newBlockFilter()}}async _eth_newPendingTransactionFilter(){return{jsonrpc:"2.0",id:0,result:await this._filterPolyfill.newPendingTransactionFilter()}}_eth_getFilterChanges(params){const filterId=(0,util_1.ensureHexString)(params[0]);return this._filterPolyfill.getFilterChanges(filterId)}_eth_getFilterLogs(params){const filterId=(0,util_1.ensureHexString)(params[0]);return this._filterPolyfill.getFilterLogs(filterId)}initializeRelay(){return this._relay?Promise.resolve(this._relay):this._relayProvider().then((relay=>(relay.setAccountsCallback(((accounts,isDisconnect)=>this._setAddresses(accounts,isDisconnect))),relay.setChainCallback(((chainId,jsonRpcUrl)=>{this.updateProviderInfo(jsonRpcUrl,parseInt(chainId,10))})),relay.setDappDefaultChainCallback(this._chainIdFromOpts),this._relay=relay,relay)))}}exports.CoinbaseWalletProvider=CoinbaseWalletProvider;