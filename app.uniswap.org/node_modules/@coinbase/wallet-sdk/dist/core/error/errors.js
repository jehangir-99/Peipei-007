"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.standardErrors=void 0;const constants_1=require("./constants"),utils_1=require("./utils");function getEthJsonRpcError(code,arg){const[message,data]=parseOpts(arg);return new EthereumRpcError(code,message||(0,utils_1.getMessageFromCode)(code),data)}function getEthProviderError(code,arg){const[message,data]=parseOpts(arg);return new EthereumProviderError(code,message||(0,utils_1.getMessageFromCode)(code),data)}function parseOpts(arg){if(arg){if("string"==typeof arg)return[arg];if("object"==typeof arg&&!Array.isArray(arg)){const{message:message,data:data}=arg;if(message&&"string"!=typeof message)throw new Error("Must specify string message.");return[message||void 0,data]}}return[]}exports.standardErrors={rpc:{parse:arg=>getEthJsonRpcError(constants_1.standardErrorCodes.rpc.parse,arg),invalidRequest:arg=>getEthJsonRpcError(constants_1.standardErrorCodes.rpc.invalidRequest,arg),invalidParams:arg=>getEthJsonRpcError(constants_1.standardErrorCodes.rpc.invalidParams,arg),methodNotFound:arg=>getEthJsonRpcError(constants_1.standardErrorCodes.rpc.methodNotFound,arg),internal:arg=>getEthJsonRpcError(constants_1.standardErrorCodes.rpc.internal,arg),server:opts=>{if(!opts||"object"!=typeof opts||Array.isArray(opts))throw new Error("Ethereum RPC Server errors must provide single object argument.");const{code:code}=opts;if(!Number.isInteger(code)||code>-32005||code<-32099)throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');return getEthJsonRpcError(code,opts)},invalidInput:arg=>getEthJsonRpcError(constants_1.standardErrorCodes.rpc.invalidInput,arg),resourceNotFound:arg=>getEthJsonRpcError(constants_1.standardErrorCodes.rpc.resourceNotFound,arg),resourceUnavailable:arg=>getEthJsonRpcError(constants_1.standardErrorCodes.rpc.resourceUnavailable,arg),transactionRejected:arg=>getEthJsonRpcError(constants_1.standardErrorCodes.rpc.transactionRejected,arg),methodNotSupported:arg=>getEthJsonRpcError(constants_1.standardErrorCodes.rpc.methodNotSupported,arg),limitExceeded:arg=>getEthJsonRpcError(constants_1.standardErrorCodes.rpc.limitExceeded,arg)},provider:{userRejectedRequest:arg=>getEthProviderError(constants_1.standardErrorCodes.provider.userRejectedRequest,arg),unauthorized:arg=>getEthProviderError(constants_1.standardErrorCodes.provider.unauthorized,arg),unsupportedMethod:arg=>getEthProviderError(constants_1.standardErrorCodes.provider.unsupportedMethod,arg),disconnected:arg=>getEthProviderError(constants_1.standardErrorCodes.provider.disconnected,arg),chainDisconnected:arg=>getEthProviderError(constants_1.standardErrorCodes.provider.chainDisconnected,arg),unsupportedChain:arg=>getEthProviderError(constants_1.standardErrorCodes.provider.unsupportedChain,arg),custom:opts=>{if(!opts||"object"!=typeof opts||Array.isArray(opts))throw new Error("Ethereum Provider custom errors must provide single object argument.");const{code:code,message:message,data:data}=opts;if(!message||"string"!=typeof message)throw new Error('"message" must be a nonempty string');return new EthereumProviderError(code,message,data)}}};class EthereumRpcError extends Error{constructor(code,message,data){if(!Number.isInteger(code))throw new Error('"code" must be an integer.');if(!message||"string"!=typeof message)throw new Error('"message" must be a nonempty string.');super(message),this.code=code,void 0!==data&&(this.data=data)}}class EthereumProviderError extends EthereumRpcError{constructor(code,message,data){if(!isValidEthProviderCode(code))throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');super(code,message,data)}}function isValidEthProviderCode(code){return Number.isInteger(code)&&code>=1e3&&code<=4999}