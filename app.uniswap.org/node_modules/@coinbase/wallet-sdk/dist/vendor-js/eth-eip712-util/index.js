const util=require("./util"),abi=require("./abi"),TYPED_MESSAGE_SCHEMA={type:"object",properties:{types:{type:"object",additionalProperties:{type:"array",items:{type:"object",properties:{name:{type:"string"},type:{type:"string"}},required:["name","type"]}}},primaryType:{type:"string"},domain:{type:"object"},message:{type:"object"}},required:["types","primaryType","domain","message"]},TypedDataUtils={encodeData(primaryType,data,types,useV4=!0){const encodedTypes=["bytes32"],encodedValues=[this.hashType(primaryType,types)];if(useV4){const encodeField=(name,type,value)=>{if(void 0!==types[type])return["bytes32",null==value?"0x0000000000000000000000000000000000000000000000000000000000000000":util.keccak(this.encodeData(type,value,types,useV4))];if(void 0===value)throw new Error(`missing value for field ${name} of type ${type}`);if("bytes"===type)return["bytes32",util.keccak(value)];if("string"===type)return"string"==typeof value&&(value=Buffer.from(value,"utf8")),["bytes32",util.keccak(value)];if(type.lastIndexOf("]")===type.length-1){const parsedType=type.slice(0,type.lastIndexOf("[")),typeValuePairs=value.map((item=>encodeField(name,parsedType,item)));return["bytes32",util.keccak(abi.rawEncode(typeValuePairs.map((([type])=>type)),typeValuePairs.map((([,value])=>value))))]}return[type,value]};for(const field of types[primaryType]){const[type,value]=encodeField(field.name,field.type,data[field.name]);encodedTypes.push(type),encodedValues.push(value)}}else for(const field of types[primaryType]){let value=data[field.name];if(void 0!==value)if("bytes"===field.type)encodedTypes.push("bytes32"),value=util.keccak(value),encodedValues.push(value);else if("string"===field.type)encodedTypes.push("bytes32"),"string"==typeof value&&(value=Buffer.from(value,"utf8")),value=util.keccak(value),encodedValues.push(value);else if(void 0!==types[field.type])encodedTypes.push("bytes32"),value=util.keccak(this.encodeData(field.type,value,types,useV4)),encodedValues.push(value);else{if(field.type.lastIndexOf("]")===field.type.length-1)throw new Error("Arrays currently unimplemented in encodeData");encodedTypes.push(field.type),encodedValues.push(value)}}return abi.rawEncode(encodedTypes,encodedValues)},encodeType(primaryType,types){let result="",deps=this.findTypeDependencies(primaryType,types).filter((dep=>dep!==primaryType));deps=[primaryType].concat(deps.sort());for(const type of deps){if(!types[type])throw new Error("No type definition specified: "+type);result+=type+"("+types[type].map((({name:name,type:type})=>type+" "+name)).join(",")+")"}return result},findTypeDependencies(primaryType,types,results=[]){if(primaryType=primaryType.match(/^\w*/)[0],results.includes(primaryType)||void 0===types[primaryType])return results;results.push(primaryType);for(const field of types[primaryType])for(const dep of this.findTypeDependencies(field.type,types,results))!results.includes(dep)&&results.push(dep);return results},hashStruct(primaryType,data,types,useV4=!0){return util.keccak(this.encodeData(primaryType,data,types,useV4))},hashType(primaryType,types){return util.keccak(this.encodeType(primaryType,types))},sanitizeData(data){const sanitizedData={};for(const key in TYPED_MESSAGE_SCHEMA.properties)data[key]&&(sanitizedData[key]=data[key]);return sanitizedData.types&&(sanitizedData.types=Object.assign({EIP712Domain:[]},sanitizedData.types)),sanitizedData},hash(typedData,useV4=!0){const sanitizedData=this.sanitizeData(typedData),parts=[Buffer.from("1901","hex")];return parts.push(this.hashStruct("EIP712Domain",sanitizedData.domain,sanitizedData.types,useV4)),"EIP712Domain"!==sanitizedData.primaryType&&parts.push(this.hashStruct(sanitizedData.primaryType,sanitizedData.message,sanitizedData.types,useV4)),util.keccak(Buffer.concat(parts))}};function typedSignatureHashLegacy(typedData){const error=new Error("Expect argument to be non-empty array");if("object"!=typeof typedData||!typedData.length)throw error;const data=typedData.map((function(e){return"bytes"===e.type?util.toBuffer(e.value):e.value})),types=typedData.map((function(e){return e.type})),schema=typedData.map((function(e){if(!e.name)throw error;return e.type+" "+e.name}));return abi.soliditySHA3(["bytes32","bytes32"],[abi.soliditySHA3(new Array(typedData.length).fill("string"),schema),abi.soliditySHA3(types,data)])}module.exports={TYPED_MESSAGE_SCHEMA:TYPED_MESSAGE_SCHEMA,TypedDataUtils:TypedDataUtils,hashForSignTypedDataLegacy:function(msgParams){return typedSignatureHashLegacy(msgParams.data)},hashForSignTypedData_v3:function(msgParams){return TypedDataUtils.hash(msgParams.data,!1)},hashForSignTypedData_v4:function(msgParams){return TypedDataUtils.hash(msgParams.data)}};