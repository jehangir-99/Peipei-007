"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.WalletLinkConnection=void 0;const type_1=require("../../../core/type"),Cipher_1=require("../../../lib/Cipher"),DiagnosticLogger_1=require("../../../provider/DiagnosticLogger"),RelayAbstract_1=require("../../RelayAbstract"),Session_1=require("../../Session"),WalletLinkHTTP_1=require("./WalletLinkHTTP"),WalletLinkWebSocket_1=require("./WalletLinkWebSocket"),HEARTBEAT_INTERVAL=1e4,REQUEST_TIMEOUT=6e4;class WalletLinkConnection{constructor({session:session,linkAPIUrl:linkAPIUrl,listener:listener,diagnostic:diagnostic,WebSocketClass:WebSocketClass=WebSocket}){this.destroyed=!1,this.lastHeartbeatResponse=0,this.nextReqId=(0,type_1.IntNumber)(1),this._connected=!1,this._linked=!1,this.shouldFetchUnseenEventsOnConnect=!1,this.requestResolutions=new Map,this.handleSessionMetadataUpdated=metadata=>{if(!metadata)return;new Map([["__destroyed",this.handleDestroyed],["EthereumAddress",this.handleAccountUpdated],["WalletUsername",this.handleWalletUsernameUpdated],["AppVersion",this.handleAppVersionUpdated],["ChainId",v=>metadata.JsonRpcUrl&&this.handleChainUpdated(v,metadata.JsonRpcUrl)]]).forEach(((handler,key)=>{const value=metadata[key];void 0!==value&&handler(value)}))},this.handleDestroyed=__destroyed=>{var _a,_b;"1"===__destroyed&&(null===(_a=this.listener)||void 0===_a||_a.resetAndReload(),null===(_b=this.diagnostic)||void 0===_b||_b.log(DiagnosticLogger_1.EVENTS.METADATA_DESTROYED,{alreadyDestroyed:this.isDestroyed,sessionIdHash:Session_1.Session.hash(this.session.id)}))},this.handleAccountUpdated=async encryptedEthereumAddress=>{var _a,_b;try{const address=await this.cipher.decrypt(encryptedEthereumAddress);null===(_a=this.listener)||void 0===_a||_a.accountUpdated(address)}catch(_c){null===(_b=this.diagnostic)||void 0===_b||_b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR,{message:"Had error decrypting",value:"selectedAddress"})}},this.handleMetadataUpdated=async(key,encryptedMetadataValue)=>{var _a,_b;try{const decryptedValue=await this.cipher.decrypt(encryptedMetadataValue);null===(_a=this.listener)||void 0===_a||_a.metadataUpdated(key,decryptedValue)}catch(_c){null===(_b=this.diagnostic)||void 0===_b||_b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR,{message:"Had error decrypting",value:key})}},this.handleWalletUsernameUpdated=async walletUsername=>{this.handleMetadataUpdated(RelayAbstract_1.WALLET_USER_NAME_KEY,walletUsername)},this.handleAppVersionUpdated=async appVersion=>{this.handleMetadataUpdated(RelayAbstract_1.APP_VERSION_KEY,appVersion)},this.handleChainUpdated=async(encryptedChainId,encryptedJsonRpcUrl)=>{var _a,_b;try{const chainId=await this.cipher.decrypt(encryptedChainId),jsonRpcUrl=await this.cipher.decrypt(encryptedJsonRpcUrl);null===(_a=this.listener)||void 0===_a||_a.chainUpdated(chainId,jsonRpcUrl)}catch(_c){null===(_b=this.diagnostic)||void 0===_b||_b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR,{message:"Had error decrypting",value:"chainId|jsonRpcUrl"})}},this.session=session,this.cipher=new Cipher_1.Cipher(session.secret),this.diagnostic=diagnostic,this.listener=listener;const ws=new WalletLinkWebSocket_1.WalletLinkWebSocket(`${linkAPIUrl}/rpc`,WebSocketClass);ws.setConnectionStateListener((async state=>{var _a;null===(_a=this.diagnostic)||void 0===_a||_a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE,{state:state,sessionIdHash:Session_1.Session.hash(session.id)});let connected=!1;switch(state){case WalletLinkWebSocket_1.ConnectionState.DISCONNECTED:if(!this.destroyed){const connect=async()=>{await new Promise((resolve=>setTimeout(resolve,5e3))),this.destroyed||ws.connect().catch((()=>{connect()}))};connect()}break;case WalletLinkWebSocket_1.ConnectionState.CONNECTED:try{await this.authenticate(),this.sendIsLinked(),this.sendGetSessionConfig(),connected=!0}catch(_b){}this.updateLastHeartbeat(),setInterval((()=>{this.heartbeat()}),1e4),this.shouldFetchUnseenEventsOnConnect&&this.fetchUnseenEventsAPI();case WalletLinkWebSocket_1.ConnectionState.CONNECTING:}this.connected!==connected&&(this.connected=connected)})),ws.setIncomingDataListener((m=>{var _a,_b,_c;switch(m.type){case"Heartbeat":return void this.updateLastHeartbeat();case"IsLinkedOK":case"Linked":{const linked="IsLinkedOK"===m.type?m.linked:void 0;null===(_a=this.diagnostic)||void 0===_a||_a.log(DiagnosticLogger_1.EVENTS.LINKED,{sessionIdHash:Session_1.Session.hash(session.id),linked:linked,type:m.type,onlineGuests:m.onlineGuests}),this.linked=linked||m.onlineGuests>0;break}case"GetSessionConfigOK":case"SessionConfigUpdated":null===(_b=this.diagnostic)||void 0===_b||_b.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED,{sessionIdHash:Session_1.Session.hash(session.id),metadata_keys:m&&m.metadata?Object.keys(m.metadata):void 0}),this.handleSessionMetadataUpdated(m.metadata);break;case"Event":this.handleIncomingEvent(m)}void 0!==m.id&&(null===(_c=this.requestResolutions.get(m.id))||void 0===_c||_c(m))})),this.ws=ws,this.http=new WalletLinkHTTP_1.WalletLinkHTTP(linkAPIUrl,session.id,session.key)}connect(){var _a;if(this.destroyed)throw new Error("instance is destroyed");null===(_a=this.diagnostic)||void 0===_a||_a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING,{sessionIdHash:Session_1.Session.hash(this.session.id)}),this.ws.connect()}destroy(){var _a;this.destroyed=!0,this.ws.disconnect(),null===(_a=this.diagnostic)||void 0===_a||_a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED,{sessionIdHash:Session_1.Session.hash(this.session.id)}),this.listener=void 0}get isDestroyed(){return this.destroyed}get connected(){return this._connected}set connected(connected){var _a,_b;this._connected=connected,connected&&(null===(_a=this.onceConnected)||void 0===_a||_a.call(this)),null===(_b=this.listener)||void 0===_b||_b.connectedUpdated(connected)}setOnceConnected(callback){return new Promise((resolve=>{this.connected?callback().then(resolve):this.onceConnected=()=>{callback().then(resolve),this.onceConnected=void 0}}))}get linked(){return this._linked}set linked(linked){var _a,_b;this._linked=linked,linked&&(null===(_a=this.onceLinked)||void 0===_a||_a.call(this)),null===(_b=this.listener)||void 0===_b||_b.linkedUpdated(linked)}setOnceLinked(callback){return new Promise((resolve=>{this.linked?callback().then(resolve):this.onceLinked=()=>{callback().then(resolve),this.onceLinked=void 0}}))}async handleIncomingEvent(m){var _a,_b;if("Event"===m.type&&"Web3Response"===m.event)try{const decryptedData=await this.cipher.decrypt(m.data),message=JSON.parse(decryptedData);if("WEB3_RESPONSE"!==message.type)return;null===(_a=this.listener)||void 0===_a||_a.handleWeb3ResponseMessage(message)}catch(_c){null===(_b=this.diagnostic)||void 0===_b||_b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR,{message:"Had error decrypting",value:"incomingEvent"})}}async checkUnseenEvents(){if(this.connected){await new Promise((resolve=>setTimeout(resolve,250)));try{await this.fetchUnseenEventsAPI()}catch(e){console.error("Unable to check for unseen events",e)}}else this.shouldFetchUnseenEventsOnConnect=!0}async fetchUnseenEventsAPI(){this.shouldFetchUnseenEventsOnConnect=!1;(await this.http.fetchUnseenEvents()).forEach((e=>this.handleIncomingEvent(e)))}async setSessionMetadata(key,value){const message={type:"SetSessionConfig",id:(0,type_1.IntNumber)(this.nextReqId++),sessionId:this.session.id,metadata:{[key]:value}};return this.setOnceConnected((async()=>{const res=await this.makeRequest(message);if("Fail"===res.type)throw new Error(res.error||"failed to set session metadata")}))}async publishEvent(event,unencryptedData,callWebhook=!1){const data=await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({},unencryptedData),{origin:location.origin,relaySource:window.coinbaseWalletExtension?"injected_sdk":"sdk"}))),message={type:"PublishEvent",id:(0,type_1.IntNumber)(this.nextReqId++),sessionId:this.session.id,event:event,data:data,callWebhook:callWebhook};return this.setOnceLinked((async()=>{const res=await this.makeRequest(message);if("Fail"===res.type)throw new Error(res.error||"failed to publish event");return res.eventId}))}sendData(message){this.ws.sendData(JSON.stringify(message))}updateLastHeartbeat(){this.lastHeartbeatResponse=Date.now()}heartbeat(){if(Date.now()-this.lastHeartbeatResponse>2e4)this.ws.disconnect();else try{this.ws.sendData("h")}catch(_a){}}async makeRequest(message,timeout=6e4){const reqId=message.id;let timeoutId;return this.sendData(message),Promise.race([new Promise(((_,reject)=>{timeoutId=window.setTimeout((()=>{reject(new Error(`request ${reqId} timed out`))}),timeout)})),new Promise((resolve=>{this.requestResolutions.set(reqId,(m=>{clearTimeout(timeoutId),resolve(m),this.requestResolutions.delete(reqId)}))}))])}async authenticate(){const m={type:"HostSession",id:(0,type_1.IntNumber)(this.nextReqId++),sessionId:this.session.id,sessionKey:this.session.key},res=await this.makeRequest(m);if("Fail"===res.type)throw new Error(res.error||"failed to authentcate")}sendIsLinked(){const m={type:"IsLinked",id:(0,type_1.IntNumber)(this.nextReqId++),sessionId:this.session.id};this.sendData(m)}sendGetSessionConfig(){const m={type:"GetSessionConfig",id:(0,type_1.IntNumber)(this.nextReqId++),sessionId:this.session.id};this.sendData(m)}}exports.WalletLinkConnection=WalletLinkConnection;