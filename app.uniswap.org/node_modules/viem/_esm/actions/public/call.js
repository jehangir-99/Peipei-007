import{parseAccount}from"../../accounts/utils/parseAccount.js";import{multicall3Abi}from"../../constants/abis.js";import{aggregate3Signature}from"../../constants/contract.js";import{InvalidAddressError}from"../../errors/address.js";import{BaseError}from"../../errors/base.js";import{ChainDoesNotSupportContract,ClientChainNotConfiguredError}from"../../errors/chain.js";import{RawContractError}from"../../errors/contract.js";import{InvalidBytesLengthError}from"../../errors/data.js";import{AccountStateConflictError,StateAssignmentConflictError}from"../../errors/stateOverride.js";import{decodeFunctionResult}from"../../utils/abi/decodeFunctionResult.js";import{encodeFunctionData}from"../../utils/abi/encodeFunctionData.js";import{isAddress}from"../../utils/address/isAddress.js";import{getChainContractAddress}from"../../utils/chain/getChainContractAddress.js";import{numberToHex}from"../../utils/encoding/toHex.js";import{getCallError}from"../../utils/errors/getCallError.js";import{extract}from"../../utils/formatters/extract.js";import{formatTransactionRequest}from"../../utils/formatters/transactionRequest.js";import{createBatchScheduler}from"../../utils/promise/createBatchScheduler.js";import{assertRequest}from"../../utils/transaction/assertRequest.js";export async function call(client,args){const{account:account_=client.account,batch:batch=Boolean(client.batch?.multicall),blockNumber:blockNumber,blockTag:blockTag="latest",accessList:accessList,blobs:blobs,data:data,gas:gas,gasPrice:gasPrice,maxFeePerBlobGas:maxFeePerBlobGas,maxFeePerGas:maxFeePerGas,maxPriorityFeePerGas:maxPriorityFeePerGas,nonce:nonce,to:to,value:value,stateOverride:stateOverride,...rest}=args,account=account_?parseAccount(account_):void 0;try{assertRequest(args);const block=(blockNumber?numberToHex(blockNumber):void 0)||blockTag,rpcStateOverride=parseStateOverride(stateOverride),chainFormat=client.chain?.formatters?.transactionRequest?.format,request=(chainFormat||formatTransactionRequest)({...extract(rest,{format:chainFormat}),from:account?.address,accessList:accessList,blobs:blobs,data:data,gas:gas,gasPrice:gasPrice,maxFeePerBlobGas:maxFeePerBlobGas,maxFeePerGas:maxFeePerGas,maxPriorityFeePerGas:maxPriorityFeePerGas,nonce:nonce,to:to,value:value});if(batch&&shouldPerformMulticall({request:request})&&!rpcStateOverride)try{return await scheduleMulticall(client,{...request,blockNumber:blockNumber,blockTag:blockTag})}catch(err){if(!(err instanceof ClientChainNotConfiguredError||err instanceof ChainDoesNotSupportContract))throw err}const response=await client.request({method:"eth_call",params:rpcStateOverride?[request,block,rpcStateOverride]:[request,block]});return"0x"===response?{data:void 0}:{data:response}}catch(err){const data=getRevertErrorData(err),{offchainLookup:offchainLookup,offchainLookupSignature:offchainLookupSignature}=await import("../../utils/ccip.js");if(!1!==client.ccipRead&&data?.slice(0,10)===offchainLookupSignature&&to)return{data:await offchainLookup(client,{data:data,to:to})};throw getCallError(err,{...args,account:account,chain:client.chain})}}function shouldPerformMulticall({request:request}){const{data:data,to:to,...request_}=request;return!!data&&(!data.startsWith(aggregate3Signature)&&(!!to&&!(Object.values(request_).filter((x=>void 0!==x)).length>0)))}async function scheduleMulticall(client,args){const{batchSize:batchSize=1024,wait:wait=0}="object"==typeof client.batch?.multicall?client.batch.multicall:{},{blockNumber:blockNumber,blockTag:blockTag="latest",data:data,multicallAddress:multicallAddress_,to:to}=args;let multicallAddress=multicallAddress_;if(!multicallAddress){if(!client.chain)throw new ClientChainNotConfiguredError;multicallAddress=getChainContractAddress({blockNumber:blockNumber,chain:client.chain,contract:"multicall3"})}const block=(blockNumber?numberToHex(blockNumber):void 0)||blockTag,{schedule:schedule}=createBatchScheduler({id:`${client.uid}.${block}`,wait:wait,shouldSplitBatch(args){const size=args.reduce(((size,{data:data})=>size+(data.length-2)),0);return size>2*batchSize},fn:async requests=>{const calls=requests.map((request=>({allowFailure:!0,callData:request.data,target:request.to}))),calldata=encodeFunctionData({abi:multicall3Abi,args:[calls],functionName:"aggregate3"}),data=await client.request({method:"eth_call",params:[{data:calldata,to:multicallAddress},block]});return decodeFunctionResult({abi:multicall3Abi,args:[calls],functionName:"aggregate3",data:data||"0x"})}}),[{returnData:returnData,success:success}]=await schedule({data:data,to:to});if(!success)throw new RawContractError({data:returnData});return"0x"===returnData?{data:void 0}:{data:returnData}}export function getRevertErrorData(err){if(!(err instanceof BaseError))return;const error=err.walk();return"object"==typeof error?.data?error.data?.data:error.data}export function parseStateMapping(stateMapping){if(stateMapping&&0!==stateMapping.length)return stateMapping.reduce(((acc,{slot:slot,value:value})=>{if(66!==slot.length)throw new InvalidBytesLengthError({size:slot.length,targetSize:66,type:"hex"});if(66!==value.length)throw new InvalidBytesLengthError({size:value.length,targetSize:66,type:"hex"});return acc[slot]=value,acc}),{})}export function parseAccountStateOverride(args){const{balance:balance,nonce:nonce,state:state,stateDiff:stateDiff,code:code}=args,rpcAccountStateOverride={};if(void 0!==code&&(rpcAccountStateOverride.code=code),void 0!==balance&&(rpcAccountStateOverride.balance=numberToHex(balance)),void 0!==nonce&&(rpcAccountStateOverride.nonce=numberToHex(nonce)),void 0!==state&&(rpcAccountStateOverride.state=parseStateMapping(state)),void 0!==stateDiff){if(rpcAccountStateOverride.state)throw new StateAssignmentConflictError;rpcAccountStateOverride.stateDiff=parseStateMapping(stateDiff)}return rpcAccountStateOverride}export function parseStateOverride(args){if(!args)return;const rpcStateOverride={};for(const{address:address,...accountState}of args){if(!isAddress(address,{strict:!1}))throw new InvalidAddressError({address:address});if(rpcStateOverride[address])throw new AccountStateConflictError({address:address});rpcStateOverride[address]=parseAccountStateOverride(accountState)}return rpcStateOverride}