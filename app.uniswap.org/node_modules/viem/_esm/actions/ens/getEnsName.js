import{universalResolverReverseAbi}from"../../constants/abis.js";import{getChainContractAddress}from"../../utils/chain/getChainContractAddress.js";import{toHex}from"../../utils/encoding/toHex.js";import{isNullUniversalResolverError}from"../../utils/ens/errors.js";import{packetToBytes}from"../../utils/ens/packetToBytes.js";import{getAction}from"../../utils/getAction.js";import{readContract}from"../public/readContract.js";export async function getEnsName(client,{address:address,blockNumber:blockNumber,blockTag:blockTag,gatewayUrls:gatewayUrls,strict:strict,universalResolverAddress:universalResolverAddress_}){let universalResolverAddress=universalResolverAddress_;if(!universalResolverAddress){if(!client.chain)throw new Error("client chain not configured. universalResolverAddress is required.");universalResolverAddress=getChainContractAddress({blockNumber:blockNumber,chain:client.chain,contract:"ensUniversalResolver"})}const reverseNode=`${address.toLowerCase().substring(2)}.addr.reverse`;try{const readContractParameters={address:universalResolverAddress,abi:universalResolverReverseAbi,functionName:"reverse",args:[toHex(packetToBytes(reverseNode))],blockNumber:blockNumber,blockTag:blockTag},readContractAction=getAction(client,readContract,"readContract"),[name,resolvedAddress]=gatewayUrls?await readContractAction({...readContractParameters,args:[...readContractParameters.args,gatewayUrls]}):await readContractAction(readContractParameters);return address.toLowerCase()!==resolvedAddress.toLowerCase()?null:name}catch(err){if(strict)throw err;if(isNullUniversalResolverError(err,"reverse"))return null;throw err}}