import{bytesPerBlob,bytesPerFieldElement,fieldElementsPerBlob,maxBytesPerTransaction}from"../../constants/blob.js";import{BlobSizeTooLargeError,EmptyBlobError}from"../../errors/blob.js";import{createCursor}from"../cursor.js";import{size}from"../data/size.js";import{hexToBytes}from"../encoding/toBytes.js";import{bytesToHex}from"../encoding/toHex.js";export function toBlobs(parameters){const to=parameters.to??("string"==typeof parameters.data?"hex":"bytes"),data="string"==typeof parameters.data?hexToBytes(parameters.data):parameters.data,size_=size(data);if(!size_)throw new EmptyBlobError;if(size_>maxBytesPerTransaction)throw new BlobSizeTooLargeError({maxSize:maxBytesPerTransaction,size:size_});const blobs=[];let active=!0,position=0;for(;active;){const blob=createCursor(new Uint8Array(bytesPerBlob));let size=0;for(;size<fieldElementsPerBlob;){const bytes=data.slice(position,position+(bytesPerFieldElement-1));if(blob.pushByte(0),blob.pushBytes(bytes),bytes.length<31){blob.pushByte(128),active=!1;break}size++,position+=31}blobs.push(blob)}return"bytes"===to?blobs.map((x=>x.bytes)):blobs.map((x=>bytesToHex(x.bytes)))}