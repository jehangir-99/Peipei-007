import{BaseError}from"../../errors/base.js";import{isHex}from"../data/isHex.js";import{pad}from"../data/pad.js";import{assertSize}from"./fromHex.js";import{numberToHex}from"./toHex.js";const encoder=new TextEncoder;export function toBytes(value,opts={}){return"number"==typeof value||"bigint"==typeof value?numberToBytes(value,opts):"boolean"==typeof value?boolToBytes(value,opts):isHex(value)?hexToBytes(value,opts):stringToBytes(value,opts)}export function boolToBytes(value,opts={}){const bytes=new Uint8Array(1);return bytes[0]=Number(value),"number"==typeof opts.size?(assertSize(bytes,{size:opts.size}),pad(bytes,{size:opts.size})):bytes}const charCodeMap={zero:48,nine:57,A:65,F:70,a:97,f:102};function charCodeToBase16(char){return char>=charCodeMap.zero&&char<=charCodeMap.nine?char-charCodeMap.zero:char>=charCodeMap.A&&char<=charCodeMap.F?char-(charCodeMap.A-10):char>=charCodeMap.a&&char<=charCodeMap.f?char-(charCodeMap.a-10):void 0}export function hexToBytes(hex_,opts={}){let hex=hex_;opts.size&&(assertSize(hex,{size:opts.size}),hex=pad(hex,{dir:"right",size:opts.size}));let hexString=hex.slice(2);hexString.length%2&&(hexString=`0${hexString}`);const length=hexString.length/2,bytes=new Uint8Array(length);for(let index=0,j=0;index<length;index++){const nibbleLeft=charCodeToBase16(hexString.charCodeAt(j++)),nibbleRight=charCodeToBase16(hexString.charCodeAt(j++));if(void 0===nibbleLeft||void 0===nibbleRight)throw new BaseError(`Invalid byte sequence ("${hexString[j-2]}${hexString[j-1]}" in "${hexString}").`);bytes[index]=16*nibbleLeft+nibbleRight}return bytes}export function numberToBytes(value,opts){return hexToBytes(numberToHex(value,opts))}export function stringToBytes(value,opts={}){const bytes=encoder.encode(value);return"number"==typeof opts.size?(assertSize(bytes,{size:opts.size}),pad(bytes,{dir:"right",size:opts.size})):bytes}