import{InvalidBytesBooleanError}from"../../errors/encoding.js";import{trim}from"../data/trim.js";import{assertSize,hexToBigInt,hexToNumber}from"./fromHex.js";import{bytesToHex}from"./toHex.js";export function fromBytes(bytes,toOrOpts){const opts="string"==typeof toOrOpts?{to:toOrOpts}:toOrOpts,to=opts.to;return"number"===to?bytesToNumber(bytes,opts):"bigint"===to?bytesToBigInt(bytes,opts):"boolean"===to?bytesToBool(bytes,opts):"string"===to?bytesToString(bytes,opts):bytesToHex(bytes,opts)}export function bytesToBigInt(bytes,opts={}){void 0!==opts.size&&assertSize(bytes,{size:opts.size});const hex=bytesToHex(bytes,opts);return hexToBigInt(hex,opts)}export function bytesToBool(bytes_,opts={}){let bytes=bytes_;if(void 0!==opts.size&&(assertSize(bytes,{size:opts.size}),bytes=trim(bytes)),bytes.length>1||bytes[0]>1)throw new InvalidBytesBooleanError(bytes);return Boolean(bytes[0])}export function bytesToNumber(bytes,opts={}){void 0!==opts.size&&assertSize(bytes,{size:opts.size});const hex=bytesToHex(bytes,opts);return hexToNumber(hex,opts)}export function bytesToString(bytes_,opts={}){let bytes=bytes_;return void 0!==opts.size&&(assertSize(bytes,{size:opts.size}),bytes=trim(bytes,{dir:"right"})),(new TextDecoder).decode(bytes)}