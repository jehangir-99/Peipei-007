import{InvalidHexBooleanError,SizeOverflowError}from"../../errors/encoding.js";import{size as size_}from"../data/size.js";import{trim}from"../data/trim.js";import{hexToBytes}from"./toBytes.js";export function assertSize(hexOrBytes,{size:size}){if(size_(hexOrBytes)>size)throw new SizeOverflowError({givenSize:size_(hexOrBytes),maxSize:size})}export function fromHex(hex,toOrOpts){const opts="string"==typeof toOrOpts?{to:toOrOpts}:toOrOpts,to=opts.to;return"number"===to?hexToNumber(hex,opts):"bigint"===to?hexToBigInt(hex,opts):"string"===to?hexToString(hex,opts):"boolean"===to?hexToBool(hex,opts):hexToBytes(hex,opts)}export function hexToBigInt(hex,opts={}){const{signed:signed}=opts;opts.size&&assertSize(hex,{size:opts.size});const value=BigInt(hex);if(!signed)return value;const size=(hex.length-2)/2;return value<=(1n<<8n*BigInt(size)-1n)-1n?value:value-BigInt(`0x${"f".padStart(2*size,"f")}`)-1n}export function hexToBool(hex_,opts={}){let hex=hex_;if(opts.size&&(assertSize(hex,{size:opts.size}),hex=trim(hex)),"0x00"===trim(hex))return!1;if("0x01"===trim(hex))return!0;throw new InvalidHexBooleanError(hex)}export function hexToNumber(hex,opts={}){return Number(hexToBigInt(hex,opts))}export function hexToString(hex,opts={}){let bytes=hexToBytes(hex);return opts.size&&(assertSize(bytes,{size:opts.size}),bytes=trim(bytes,{dir:"right"})),(new TextDecoder).decode(bytes)}