import{}from"abitype";import{AbiItemAmbiguityError}from"../../errors/abi.js";import{isHex}from"../../utils/data/isHex.js";import{isAddress}from"../address/isAddress.js";import{toEventSelector}from"../hash/toEventSelector.js";import{toFunctionSelector}from"../hash/toFunctionSelector.js";export function getAbiItem(parameters){const{abi:abi,args:args=[],name:name}=parameters,isSelector=isHex(name,{strict:!1}),abiItems=abi.filter((abiItem=>isSelector?"function"===abiItem.type?toFunctionSelector(abiItem)===name:"event"===abiItem.type&&toEventSelector(abiItem)===name:"name"in abiItem&&abiItem.name===name));if(0===abiItems.length)return;if(1===abiItems.length)return abiItems[0];let matchedAbiItem;for(const abiItem of abiItems){if(!("inputs"in abiItem))continue;if(!args||0===args.length){if(!abiItem.inputs||0===abiItem.inputs.length)return abiItem;continue}if(!abiItem.inputs)continue;if(0===abiItem.inputs.length)continue;if(abiItem.inputs.length!==args.length)continue;if(args.every(((arg,index)=>{const abiParameter="inputs"in abiItem&&abiItem.inputs[index];return!!abiParameter&&isArgOfType(arg,abiParameter)}))){if(matchedAbiItem&&"inputs"in matchedAbiItem&&matchedAbiItem.inputs){const ambiguousTypes=getAmbiguousTypes(abiItem.inputs,matchedAbiItem.inputs,args);if(ambiguousTypes)throw new AbiItemAmbiguityError({abiItem:abiItem,type:ambiguousTypes[0]},{abiItem:matchedAbiItem,type:ambiguousTypes[1]})}matchedAbiItem=abiItem}}return matchedAbiItem||abiItems[0]}export function isArgOfType(arg,abiParameter){const argType=typeof arg,abiParameterType=abiParameter.type;switch(abiParameterType){case"address":return isAddress(arg,{strict:!1});case"bool":return"boolean"===argType;case"function":case"string":return"string"===argType;default:return"tuple"===abiParameterType&&"components"in abiParameter?Object.values(abiParameter.components).every(((component,index)=>isArgOfType(Object.values(arg)[index],component))):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)?"number"===argType||"bigint"===argType:/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)?"string"===argType||arg instanceof Uint8Array:!!/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)&&(Array.isArray(arg)&&arg.every((x=>isArgOfType(x,{...abiParameter,type:abiParameterType.replace(/(\[[0-9]{0,}\])$/,"")}))))}}export function getAmbiguousTypes(sourceParameters,targetParameters,args){for(const parameterIndex in sourceParameters){const sourceParameter=sourceParameters[parameterIndex],targetParameter=targetParameters[parameterIndex];if("tuple"===sourceParameter.type&&"tuple"===targetParameter.type&&"components"in sourceParameter&&"components"in targetParameter)return getAmbiguousTypes(sourceParameter.components,targetParameter.components,args[parameterIndex]);const types=[sourceParameter.type,targetParameter.type];if(!(!types.includes("address")||!types.includes("bytes20"))||(types.includes("address")&&types.includes("string")||!(!types.includes("address")||!types.includes("bytes")))&&isAddress(args[parameterIndex],{strict:!1}))return types}}