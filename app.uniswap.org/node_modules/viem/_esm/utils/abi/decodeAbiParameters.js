import{AbiDecodingDataSizeTooSmallError,AbiDecodingZeroDataError,InvalidAbiDecodingTypeError}from"../../errors/abi.js";import{checksumAddress}from"../address/getAddress.js";import{createCursor}from"../cursor.js";import{size}from"../data/size.js";import{sliceBytes}from"../data/slice.js";import{trim}from"../data/trim.js";import{bytesToBigInt,bytesToBool,bytesToNumber,bytesToString}from"../encoding/fromBytes.js";import{hexToBytes}from"../encoding/toBytes.js";import{bytesToHex}from"../encoding/toHex.js";import{getArrayComponents}from"./encodeAbiParameters.js";export function decodeAbiParameters(params,data){const bytes="string"==typeof data?hexToBytes(data):data,cursor=createCursor(bytes);if(0===size(bytes)&&params.length>0)throw new AbiDecodingZeroDataError;if(size(data)&&size(data)<32)throw new AbiDecodingDataSizeTooSmallError({data:"string"==typeof data?data:bytesToHex(data),params:params,size:size(data)});let consumed=0;const values=[];for(let i=0;i<params.length;++i){const param=params[i];cursor.setPosition(consumed);const[data,consumed_]=decodeParameter(cursor,param,{staticPosition:0});consumed+=consumed_,values.push(data)}return values}function decodeParameter(cursor,param,{staticPosition:staticPosition}){const arrayComponents=getArrayComponents(param.type);if(arrayComponents){const[length,type]=arrayComponents;return decodeArray(cursor,{...param,type:type},{length:length,staticPosition:staticPosition})}if("tuple"===param.type)return decodeTuple(cursor,param,{staticPosition:staticPosition});if("address"===param.type)return decodeAddress(cursor);if("bool"===param.type)return decodeBool(cursor);if(param.type.startsWith("bytes"))return decodeBytes(cursor,param,{staticPosition:staticPosition});if(param.type.startsWith("uint")||param.type.startsWith("int"))return decodeNumber(cursor,param);if("string"===param.type)return decodeString(cursor,{staticPosition:staticPosition});throw new InvalidAbiDecodingTypeError(param.type,{docsPath:"/docs/contract/decodeAbiParameters"})}const sizeOfLength=32,sizeOfOffset=32;function decodeAddress(cursor){const value=cursor.readBytes(32);return[checksumAddress(bytesToHex(sliceBytes(value,-20))),32]}function decodeArray(cursor,param,{length:length,staticPosition:staticPosition}){if(!length){const start=staticPosition+bytesToNumber(cursor.readBytes(sizeOfOffset)),startOfData=start+sizeOfLength;cursor.setPosition(start);const length=bytesToNumber(cursor.readBytes(sizeOfLength)),dynamicChild=hasDynamicChild(param);let consumed=0;const value=[];for(let i=0;i<length;++i){cursor.setPosition(startOfData+(dynamicChild?32*i:consumed));const[data,consumed_]=decodeParameter(cursor,param,{staticPosition:startOfData});consumed+=consumed_,value.push(data)}return cursor.setPosition(staticPosition+32),[value,32]}if(hasDynamicChild(param)){const start=staticPosition+bytesToNumber(cursor.readBytes(sizeOfOffset)),value=[];for(let i=0;i<length;++i){cursor.setPosition(start+32*i);const[data]=decodeParameter(cursor,param,{staticPosition:start});value.push(data)}return cursor.setPosition(staticPosition+32),[value,32]}let consumed=0;const value=[];for(let i=0;i<length;++i){const[data,consumed_]=decodeParameter(cursor,param,{staticPosition:staticPosition+consumed});consumed+=consumed_,value.push(data)}return[value,consumed]}function decodeBool(cursor){return[bytesToBool(cursor.readBytes(32),{size:32}),32]}function decodeBytes(cursor,param,{staticPosition:staticPosition}){const[_,size]=param.type.split("bytes");if(!size){const offset=bytesToNumber(cursor.readBytes(32));cursor.setPosition(staticPosition+offset);const length=bytesToNumber(cursor.readBytes(32));if(0===length)return cursor.setPosition(staticPosition+32),["0x",32];const data=cursor.readBytes(length);return cursor.setPosition(staticPosition+32),[bytesToHex(data),32]}return[bytesToHex(cursor.readBytes(parseInt(size),32)),32]}function decodeNumber(cursor,param){const signed=param.type.startsWith("int"),size=parseInt(param.type.split("int")[1]||"256"),value=cursor.readBytes(32);return[size>48?bytesToBigInt(value,{signed:signed}):bytesToNumber(value,{signed:signed}),32]}function decodeTuple(cursor,param,{staticPosition:staticPosition}){const hasUnnamedChild=0===param.components.length||param.components.some((({name:name})=>!name)),value=hasUnnamedChild?[]:{};let consumed=0;if(hasDynamicChild(param)){const start=staticPosition+bytesToNumber(cursor.readBytes(sizeOfOffset));for(let i=0;i<param.components.length;++i){const component=param.components[i];cursor.setPosition(start+consumed);const[data,consumed_]=decodeParameter(cursor,component,{staticPosition:start});consumed+=consumed_,value[hasUnnamedChild?i:component?.name]=data}return cursor.setPosition(staticPosition+32),[value,32]}for(let i=0;i<param.components.length;++i){const component=param.components[i],[data,consumed_]=decodeParameter(cursor,component,{staticPosition:staticPosition});value[hasUnnamedChild?i:component?.name]=data,consumed+=consumed_}return[value,consumed]}function decodeString(cursor,{staticPosition:staticPosition}){const start=staticPosition+bytesToNumber(cursor.readBytes(32));cursor.setPosition(start);const length=bytesToNumber(cursor.readBytes(32));if(0===length)return cursor.setPosition(staticPosition+32),["",32];const data=cursor.readBytes(length,32),value=bytesToString(trim(data));return cursor.setPosition(staticPosition+32),[value,32]}function hasDynamicChild(param){const{type:type}=param;if("string"===type)return!0;if("bytes"===type)return!0;if(type.endsWith("[]"))return!0;if("tuple"===type)return param.components?.some(hasDynamicChild);const arrayComponents=getArrayComponents(param.type);return!(!arrayComponents||!hasDynamicChild({...param,type:arrayComponents[1]}))}