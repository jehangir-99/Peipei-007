import{AbiEncodingArrayLengthMismatchError,AbiEncodingBytesSizeMismatchError,AbiEncodingLengthMismatchError,InvalidAbiEncodingTypeError,InvalidArrayError}from"../../errors/abi.js";import{InvalidAddressError}from"../../errors/address.js";import{BaseError}from"../../errors/base.js";import{isAddress}from"../address/isAddress.js";import{concat}from"../data/concat.js";import{padHex}from"../data/pad.js";import{size}from"../data/size.js";import{slice}from"../data/slice.js";import{boolToHex,numberToHex,stringToHex}from"../encoding/toHex.js";export function encodeAbiParameters(params,values){if(params.length!==values.length)throw new AbiEncodingLengthMismatchError({expectedLength:params.length,givenLength:values.length});const data=encodeParams(prepareParams({params:params,values:values}));return 0===data.length?"0x":data}function prepareParams({params:params,values:values}){const preparedParams=[];for(let i=0;i<params.length;i++)preparedParams.push(prepareParam({param:params[i],value:values[i]}));return preparedParams}function prepareParam({param:param,value:value}){const arrayComponents=getArrayComponents(param.type);if(arrayComponents){const[length,type]=arrayComponents;return encodeArray(value,{length:length,param:{...param,type:type}})}if("tuple"===param.type)return encodeTuple(value,{param:param});if("address"===param.type)return encodeAddress(value);if("bool"===param.type)return encodeBool(value);if(param.type.startsWith("uint")||param.type.startsWith("int")){return encodeNumber(value,{signed:param.type.startsWith("int")})}if(param.type.startsWith("bytes"))return encodeBytes(value,{param:param});if("string"===param.type)return encodeString(value);throw new InvalidAbiEncodingTypeError(param.type,{docsPath:"/docs/contract/encodeAbiParameters"})}function encodeParams(preparedParams){let staticSize=0;for(let i=0;i<preparedParams.length;i++){const{dynamic:dynamic,encoded:encoded}=preparedParams[i];staticSize+=dynamic?32:size(encoded)}const staticParams=[],dynamicParams=[];let dynamicSize=0;for(let i=0;i<preparedParams.length;i++){const{dynamic:dynamic,encoded:encoded}=preparedParams[i];dynamic?(staticParams.push(numberToHex(staticSize+dynamicSize,{size:32})),dynamicParams.push(encoded),dynamicSize+=size(encoded)):staticParams.push(encoded)}return concat([...staticParams,...dynamicParams])}function encodeAddress(value){if(!isAddress(value))throw new InvalidAddressError({address:value});return{dynamic:!1,encoded:padHex(value.toLowerCase())}}function encodeArray(value,{length:length,param:param}){const dynamic=null===length;if(!Array.isArray(value))throw new InvalidArrayError(value);if(!dynamic&&value.length!==length)throw new AbiEncodingArrayLengthMismatchError({expectedLength:length,givenLength:value.length,type:`${param.type}[${length}]`});let dynamicChild=!1;const preparedParams=[];for(let i=0;i<value.length;i++){const preparedParam=prepareParam({param:param,value:value[i]});preparedParam.dynamic&&(dynamicChild=!0),preparedParams.push(preparedParam)}if(dynamic||dynamicChild){const data=encodeParams(preparedParams);if(dynamic){const length=numberToHex(preparedParams.length,{size:32});return{dynamic:!0,encoded:preparedParams.length>0?concat([length,data]):length}}if(dynamicChild)return{dynamic:!0,encoded:data}}return{dynamic:!1,encoded:concat(preparedParams.map((({encoded:encoded})=>encoded)))}}function encodeBytes(value,{param:param}){const[,paramSize]=param.type.split("bytes"),bytesSize=size(value);if(!paramSize){let value_=value;return bytesSize%32!=0&&(value_=padHex(value_,{dir:"right",size:32*Math.ceil((value.length-2)/2/32)})),{dynamic:!0,encoded:concat([padHex(numberToHex(bytesSize,{size:32})),value_])}}if(bytesSize!==parseInt(paramSize))throw new AbiEncodingBytesSizeMismatchError({expectedSize:parseInt(paramSize),value:value});return{dynamic:!1,encoded:padHex(value,{dir:"right"})}}function encodeBool(value){if("boolean"!=typeof value)throw new BaseError(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:padHex(boolToHex(value))}}function encodeNumber(value,{signed:signed}){return{dynamic:!1,encoded:numberToHex(value,{size:32,signed:signed})}}function encodeString(value){const hexValue=stringToHex(value),partsLength=Math.ceil(size(hexValue)/32),parts=[];for(let i=0;i<partsLength;i++)parts.push(padHex(slice(hexValue,32*i,32*(i+1)),{dir:"right"}));return{dynamic:!0,encoded:concat([padHex(numberToHex(size(hexValue),{size:32})),...parts])}}function encodeTuple(value,{param:param}){let dynamic=!1;const preparedParams=[];for(let i=0;i<param.components.length;i++){const param_=param.components[i],preparedParam=prepareParam({param:param_,value:value[Array.isArray(value)?i:param_.name]});preparedParams.push(preparedParam),preparedParam.dynamic&&(dynamic=!0)}return{dynamic:dynamic,encoded:dynamic?encodeParams(preparedParams):concat(preparedParams.map((({encoded:encoded})=>encoded)))}}export function getArrayComponents(type){const matches=type.match(/^(.*)\[(\d+)?\]$/);return matches?[matches[2]?Number(matches[2]):null,matches[1]]:void 0}