import{InvalidLegacyVError}from"../../errors/transaction.js";import{blobsToCommitments}from"../blob/blobsToCommitments.js";import{blobsToProofs}from"../blob/blobsToProofs.js";import{commitmentsToVersionedHashes}from"../blob/commitmentsToVersionedHashes.js";import{toBlobSidecars}from"../blob/toBlobSidecars.js";import{concatHex}from"../data/concat.js";import{trim}from"../data/trim.js";import{bytesToHex,toHex}from"../encoding/toHex.js";import{toRlp}from"../encoding/toRlp.js";import{assertTransactionEIP1559,assertTransactionEIP2930,assertTransactionEIP4844,assertTransactionLegacy}from"./assertTransaction.js";import{getTransactionType}from"./getTransactionType.js";import{serializeAccessList}from"./serializeAccessList.js";export function serializeTransaction(transaction,signature){const type=getTransactionType(transaction);return"eip1559"===type?serializeTransactionEIP1559(transaction,signature):"eip2930"===type?serializeTransactionEIP2930(transaction,signature):"eip4844"===type?serializeTransactionEIP4844(transaction,signature):serializeTransactionLegacy(transaction,signature)}function serializeTransactionEIP4844(transaction,signature){const{chainId:chainId,gas:gas,nonce:nonce,to:to,value:value,maxFeePerBlobGas:maxFeePerBlobGas,maxFeePerGas:maxFeePerGas,maxPriorityFeePerGas:maxPriorityFeePerGas,accessList:accessList,data:data}=transaction;assertTransactionEIP4844(transaction);let blobVersionedHashes=transaction.blobVersionedHashes,sidecars=transaction.sidecars;if(transaction.blobs){const blobs="string"==typeof transaction.blobs[0]?transaction.blobs:transaction.blobs.map((x=>bytesToHex(x))),kzg=transaction.kzg,commitments=blobsToCommitments({blobs:blobs,kzg:kzg}),proofs=blobsToProofs({blobs:blobs,commitments:commitments,kzg:kzg});blobVersionedHashes=commitmentsToVersionedHashes({commitments:commitments}),!1!==sidecars&&(sidecars=toBlobSidecars({blobs:blobs,commitments:commitments,proofs:proofs}))}const serializedAccessList=serializeAccessList(accessList),serializedTransaction=[toHex(chainId),nonce?toHex(nonce):"0x",maxPriorityFeePerGas?toHex(maxPriorityFeePerGas):"0x",maxFeePerGas?toHex(maxFeePerGas):"0x",gas?toHex(gas):"0x",to??"0x",value?toHex(value):"0x",data??"0x",serializedAccessList,maxFeePerBlobGas?toHex(maxFeePerBlobGas):"0x",blobVersionedHashes??[],...toYParitySignatureArray(transaction,signature)],blobs=[],commitments=[],proofs=[];if(sidecars)for(let i=0;i<sidecars.length;i++){const{blob:blob,commitment:commitment,proof:proof}=sidecars[i];blobs.push(blob),commitments.push(commitment),proofs.push(proof)}return concatHex(["0x03",toRlp(sidecars?[serializedTransaction,blobs,commitments,proofs]:serializedTransaction)])}function serializeTransactionEIP1559(transaction,signature){const{chainId:chainId,gas:gas,nonce:nonce,to:to,value:value,maxFeePerGas:maxFeePerGas,maxPriorityFeePerGas:maxPriorityFeePerGas,accessList:accessList,data:data}=transaction;assertTransactionEIP1559(transaction);const serializedAccessList=serializeAccessList(accessList),serializedTransaction=[toHex(chainId),nonce?toHex(nonce):"0x",maxPriorityFeePerGas?toHex(maxPriorityFeePerGas):"0x",maxFeePerGas?toHex(maxFeePerGas):"0x",gas?toHex(gas):"0x",to??"0x",value?toHex(value):"0x",data??"0x",serializedAccessList,...toYParitySignatureArray(transaction,signature)];return concatHex(["0x02",toRlp(serializedTransaction)])}function serializeTransactionEIP2930(transaction,signature){const{chainId:chainId,gas:gas,data:data,nonce:nonce,to:to,value:value,accessList:accessList,gasPrice:gasPrice}=transaction;assertTransactionEIP2930(transaction);const serializedAccessList=serializeAccessList(accessList),serializedTransaction=[toHex(chainId),nonce?toHex(nonce):"0x",gasPrice?toHex(gasPrice):"0x",gas?toHex(gas):"0x",to??"0x",value?toHex(value):"0x",data??"0x",serializedAccessList,...toYParitySignatureArray(transaction,signature)];return concatHex(["0x01",toRlp(serializedTransaction)])}function serializeTransactionLegacy(transaction,signature){const{chainId:chainId=0,gas:gas,data:data,nonce:nonce,to:to,value:value,gasPrice:gasPrice}=transaction;assertTransactionLegacy(transaction);let serializedTransaction=[nonce?toHex(nonce):"0x",gasPrice?toHex(gasPrice):"0x",gas?toHex(gas):"0x",to??"0x",value?toHex(value):"0x",data??"0x"];if(signature){const v=(()=>{if(signature.v>=35n){return(signature.v-35n)/2n>0?signature.v:27n+(35n===signature.v?0n:1n)}if(chainId>0)return BigInt(2*chainId)+BigInt(35n+signature.v-27n);const v=27n+(27n===signature.v?0n:1n);if(signature.v!==v)throw new InvalidLegacyVError({v:signature.v});return v})();serializedTransaction=[...serializedTransaction,toHex(v),signature.r,signature.s]}else chainId>0&&(serializedTransaction=[...serializedTransaction,toHex(chainId),"0x","0x"]);return toRlp(serializedTransaction)}export function toYParitySignatureArray(transaction,signature){const{r:r,s:s,v:v,yParity:yParity}=signature??transaction;if(void 0===r)return[];if(void 0===s)return[];if(void 0===v&&void 0===yParity)return[];return["number"==typeof yParity?yParity?toHex(1):"0x":0n===v?"0x":1n===v?toHex(1):27n===v?"0x":toHex(1),trim(r),trim(s)]}