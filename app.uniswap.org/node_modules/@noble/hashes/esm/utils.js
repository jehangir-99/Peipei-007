/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
import{crypto}from"@noble/hashes/crypto";const u8a=a=>a instanceof Uint8Array;export const u8=arr=>new Uint8Array(arr.buffer,arr.byteOffset,arr.byteLength);export const u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4));export const createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);export const rotr=(word,shift)=>word<<32-shift|word>>>shift;export const isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0];if(!isLE)throw new Error("Non little-endian hardware is not supported");const hexes=Array.from({length:256},((_,i)=>i.toString(16).padStart(2,"0")));export function bytesToHex(bytes){if(!u8a(bytes))throw new Error("Uint8Array expected");let hex="";for(let i=0;i<bytes.length;i++)hex+=hexes[bytes[i]];return hex}export function hexToBytes(hex){if("string"!=typeof hex)throw new Error("hex string expected, got "+typeof hex);const len=hex.length;if(len%2)throw new Error("padded hex string expected, got unpadded hex of length "+len);const array=new Uint8Array(len/2);for(let i=0;i<array.length;i++){const j=2*i,hexByte=hex.slice(j,j+2),byte=Number.parseInt(hexByte,16);if(Number.isNaN(byte)||byte<0)throw new Error("Invalid byte sequence");array[i]=byte}return array}export const nextTick=async()=>{};export async function asyncLoop(iters,tick,cb){let ts=Date.now();for(let i=0;i<iters;i++){cb(i);const diff=Date.now()-ts;diff>=0&&diff<tick||(await nextTick(),ts+=diff)}}export function utf8ToBytes(str){if("string"!=typeof str)throw new Error("utf8ToBytes expected string, got "+typeof str);return new Uint8Array((new TextEncoder).encode(str))}export function toBytes(data){if("string"==typeof data&&(data=utf8ToBytes(data)),!u8a(data))throw new Error("expected Uint8Array, got "+typeof data);return data}export function concatBytes(...arrays){const r=new Uint8Array(arrays.reduce(((sum,a)=>sum+a.length),0));let pad=0;return arrays.forEach((a=>{if(!u8a(a))throw new Error("Uint8Array expected");r.set(a,pad),pad+=a.length})),r}export class Hash{clone(){return this._cloneInto()}}const toStr={}.toString;export function checkOpts(defaults,opts){if(void 0!==opts&&"[object Object]"!==toStr.call(opts))throw new Error("Options should be object or undefined");return Object.assign(defaults,opts)}export function wrapConstructor(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=()=>hashCons(),hashC}export function wrapConstructorWithOpts(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC}export function wrapXOFConstructorWithOpts(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC}export function randomBytes(bytesLength=32){if(crypto&&"function"==typeof crypto.getRandomValues)return crypto.getRandomValues(new Uint8Array(bytesLength));throw new Error("crypto.getRandomValues must be defined")}