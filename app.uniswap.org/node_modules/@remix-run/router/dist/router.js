/**
 * @remix-run/router v1.5.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends(){return _extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}var Action;!function(Action){Action.Pop="POP",Action.Push="PUSH",Action.Replace="REPLACE"}(Action||(Action={}));const PopStateEventType="popstate";function createMemoryHistory(options){void 0===options&&(options={});let entries,{initialEntries:initialEntries=["/"],initialIndex:initialIndex,v5Compat:v5Compat=!1}=options;entries=initialEntries.map(((entry,index)=>createMemoryLocation(entry,"string"==typeof entry?null:entry.state,0===index?"default":void 0)));let index=clampIndex(null==initialIndex?entries.length-1:initialIndex),action=Action.Pop,listener=null;function clampIndex(n){return Math.min(Math.max(n,0),entries.length-1)}function getCurrentLocation(){return entries[index]}function createMemoryLocation(to,state,key){void 0===state&&(state=null);let location=createLocation(entries?getCurrentLocation().pathname:"/",to,state,key);return warning("/"===location.pathname.charAt(0),"relative pathnames are not supported in memory history: "+JSON.stringify(to)),location}function createHref(to){return"string"==typeof to?to:createPath(to)}return{get index(){return index},get action(){return action},get location(){return getCurrentLocation()},createHref:createHref,createURL:to=>new URL(createHref(to),"http://localhost"),encodeLocation(to){let path="string"==typeof to?parsePath(to):to;return{pathname:path.pathname||"",search:path.search||"",hash:path.hash||""}},push(to,state){action=Action.Push;let nextLocation=createMemoryLocation(to,state);index+=1,entries.splice(index,entries.length,nextLocation),v5Compat&&listener&&listener({action:action,location:nextLocation,delta:1})},replace(to,state){action=Action.Replace;let nextLocation=createMemoryLocation(to,state);entries[index]=nextLocation,v5Compat&&listener&&listener({action:action,location:nextLocation,delta:0})},go(delta){action=Action.Pop;let nextIndex=clampIndex(index+delta),nextLocation=entries[nextIndex];index=nextIndex,listener&&listener({action:action,location:nextLocation,delta:delta})},listen:fn=>(listener=fn,()=>{listener=null})}}function createBrowserHistory(options){return void 0===options&&(options={}),getUrlBasedHistory((function(window,globalHistory){let{pathname:pathname,search:search,hash:hash}=window.location;return createLocation("",{pathname:pathname,search:search,hash:hash},globalHistory.state&&globalHistory.state.usr||null,globalHistory.state&&globalHistory.state.key||"default")}),(function(window,to){return"string"==typeof to?to:createPath(to)}),null,options)}function createHashHistory(options){return void 0===options&&(options={}),getUrlBasedHistory((function(window,globalHistory){let{pathname:pathname="/",search:search="",hash:hash=""}=parsePath(window.location.hash.substr(1));return createLocation("",{pathname:pathname,search:search,hash:hash},globalHistory.state&&globalHistory.state.usr||null,globalHistory.state&&globalHistory.state.key||"default")}),(function(window,to){let base=window.document.querySelector("base"),href="";if(base&&base.getAttribute("href")){let url=window.location.href,hashIndex=url.indexOf("#");href=-1===hashIndex?url:url.slice(0,hashIndex)}return href+"#"+("string"==typeof to?to:createPath(to))}),(function(location,to){warning("/"===location.pathname.charAt(0),"relative pathnames are not supported in hash history.push("+JSON.stringify(to)+")")}),options)}function invariant(value,message){if(!1===value||null==value)throw new Error(message)}function warning(cond,message){if(!cond){"undefined"!=typeof console&&console.warn(message);try{throw new Error(message)}catch(e){}}}function createKey(){return Math.random().toString(36).substr(2,8)}function getHistoryState(location,index){return{usr:location.state,key:location.key,idx:index}}function createLocation(current,to,state,key){return void 0===state&&(state=null),_extends({pathname:"string"==typeof current?current:current.pathname,search:"",hash:""},"string"==typeof to?parsePath(to):to,{state:state,key:to&&to.key||key||createKey()})}function createPath(_ref){let{pathname:pathname="/",search:search="",hash:hash=""}=_ref;return search&&"?"!==search&&(pathname+="?"===search.charAt(0)?search:"?"+search),hash&&"#"!==hash&&(pathname+="#"===hash.charAt(0)?hash:"#"+hash),pathname}function parsePath(path){let parsedPath={};if(path){let hashIndex=path.indexOf("#");hashIndex>=0&&(parsedPath.hash=path.substr(hashIndex),path=path.substr(0,hashIndex));let searchIndex=path.indexOf("?");searchIndex>=0&&(parsedPath.search=path.substr(searchIndex),path=path.substr(0,searchIndex)),path&&(parsedPath.pathname=path)}return parsedPath}function getUrlBasedHistory(getLocation,createHref,validateLocation,options){void 0===options&&(options={});let{window:window=document.defaultView,v5Compat:v5Compat=!1}=options,globalHistory=window.history,action=Action.Pop,listener=null,index=getIndex();function getIndex(){return(globalHistory.state||{idx:null}).idx}function handlePop(){action=Action.Pop;let nextIndex=getIndex(),delta=null==nextIndex?null:nextIndex-index;index=nextIndex,listener&&listener({action:action,location:history.location,delta:delta})}function createURL(to){let base="null"!==window.location.origin?window.location.origin:window.location.href,href="string"==typeof to?to:createPath(to);return invariant(base,"No window.location.(origin|href) available to create URL for href: "+href),new URL(href,base)}null==index&&(index=0,globalHistory.replaceState(_extends({},globalHistory.state,{idx:index}),""));let history={get action(){return action},get location(){return getLocation(window,globalHistory)},listen(fn){if(listener)throw new Error("A history only accepts one active listener");return window.addEventListener(PopStateEventType,handlePop),listener=fn,()=>{window.removeEventListener(PopStateEventType,handlePop),listener=null}},createHref:to=>createHref(window,to),createURL:createURL,encodeLocation(to){let url=createURL(to);return{pathname:url.pathname,search:url.search,hash:url.hash}},push:function(to,state){action=Action.Push;let location=createLocation(history.location,to,state);validateLocation&&validateLocation(location,to),index=getIndex()+1;let historyState=getHistoryState(location,index),url=history.createHref(location);try{globalHistory.pushState(historyState,"",url)}catch(error){window.location.assign(url)}v5Compat&&listener&&listener({action:action,location:history.location,delta:1})},replace:function(to,state){action=Action.Replace;let location=createLocation(history.location,to,state);validateLocation&&validateLocation(location,to),index=getIndex();let historyState=getHistoryState(location,index),url=history.createHref(location);globalHistory.replaceState(historyState,"",url),v5Compat&&listener&&listener({action:action,location:history.location,delta:0})},go:n=>globalHistory.go(n)};return history}var ResultType;!function(ResultType){ResultType.data="data",ResultType.deferred="deferred",ResultType.redirect="redirect",ResultType.error="error"}(ResultType||(ResultType={}));const immutableRouteKeys=new Set(["lazy","caseSensitive","path","id","index","children"]);function isIndexRoute(route){return!0===route.index}function convertRoutesToDataRoutes(routes,detectErrorBoundary,parentPath,manifest){return void 0===parentPath&&(parentPath=[]),void 0===manifest&&(manifest={}),routes.map(((route,index)=>{let treePath=[...parentPath,index],id="string"==typeof route.id?route.id:treePath.join("-");if(invariant(!0!==route.index||!route.children,"Cannot specify children on an index route"),invariant(!manifest[id],'Found a route id collision on id "'+id+"\".  Route id's must be globally unique within Data Router usages"),isIndexRoute(route)){let indexRoute=_extends({},route,{hasErrorBoundary:detectErrorBoundary(route),id:id});return manifest[id]=indexRoute,indexRoute}{let pathOrLayoutRoute=_extends({},route,{id:id,hasErrorBoundary:detectErrorBoundary(route),children:void 0});return manifest[id]=pathOrLayoutRoute,route.children&&(pathOrLayoutRoute.children=convertRoutesToDataRoutes(route.children,detectErrorBoundary,treePath,manifest)),pathOrLayoutRoute}}))}function matchRoutes(routes,locationArg,basename){void 0===basename&&(basename="/");let pathname=stripBasename(("string"==typeof locationArg?parsePath(locationArg):locationArg).pathname||"/",basename);if(null==pathname)return null;let branches=flattenRoutes(routes);rankRouteBranches(branches);let matches=null;for(let i=0;null==matches&&i<branches.length;++i)matches=matchRouteBranch(branches[i],safelyDecodeURI(pathname));return matches}function flattenRoutes(routes,branches,parentsMeta,parentPath){void 0===branches&&(branches=[]),void 0===parentsMeta&&(parentsMeta=[]),void 0===parentPath&&(parentPath="");let flattenRoute=(route,index,relativePath)=>{let meta={relativePath:void 0===relativePath?route.path||"":relativePath,caseSensitive:!0===route.caseSensitive,childrenIndex:index,route:route};meta.relativePath.startsWith("/")&&(invariant(meta.relativePath.startsWith(parentPath),'Absolute route path "'+meta.relativePath+'" nested under path "'+parentPath+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),meta.relativePath=meta.relativePath.slice(parentPath.length));let path=joinPaths([parentPath,meta.relativePath]),routesMeta=parentsMeta.concat(meta);route.children&&route.children.length>0&&(invariant(!0!==route.index,'Index routes must not have child routes. Please remove all child routes from route path "'+path+'".'),flattenRoutes(route.children,branches,routesMeta,path)),(null!=route.path||route.index)&&branches.push({path:path,score:computeScore(path,route.index),routesMeta:routesMeta})};return routes.forEach(((route,index)=>{var _route$path;if(""!==route.path&&null!=(_route$path=route.path)&&_route$path.includes("?"))for(let exploded of explodeOptionalSegments(route.path))flattenRoute(route,index,exploded);else flattenRoute(route,index)})),branches}function explodeOptionalSegments(path){let segments=path.split("/");if(0===segments.length)return[];let[first,...rest]=segments,isOptional=first.endsWith("?"),required=first.replace(/\?$/,"");if(0===rest.length)return isOptional?[required,""]:[required];let restExploded=explodeOptionalSegments(rest.join("/")),result=[];return result.push(...restExploded.map((subpath=>""===subpath?required:[required,subpath].join("/")))),isOptional&&result.push(...restExploded),result.map((exploded=>path.startsWith("/")&&""===exploded?"/":exploded))}function rankRouteBranches(branches){branches.sort(((a,b)=>a.score!==b.score?b.score-a.score:compareIndexes(a.routesMeta.map((meta=>meta.childrenIndex)),b.routesMeta.map((meta=>meta.childrenIndex)))))}const paramRe=/^:\w+$/,dynamicSegmentValue=3,indexRouteValue=2,emptySegmentValue=1,staticSegmentValue=10,splatPenalty=-2,isSplat=s=>"*"===s;function computeScore(path,index){let segments=path.split("/"),initialScore=segments.length;return segments.some(isSplat)&&(initialScore+=splatPenalty),index&&(initialScore+=indexRouteValue),segments.filter((s=>!isSplat(s))).reduce(((score,segment)=>score+(paramRe.test(segment)?dynamicSegmentValue:""===segment?emptySegmentValue:staticSegmentValue)),initialScore)}function compareIndexes(a,b){return a.length===b.length&&a.slice(0,-1).every(((n,i)=>n===b[i]))?a[a.length-1]-b[b.length-1]:0}function matchRouteBranch(branch,pathname){let{routesMeta:routesMeta}=branch,matchedParams={},matchedPathname="/",matches=[];for(let i=0;i<routesMeta.length;++i){let meta=routesMeta[i],end=i===routesMeta.length-1,remainingPathname="/"===matchedPathname?pathname:pathname.slice(matchedPathname.length)||"/",match=matchPath({path:meta.relativePath,caseSensitive:meta.caseSensitive,end:end},remainingPathname);if(!match)return null;Object.assign(matchedParams,match.params);let route=meta.route;matches.push({params:matchedParams,pathname:joinPaths([matchedPathname,match.pathname]),pathnameBase:normalizePathname(joinPaths([matchedPathname,match.pathnameBase])),route:route}),"/"!==match.pathnameBase&&(matchedPathname=joinPaths([matchedPathname,match.pathnameBase]))}return matches}function generatePath(originalPath,params){void 0===params&&(params={});let path=originalPath;path.endsWith("*")&&"*"!==path&&!path.endsWith("/*")&&(warning(!1,'Route path "'+path+'" will be treated as if it were "'+path.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+path.replace(/\*$/,"/*")+'".'),path=path.replace(/\*$/,"/*"));return(path.startsWith("/")?"/":"")+path.split(/\/+/).map(((segment,index,array)=>{if(index===array.length-1&&"*"===segment){return params["*"]}const keyMatch=segment.match(/^:(\w+)(\??)$/);if(keyMatch){const[,key,optional]=keyMatch;let param=params[key];return"?"===optional?null==param?"":param:(null==param&&invariant(!1,'Missing ":'+key+'" param'),param)}return segment.replace(/\?$/g,"")})).filter((segment=>!!segment)).join("/")}function matchPath(pattern,pathname){"string"==typeof pattern&&(pattern={path:pattern,caseSensitive:!1,end:!0});let[matcher,paramNames]=compilePath(pattern.path,pattern.caseSensitive,pattern.end),match=pathname.match(matcher);if(!match)return null;let matchedPathname=match[0],pathnameBase=matchedPathname.replace(/(.)\/+$/,"$1"),captureGroups=match.slice(1);return{params:paramNames.reduce(((memo,paramName,index)=>{if("*"===paramName){let splatValue=captureGroups[index]||"";pathnameBase=matchedPathname.slice(0,matchedPathname.length-splatValue.length).replace(/(.)\/+$/,"$1")}return memo[paramName]=safelyDecodeURIComponent(captureGroups[index]||"",paramName),memo}),{}),pathname:matchedPathname,pathnameBase:pathnameBase,pattern:pattern}}function compilePath(path,caseSensitive,end){void 0===caseSensitive&&(caseSensitive=!1),void 0===end&&(end=!0),warning("*"===path||!path.endsWith("*")||path.endsWith("/*"),'Route path "'+path+'" will be treated as if it were "'+path.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+path.replace(/\*$/,"/*")+'".');let paramNames=[],regexpSource="^"+path.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/\/:(\w+)/g,((_,paramName)=>(paramNames.push(paramName),"/([^\\/]+)")));return path.endsWith("*")?(paramNames.push("*"),regexpSource+="*"===path||"/*"===path?"(.*)$":"(?:\\/(.+)|\\/*)$"):end?regexpSource+="\\/*$":""!==path&&"/"!==path&&(regexpSource+="(?:(?=\\/|$))"),[new RegExp(regexpSource,caseSensitive?void 0:"i"),paramNames]}function safelyDecodeURI(value){try{return decodeURI(value)}catch(error){return warning(!1,'The URL path "'+value+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+error+")."),value}}function safelyDecodeURIComponent(value,paramName){try{return decodeURIComponent(value)}catch(error){return warning(!1,'The value for the URL param "'+paramName+'" will not be decoded because the string "'+value+'" is a malformed URL segment. This is probably due to a bad percent encoding ('+error+")."),value}}function stripBasename(pathname,basename){if("/"===basename)return pathname;if(!pathname.toLowerCase().startsWith(basename.toLowerCase()))return null;let startIndex=basename.endsWith("/")?basename.length-1:basename.length,nextChar=pathname.charAt(startIndex);return nextChar&&"/"!==nextChar?null:pathname.slice(startIndex)||"/"}function resolvePath(to,fromPathname){void 0===fromPathname&&(fromPathname="/");let{pathname:toPathname,search:search="",hash:hash=""}="string"==typeof to?parsePath(to):to;return{pathname:toPathname?toPathname.startsWith("/")?toPathname:resolvePathname(toPathname,fromPathname):fromPathname,search:normalizeSearch(search),hash:normalizeHash(hash)}}function resolvePathname(relativePath,fromPathname){let segments=fromPathname.replace(/\/+$/,"").split("/");return relativePath.split("/").forEach((segment=>{".."===segment?segments.length>1&&segments.pop():"."!==segment&&segments.push(segment)})),segments.length>1?segments.join("/"):"/"}function getInvalidPathError(char,field,dest,path){return"Cannot include a '"+char+"' character in a manually specified `to."+field+"` field ["+JSON.stringify(path)+"].  Please separate it out to the `to."+dest+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function getPathContributingMatches(matches){return matches.filter(((match,index)=>0===index||match.route.path&&match.route.path.length>0))}function resolveTo(toArg,routePathnames,locationPathname,isPathRelative){let to;void 0===isPathRelative&&(isPathRelative=!1),"string"==typeof toArg?to=parsePath(toArg):(to=_extends({},toArg),invariant(!to.pathname||!to.pathname.includes("?"),getInvalidPathError("?","pathname","search",to)),invariant(!to.pathname||!to.pathname.includes("#"),getInvalidPathError("#","pathname","hash",to)),invariant(!to.search||!to.search.includes("#"),getInvalidPathError("#","search","hash",to)));let from,isEmptyPath=""===toArg||""===to.pathname,toPathname=isEmptyPath?"/":to.pathname;if(isPathRelative||null==toPathname)from=locationPathname;else{let routePathnameIndex=routePathnames.length-1;if(toPathname.startsWith("..")){let toSegments=toPathname.split("/");for(;".."===toSegments[0];)toSegments.shift(),routePathnameIndex-=1;to.pathname=toSegments.join("/")}from=routePathnameIndex>=0?routePathnames[routePathnameIndex]:"/"}let path=resolvePath(to,from),hasExplicitTrailingSlash=toPathname&&"/"!==toPathname&&toPathname.endsWith("/"),hasCurrentTrailingSlash=(isEmptyPath||"."===toPathname)&&locationPathname.endsWith("/");return path.pathname.endsWith("/")||!hasExplicitTrailingSlash&&!hasCurrentTrailingSlash||(path.pathname+="/"),path}function getToPathname(to){return""===to||""===to.pathname?"/":"string"==typeof to?parsePath(to).pathname:to.pathname}const joinPaths=paths=>paths.join("/").replace(/\/\/+/g,"/"),normalizePathname=pathname=>pathname.replace(/\/+$/,"").replace(/^\/*/,"/"),normalizeSearch=search=>search&&"?"!==search?search.startsWith("?")?search:"?"+search:"",normalizeHash=hash=>hash&&"#"!==hash?hash.startsWith("#")?hash:"#"+hash:"",json=function(data,init){void 0===init&&(init={});let responseInit="number"==typeof init?{status:init}:init,headers=new Headers(responseInit.headers);return headers.has("Content-Type")||headers.set("Content-Type","application/json; charset=utf-8"),new Response(JSON.stringify(data),_extends({},responseInit,{headers:headers}))};class AbortedDeferredError extends Error{}class DeferredData{constructor(data,responseInit){let reject;this.pendingKeysSet=new Set,this.subscribers=new Set,this.deferredKeys=[],invariant(data&&"object"==typeof data&&!Array.isArray(data),"defer() only accepts plain objects"),this.abortPromise=new Promise(((_,r)=>reject=r)),this.controller=new AbortController;let onAbort=()=>reject(new AbortedDeferredError("Deferred data aborted"));this.unlistenAbortSignal=()=>this.controller.signal.removeEventListener("abort",onAbort),this.controller.signal.addEventListener("abort",onAbort),this.data=Object.entries(data).reduce(((acc,_ref)=>{let[key,value]=_ref;return Object.assign(acc,{[key]:this.trackPromise(key,value)})}),{}),this.done&&this.unlistenAbortSignal(),this.init=responseInit}trackPromise(key,value){if(!(value instanceof Promise))return value;this.deferredKeys.push(key),this.pendingKeysSet.add(key);let promise=Promise.race([value,this.abortPromise]).then((data=>this.onSettle(promise,key,null,data)),(error=>this.onSettle(promise,key,error)));return promise.catch((()=>{})),Object.defineProperty(promise,"_tracked",{get:()=>!0}),promise}onSettle(promise,key,error,data){return this.controller.signal.aborted&&error instanceof AbortedDeferredError?(this.unlistenAbortSignal(),Object.defineProperty(promise,"_error",{get:()=>error}),Promise.reject(error)):(this.pendingKeysSet.delete(key),this.done&&this.unlistenAbortSignal(),error?(Object.defineProperty(promise,"_error",{get:()=>error}),this.emit(!1,key),Promise.reject(error)):(Object.defineProperty(promise,"_data",{get:()=>data}),this.emit(!1,key),data))}emit(aborted,settledKey){this.subscribers.forEach((subscriber=>subscriber(aborted,settledKey)))}subscribe(fn){return this.subscribers.add(fn),()=>this.subscribers.delete(fn)}cancel(){this.controller.abort(),this.pendingKeysSet.forEach(((v,k)=>this.pendingKeysSet.delete(k))),this.emit(!0)}async resolveData(signal){let aborted=!1;if(!this.done){let onAbort=()=>this.cancel();signal.addEventListener("abort",onAbort),aborted=await new Promise((resolve=>{this.subscribe((aborted=>{signal.removeEventListener("abort",onAbort),(aborted||this.done)&&resolve(aborted)}))}))}return aborted}get done(){return 0===this.pendingKeysSet.size}get unwrappedData(){return invariant(null!==this.data&&this.done,"Can only unwrap data on initialized and settled deferreds"),Object.entries(this.data).reduce(((acc,_ref2)=>{let[key,value]=_ref2;return Object.assign(acc,{[key]:unwrapTrackedPromise(value)})}),{})}get pendingKeys(){return Array.from(this.pendingKeysSet)}}function isTrackedPromise(value){return value instanceof Promise&&!0===value._tracked}function unwrapTrackedPromise(value){if(!isTrackedPromise(value))return value;if(value._error)throw value._error;return value._data}const defer=function(data,init){return void 0===init&&(init={}),new DeferredData(data,"number"==typeof init?{status:init}:init)},redirect=function(url,init){void 0===init&&(init=302);let responseInit=init;"number"==typeof responseInit?responseInit={status:responseInit}:void 0===responseInit.status&&(responseInit.status=302);let headers=new Headers(responseInit.headers);return headers.set("Location",url),new Response(null,_extends({},responseInit,{headers:headers}))};class ErrorResponse{constructor(status,statusText,data,internal){void 0===internal&&(internal=!1),this.status=status,this.statusText=statusText||"",this.internal=internal,data instanceof Error?(this.data=data.toString(),this.error=data):this.data=data}}function isRouteErrorResponse(error){return null!=error&&"number"==typeof error.status&&"string"==typeof error.statusText&&"boolean"==typeof error.internal&&"data"in error}const validMutationMethodsArr=["post","put","patch","delete"],validMutationMethods=new Set(validMutationMethodsArr),validRequestMethodsArr=["get",...validMutationMethodsArr],validRequestMethods=new Set(validRequestMethodsArr),redirectStatusCodes=new Set([301,302,303,307,308]),redirectPreserveMethodStatusCodes=new Set([307,308]),IDLE_NAVIGATION={state:"idle",location:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0},IDLE_FETCHER={state:"idle",data:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0},IDLE_BLOCKER={state:"unblocked",proceed:void 0,reset:void 0,location:void 0},ABSOLUTE_URL_REGEX=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,isBrowser="undefined"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,isServer=!isBrowser,defaultDetectErrorBoundary=route=>Boolean(route.hasErrorBoundary);function createRouter(init){invariant(init.routes.length>0,"You must provide a non-empty routes array to createRouter");let inFlightDataRoutes,detectErrorBoundary=init.detectErrorBoundary||defaultDetectErrorBoundary,manifest={},dataRoutes=convertRoutesToDataRoutes(init.routes,detectErrorBoundary,void 0,manifest),future=_extends({v7_normalizeFormMethod:!1},init.future),unlistenHistory=null,subscribers=new Set,savedScrollPositions=null,getScrollRestorationKey=null,getScrollPosition=null,initialScrollRestored=null!=init.hydrationData,initialMatches=matchRoutes(dataRoutes,init.history.location,init.basename),initialErrors=null;if(null==initialMatches){let error=getInternalRouterError(404,{pathname:init.history.location.pathname}),{matches:matches,route:route}=getShortCircuitMatches(dataRoutes);initialMatches=matches,initialErrors={[route.id]:error}}let router,pendingNavigationController,initialized=!(initialMatches.some((m=>m.route.lazy))||initialMatches.some((m=>m.route.loader))&&null==init.hydrationData),state={historyAction:init.history.action,location:init.history.location,matches:initialMatches,initialized:initialized,navigation:IDLE_NAVIGATION,restoreScrollPosition:null==init.hydrationData&&null,preventScrollReset:!1,revalidation:"idle",loaderData:init.hydrationData&&init.hydrationData.loaderData||{},actionData:init.hydrationData&&init.hydrationData.actionData||null,errors:init.hydrationData&&init.hydrationData.errors||initialErrors,fetchers:new Map,blockers:new Map},pendingAction=Action.Pop,pendingPreventScrollReset=!1,isUninterruptedRevalidation=!1,isRevalidationRequired=!1,cancelledDeferredRoutes=[],cancelledFetcherLoads=[],fetchControllers=new Map,incrementingLoadId=0,pendingNavigationLoadId=-1,fetchReloadIds=new Map,fetchRedirectIds=new Set,fetchLoadMatches=new Map,activeDeferreds=new Map,blockerFunctions=new Map,ignoreNextHistoryUpdate=!1;function updateState(newState){state=_extends({},state,newState),subscribers.forEach((subscriber=>subscriber(state)))}function completeNavigation(location,newState){var _location$state,_location$state2;let actionData,isActionReload=null!=state.actionData&&null!=state.navigation.formMethod&&isMutationMethod(state.navigation.formMethod)&&"loading"===state.navigation.state&&!0!==(null==(_location$state=location.state)?void 0:_location$state._isRedirect);actionData=newState.actionData?Object.keys(newState.actionData).length>0?newState.actionData:null:isActionReload?state.actionData:null;let loaderData=newState.loaderData?mergeLoaderData(state.loaderData,newState.loaderData,newState.matches||[],newState.errors):state.loaderData;for(let[key]of blockerFunctions)deleteBlocker(key);let preventScrollReset=!0===pendingPreventScrollReset||null!=state.navigation.formMethod&&isMutationMethod(state.navigation.formMethod)&&!0!==(null==(_location$state2=location.state)?void 0:_location$state2._isRedirect);inFlightDataRoutes&&(dataRoutes=inFlightDataRoutes,inFlightDataRoutes=void 0),updateState(_extends({},newState,{actionData:actionData,loaderData:loaderData,historyAction:pendingAction,location:location,initialized:!0,navigation:IDLE_NAVIGATION,revalidation:"idle",restoreScrollPosition:getSavedScrollPosition(location,newState.matches||state.matches),preventScrollReset:preventScrollReset,blockers:new Map(state.blockers)})),isUninterruptedRevalidation||pendingAction===Action.Pop||(pendingAction===Action.Push?init.history.push(location,location.state):pendingAction===Action.Replace&&init.history.replace(location,location.state)),pendingAction=Action.Pop,pendingPreventScrollReset=!1,isUninterruptedRevalidation=!1,isRevalidationRequired=!1,cancelledDeferredRoutes=[],cancelledFetcherLoads=[]}async function startNavigation(historyAction,location,opts){pendingNavigationController&&pendingNavigationController.abort(),pendingNavigationController=null,pendingAction=historyAction,isUninterruptedRevalidation=!0===(opts&&opts.startUninterruptedRevalidation),function(location,matches){if(savedScrollPositions&&getScrollRestorationKey&&getScrollPosition){let userMatches=matches.map((m=>createUseMatchesMatch(m,state.loaderData))),key=getScrollRestorationKey(location,userMatches)||location.key;savedScrollPositions[key]=getScrollPosition()}}(state.location,state.matches),pendingPreventScrollReset=!0===(opts&&opts.preventScrollReset);let routesToUse=inFlightDataRoutes||dataRoutes,loadingNavigation=opts&&opts.overrideNavigation,matches=matchRoutes(routesToUse,location,init.basename);if(!matches){let error=getInternalRouterError(404,{pathname:location.pathname}),{matches:notFoundMatches,route:route}=getShortCircuitMatches(routesToUse);return cancelActiveDeferreds(),void completeNavigation(location,{matches:notFoundMatches,loaderData:{},errors:{[route.id]:error}})}if(isHashChangeOnly(state.location,location)&&!(opts&&opts.submission&&isMutationMethod(opts.submission.formMethod)))return void completeNavigation(location,{matches:matches});pendingNavigationController=new AbortController;let pendingActionData,pendingError,request=createClientSideRequest(init.history,location,pendingNavigationController.signal,opts&&opts.submission);if(opts&&opts.pendingError)pendingError={[findNearestBoundary(matches).route.id]:opts.pendingError};else if(opts&&opts.submission&&isMutationMethod(opts.submission.formMethod)){let actionOutput=await async function(request,location,submission,matches,opts){interruptActiveLoads();let result,navigation=_extends({state:"submitting",location:location},submission);updateState({navigation:navigation});let actionMatch=getTargetMatch(matches,location);if(actionMatch.route.action||actionMatch.route.lazy){if(result=await callLoaderOrAction("action",request,actionMatch,matches,manifest,detectErrorBoundary,router.basename),request.signal.aborted)return{shortCircuited:!0}}else result={type:ResultType.error,error:getInternalRouterError(405,{method:request.method,pathname:location.pathname,routeId:actionMatch.route.id})};if(isRedirectResult(result)){let replace;return replace=opts&&null!=opts.replace?opts.replace:result.location===state.location.pathname+state.location.search,await startRedirectNavigation(state,result,{submission:submission,replace:replace}),{shortCircuited:!0}}if(isErrorResult(result)){let boundaryMatch=findNearestBoundary(matches,actionMatch.route.id);return!0!==(opts&&opts.replace)&&(pendingAction=Action.Push),{pendingActionData:{},pendingActionError:{[boundaryMatch.route.id]:result.error}}}if(isDeferredResult(result))throw getInternalRouterError(400,{type:"defer-action"});return{pendingActionData:{[actionMatch.route.id]:result.data}}}(request,location,opts.submission,matches,{replace:opts.replace});if(actionOutput.shortCircuited)return;pendingActionData=actionOutput.pendingActionData,pendingError=actionOutput.pendingActionError,loadingNavigation=_extends({state:"loading",location:location},opts.submission),request=new Request(request.url,{signal:request.signal})}let{shortCircuited:shortCircuited,loaderData:loaderData,errors:errors}=await async function(request,location,matches,overrideNavigation,submission,fetcherSubmission,replace,pendingActionData,pendingError){let loadingNavigation=overrideNavigation;if(!loadingNavigation){loadingNavigation=_extends({state:"loading",location:location,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0},submission)}let activeSubmission=submission||fetcherSubmission?submission||fetcherSubmission:loadingNavigation.formMethod&&loadingNavigation.formAction&&loadingNavigation.formData&&loadingNavigation.formEncType?{formMethod:loadingNavigation.formMethod,formAction:loadingNavigation.formAction,formData:loadingNavigation.formData,formEncType:loadingNavigation.formEncType}:void 0,routesToUse=inFlightDataRoutes||dataRoutes,[matchesToLoad,revalidatingFetchers]=getMatchesToLoad(init.history,state,matches,activeSubmission,location,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,fetchLoadMatches,routesToUse,init.basename,pendingActionData,pendingError);if(cancelActiveDeferreds((routeId=>!(matches&&matches.some((m=>m.route.id===routeId)))||matchesToLoad&&matchesToLoad.some((m=>m.route.id===routeId)))),0===matchesToLoad.length&&0===revalidatingFetchers.length)return completeNavigation(location,_extends({matches:matches,loaderData:{},errors:pendingError||null},pendingActionData?{actionData:pendingActionData}:{})),{shortCircuited:!0};if(!isUninterruptedRevalidation){revalidatingFetchers.forEach((rf=>{let fetcher=state.fetchers.get(rf.key),revalidatingFetcher={state:"loading",data:fetcher&&fetcher.data,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0," _hasFetcherDoneAnything ":!0};state.fetchers.set(rf.key,revalidatingFetcher)}));let actionData=pendingActionData||state.actionData;updateState(_extends({navigation:loadingNavigation},actionData?0===Object.keys(actionData).length?{actionData:null}:{actionData:actionData}:{},revalidatingFetchers.length>0?{fetchers:new Map(state.fetchers)}:{}))}pendingNavigationLoadId=++incrementingLoadId,revalidatingFetchers.forEach((rf=>fetchControllers.set(rf.key,pendingNavigationController)));let{results:results,loaderResults:loaderResults,fetcherResults:fetcherResults}=await callLoadersAndMaybeResolveData(state.matches,matches,matchesToLoad,revalidatingFetchers,request);if(request.signal.aborted)return{shortCircuited:!0};revalidatingFetchers.forEach((rf=>fetchControllers.delete(rf.key)));let redirect=findRedirect(results);if(redirect)return await startRedirectNavigation(state,redirect,{replace:replace}),{shortCircuited:!0};let{loaderData:loaderData,errors:errors}=processLoaderData(state,matches,matchesToLoad,loaderResults,pendingError,revalidatingFetchers,fetcherResults,activeDeferreds);activeDeferreds.forEach(((deferredData,routeId)=>{deferredData.subscribe((aborted=>{(aborted||deferredData.done)&&activeDeferreds.delete(routeId)}))})),function(){let doneKeys=[];for(let key of fetchRedirectIds){let fetcher=state.fetchers.get(key);invariant(fetcher,"Expected fetcher: "+key),"loading"===fetcher.state&&(fetchRedirectIds.delete(key),doneKeys.push(key))}markFetchersDone(doneKeys)}();let didAbortFetchLoads=abortStaleFetchLoads(pendingNavigationLoadId);return _extends({loaderData:loaderData,errors:errors},didAbortFetchLoads||revalidatingFetchers.length>0?{fetchers:new Map(state.fetchers)}:{})}(request,location,matches,loadingNavigation,opts&&opts.submission,opts&&opts.fetcherSubmission,opts&&opts.replace,pendingActionData,pendingError);shortCircuited||(pendingNavigationController=null,completeNavigation(location,_extends({matches:matches},pendingActionData?{actionData:pendingActionData}:{},{loaderData:loaderData,errors:errors})))}function getFetcher(key){return state.fetchers.get(key)||IDLE_FETCHER}async function startRedirectNavigation(state,redirect,_temp){var _window;let{submission:submission,replace:replace,isFetchActionRedirect:isFetchActionRedirect}=void 0===_temp?{}:_temp;redirect.revalidate&&(isRevalidationRequired=!0);let redirectLocation=createLocation(state.location,redirect.location,_extends({_isRedirect:!0},isFetchActionRedirect?{_isFetchActionRedirect:!0}:{}));if(invariant(redirectLocation,"Expected a location on the redirect navigation"),ABSOLUTE_URL_REGEX.test(redirect.location)&&isBrowser&&void 0!==(null==(_window=window)?void 0:_window.location)){let url=init.history.createURL(redirect.location),isDifferentBasename=null==stripBasename(url.pathname,init.basename||"/");if(window.location.origin!==url.origin||isDifferentBasename)return void(replace?window.location.replace(redirect.location):window.location.assign(redirect.location))}pendingNavigationController=null;let redirectHistoryAction=!0===replace?Action.Replace:Action.Push,{formMethod:formMethod,formAction:formAction,formEncType:formEncType,formData:formData}=state.navigation;!submission&&formMethod&&formAction&&formData&&formEncType&&(submission={formMethod:formMethod,formAction:formAction,formEncType:formEncType,formData:formData}),redirectPreserveMethodStatusCodes.has(redirect.status)&&submission&&isMutationMethod(submission.formMethod)?await startNavigation(redirectHistoryAction,redirectLocation,{submission:_extends({},submission,{formAction:redirect.location}),preventScrollReset:pendingPreventScrollReset}):isFetchActionRedirect?await startNavigation(redirectHistoryAction,redirectLocation,{overrideNavigation:{state:"loading",location:redirectLocation,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0},fetcherSubmission:submission,preventScrollReset:pendingPreventScrollReset}):await startNavigation(redirectHistoryAction,redirectLocation,{overrideNavigation:{state:"loading",location:redirectLocation,formMethod:submission?submission.formMethod:void 0,formAction:submission?submission.formAction:void 0,formEncType:submission?submission.formEncType:void 0,formData:submission?submission.formData:void 0},preventScrollReset:pendingPreventScrollReset})}async function callLoadersAndMaybeResolveData(currentMatches,matches,matchesToLoad,fetchersToLoad,request){let results=await Promise.all([...matchesToLoad.map((match=>callLoaderOrAction("loader",request,match,matches,manifest,detectErrorBoundary,router.basename))),...fetchersToLoad.map((f=>{if(f.matches&&f.match)return callLoaderOrAction("loader",createClientSideRequest(init.history,f.path,request.signal),f.match,f.matches,manifest,detectErrorBoundary,router.basename);return{type:ResultType.error,error:getInternalRouterError(404,{pathname:f.path})}}))]),loaderResults=results.slice(0,matchesToLoad.length),fetcherResults=results.slice(matchesToLoad.length);return await Promise.all([resolveDeferredResults(currentMatches,matchesToLoad,loaderResults,request.signal,!1,state.loaderData),resolveDeferredResults(currentMatches,fetchersToLoad.map((f=>f.match)),fetcherResults,request.signal,!0)]),{results:results,loaderResults:loaderResults,fetcherResults:fetcherResults}}function interruptActiveLoads(){isRevalidationRequired=!0,cancelledDeferredRoutes.push(...cancelActiveDeferreds()),fetchLoadMatches.forEach(((_,key)=>{fetchControllers.has(key)&&(cancelledFetcherLoads.push(key),abortFetcher(key))}))}function setFetcherError(key,routeId,error){let boundaryMatch=findNearestBoundary(state.matches,routeId);deleteFetcher(key),updateState({errors:{[boundaryMatch.route.id]:error},fetchers:new Map(state.fetchers)})}function deleteFetcher(key){fetchControllers.has(key)&&abortFetcher(key),fetchLoadMatches.delete(key),fetchReloadIds.delete(key),fetchRedirectIds.delete(key),state.fetchers.delete(key)}function abortFetcher(key){let controller=fetchControllers.get(key);invariant(controller,"Expected fetch controller: "+key),controller.abort(),fetchControllers.delete(key)}function markFetchersDone(keys){for(let key of keys){let doneFetcher={state:"idle",data:getFetcher(key).data,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0," _hasFetcherDoneAnything ":!0};state.fetchers.set(key,doneFetcher)}}function abortStaleFetchLoads(landedId){let yeetedKeys=[];for(let[key,id]of fetchReloadIds)if(id<landedId){let fetcher=state.fetchers.get(key);invariant(fetcher,"Expected fetcher: "+key),"loading"===fetcher.state&&(abortFetcher(key),fetchReloadIds.delete(key),yeetedKeys.push(key))}return markFetchersDone(yeetedKeys),yeetedKeys.length>0}function deleteBlocker(key){state.blockers.delete(key),blockerFunctions.delete(key)}function updateBlocker(key,newBlocker){let blocker=state.blockers.get(key)||IDLE_BLOCKER;invariant("unblocked"===blocker.state&&"blocked"===newBlocker.state||"blocked"===blocker.state&&"blocked"===newBlocker.state||"blocked"===blocker.state&&"proceeding"===newBlocker.state||"blocked"===blocker.state&&"unblocked"===newBlocker.state||"proceeding"===blocker.state&&"unblocked"===newBlocker.state,"Invalid blocker state transition: "+blocker.state+" -> "+newBlocker.state),state.blockers.set(key,newBlocker),updateState({blockers:new Map(state.blockers)})}function shouldBlockNavigation(_ref2){let{currentLocation:currentLocation,nextLocation:nextLocation,historyAction:historyAction}=_ref2;if(0===blockerFunctions.size)return;blockerFunctions.size>1&&warning(!1,"A router only supports one blocker at a time");let entries=Array.from(blockerFunctions.entries()),[blockerKey,blockerFunction]=entries[entries.length-1],blocker=state.blockers.get(blockerKey);return blocker&&"proceeding"===blocker.state?void 0:blockerFunction({currentLocation:currentLocation,nextLocation:nextLocation,historyAction:historyAction})?blockerKey:void 0}function cancelActiveDeferreds(predicate){let cancelledRouteIds=[];return activeDeferreds.forEach(((dfd,routeId)=>{predicate&&!predicate(routeId)||(dfd.cancel(),cancelledRouteIds.push(routeId),activeDeferreds.delete(routeId))})),cancelledRouteIds}function getSavedScrollPosition(location,matches){if(savedScrollPositions&&getScrollRestorationKey&&getScrollPosition){let userMatches=matches.map((m=>createUseMatchesMatch(m,state.loaderData))),key=getScrollRestorationKey(location,userMatches)||location.key,y=savedScrollPositions[key];if("number"==typeof y)return y}return null}return router={get basename(){return init.basename},get state(){return state},get routes(){return dataRoutes},initialize:function(){return unlistenHistory=init.history.listen((_ref=>{let{action:historyAction,location:location,delta:delta}=_ref;if(ignoreNextHistoryUpdate)return void(ignoreNextHistoryUpdate=!1);warning(0===blockerFunctions.size||null!=delta,"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");let blockerKey=shouldBlockNavigation({currentLocation:state.location,nextLocation:location,historyAction:historyAction});return blockerKey&&null!=delta?(ignoreNextHistoryUpdate=!0,init.history.go(-1*delta),void updateBlocker(blockerKey,{state:"blocked",location:location,proceed(){updateBlocker(blockerKey,{state:"proceeding",proceed:void 0,reset:void 0,location:location}),init.history.go(delta)},reset(){deleteBlocker(blockerKey),updateState({blockers:new Map(router.state.blockers)})}})):startNavigation(historyAction,location)})),state.initialized||startNavigation(Action.Pop,state.location),router},subscribe:function(fn){return subscribers.add(fn),()=>subscribers.delete(fn)},enableScrollRestoration:function(positions,getPosition,getKey){if(savedScrollPositions=positions,getScrollPosition=getPosition,getScrollRestorationKey=getKey||(location=>location.key),!initialScrollRestored&&state.navigation===IDLE_NAVIGATION){initialScrollRestored=!0;let y=getSavedScrollPosition(state.location,state.matches);null!=y&&updateState({restoreScrollPosition:y})}return()=>{savedScrollPositions=null,getScrollPosition=null,getScrollRestorationKey=null}},navigate:async function navigate(to,opts){if("number"==typeof to)return void init.history.go(to);let{path:path,submission:submission,error:error}=normalizeNavigateOptions(to,future,opts),currentLocation=state.location,nextLocation=createLocation(state.location,path,opts&&opts.state);nextLocation=_extends({},nextLocation,init.history.encodeLocation(nextLocation));let userReplace=opts&&null!=opts.replace?opts.replace:void 0,historyAction=Action.Push;!0===userReplace?historyAction=Action.Replace:!1===userReplace||null!=submission&&isMutationMethod(submission.formMethod)&&submission.formAction===state.location.pathname+state.location.search&&(historyAction=Action.Replace);let preventScrollReset=opts&&"preventScrollReset"in opts?!0===opts.preventScrollReset:void 0,blockerKey=shouldBlockNavigation({currentLocation:currentLocation,nextLocation:nextLocation,historyAction:historyAction});if(!blockerKey)return await startNavigation(historyAction,nextLocation,{submission:submission,pendingError:error,preventScrollReset:preventScrollReset,replace:opts&&opts.replace});updateBlocker(blockerKey,{state:"blocked",location:nextLocation,proceed(){updateBlocker(blockerKey,{state:"proceeding",proceed:void 0,reset:void 0,location:nextLocation}),navigate(to,opts)},reset(){deleteBlocker(blockerKey),updateState({blockers:new Map(state.blockers)})}})},fetch:function(key,routeId,href,opts){if(isServer)throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");fetchControllers.has(key)&&abortFetcher(key);let matches=matchRoutes(inFlightDataRoutes||dataRoutes,href,init.basename);if(!matches)return void setFetcherError(key,routeId,getInternalRouterError(404,{pathname:href}));let{path:path,submission:submission}=normalizeNavigateOptions(href,future,opts,!0),match=getTargetMatch(matches,path);pendingPreventScrollReset=!0===(opts&&opts.preventScrollReset),submission&&isMutationMethod(submission.formMethod)?async function(key,routeId,path,match,requestMatches,submission){if(interruptActiveLoads(),fetchLoadMatches.delete(key),!match.route.action&&!match.route.lazy){let error=getInternalRouterError(405,{method:submission.formMethod,pathname:path,routeId:routeId});return void setFetcherError(key,routeId,error)}let existingFetcher=state.fetchers.get(key),fetcher=_extends({state:"submitting"},submission,{data:existingFetcher&&existingFetcher.data," _hasFetcherDoneAnything ":!0});state.fetchers.set(key,fetcher),updateState({fetchers:new Map(state.fetchers)});let abortController=new AbortController,fetchRequest=createClientSideRequest(init.history,path,abortController.signal,submission);fetchControllers.set(key,abortController);let actionResult=await callLoaderOrAction("action",fetchRequest,match,requestMatches,manifest,detectErrorBoundary,router.basename);if(fetchRequest.signal.aborted)return void(fetchControllers.get(key)===abortController&&fetchControllers.delete(key));if(isRedirectResult(actionResult)){fetchControllers.delete(key),fetchRedirectIds.add(key);let loadingFetcher=_extends({state:"loading"},submission,{data:void 0," _hasFetcherDoneAnything ":!0});return state.fetchers.set(key,loadingFetcher),updateState({fetchers:new Map(state.fetchers)}),startRedirectNavigation(state,actionResult,{submission:submission,isFetchActionRedirect:!0})}if(isErrorResult(actionResult))return void setFetcherError(key,routeId,actionResult.error);if(isDeferredResult(actionResult))throw getInternalRouterError(400,{type:"defer-action"});let nextLocation=state.navigation.location||state.location,revalidationRequest=createClientSideRequest(init.history,nextLocation,abortController.signal),routesToUse=inFlightDataRoutes||dataRoutes,matches="idle"!==state.navigation.state?matchRoutes(routesToUse,state.navigation.location,init.basename):state.matches;invariant(matches,"Didn't find any matches after fetcher action");let loadId=++incrementingLoadId;fetchReloadIds.set(key,loadId);let loadFetcher=_extends({state:"loading",data:actionResult.data},submission,{" _hasFetcherDoneAnything ":!0});state.fetchers.set(key,loadFetcher);let[matchesToLoad,revalidatingFetchers]=getMatchesToLoad(init.history,state,matches,submission,nextLocation,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,fetchLoadMatches,routesToUse,init.basename,{[match.route.id]:actionResult.data},void 0);revalidatingFetchers.filter((rf=>rf.key!==key)).forEach((rf=>{let staleKey=rf.key,existingFetcher=state.fetchers.get(staleKey),revalidatingFetcher={state:"loading",data:existingFetcher&&existingFetcher.data,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0," _hasFetcherDoneAnything ":!0};state.fetchers.set(staleKey,revalidatingFetcher),fetchControllers.set(staleKey,abortController)})),updateState({fetchers:new Map(state.fetchers)});let{results:results,loaderResults:loaderResults,fetcherResults:fetcherResults}=await callLoadersAndMaybeResolveData(state.matches,matches,matchesToLoad,revalidatingFetchers,revalidationRequest);if(abortController.signal.aborted)return;fetchReloadIds.delete(key),fetchControllers.delete(key),revalidatingFetchers.forEach((r=>fetchControllers.delete(r.key)));let redirect=findRedirect(results);if(redirect)return startRedirectNavigation(state,redirect);let{loaderData:loaderData,errors:errors}=processLoaderData(state,state.matches,matchesToLoad,loaderResults,void 0,revalidatingFetchers,fetcherResults,activeDeferreds),doneFetcher={state:"idle",data:actionResult.data,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0," _hasFetcherDoneAnything ":!0};state.fetchers.set(key,doneFetcher);let didAbortFetchLoads=abortStaleFetchLoads(loadId);"loading"===state.navigation.state&&loadId>pendingNavigationLoadId?(invariant(pendingAction,"Expected pending action"),pendingNavigationController&&pendingNavigationController.abort(),completeNavigation(state.navigation.location,{matches:matches,loaderData:loaderData,errors:errors,fetchers:new Map(state.fetchers)})):(updateState(_extends({errors:errors,loaderData:mergeLoaderData(state.loaderData,loaderData,matches,errors)},didAbortFetchLoads?{fetchers:new Map(state.fetchers)}:{})),isRevalidationRequired=!1)}(key,routeId,path,match,matches,submission):(fetchLoadMatches.set(key,{routeId:routeId,path:path}),async function(key,routeId,path,match,matches,submission){let existingFetcher=state.fetchers.get(key),loadingFetcher=_extends({state:"loading",formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0},submission,{data:existingFetcher&&existingFetcher.data," _hasFetcherDoneAnything ":!0});state.fetchers.set(key,loadingFetcher),updateState({fetchers:new Map(state.fetchers)});let abortController=new AbortController,fetchRequest=createClientSideRequest(init.history,path,abortController.signal);fetchControllers.set(key,abortController);let result=await callLoaderOrAction("loader",fetchRequest,match,matches,manifest,detectErrorBoundary,router.basename);isDeferredResult(result)&&(result=await resolveDeferredData(result,fetchRequest.signal,!0)||result);fetchControllers.get(key)===abortController&&fetchControllers.delete(key);if(fetchRequest.signal.aborted)return;if(isRedirectResult(result))return void await startRedirectNavigation(state,result);if(isErrorResult(result)){let boundaryMatch=findNearestBoundary(state.matches,routeId);return state.fetchers.delete(key),void updateState({fetchers:new Map(state.fetchers),errors:{[boundaryMatch.route.id]:result.error}})}invariant(!isDeferredResult(result),"Unhandled fetcher deferred data");let doneFetcher={state:"idle",data:result.data,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0," _hasFetcherDoneAnything ":!0};state.fetchers.set(key,doneFetcher),updateState({fetchers:new Map(state.fetchers)})}(key,routeId,path,match,matches,submission))},revalidate:function(){interruptActiveLoads(),updateState({revalidation:"loading"}),"submitting"!==state.navigation.state&&("idle"!==state.navigation.state?startNavigation(pendingAction||state.historyAction,state.navigation.location,{overrideNavigation:state.navigation}):startNavigation(state.historyAction,state.location,{startUninterruptedRevalidation:!0}))},createHref:to=>init.history.createHref(to),encodeLocation:to=>init.history.encodeLocation(to),getFetcher:getFetcher,deleteFetcher:deleteFetcher,dispose:function(){unlistenHistory&&unlistenHistory(),subscribers.clear(),pendingNavigationController&&pendingNavigationController.abort(),state.fetchers.forEach(((_,key)=>deleteFetcher(key))),state.blockers.forEach(((_,key)=>deleteBlocker(key)))},getBlocker:function(key,fn){let blocker=state.blockers.get(key)||IDLE_BLOCKER;return blockerFunctions.get(key)!==fn&&blockerFunctions.set(key,fn),blocker},deleteBlocker:deleteBlocker,_internalFetchControllers:fetchControllers,_internalActiveDeferreds:activeDeferreds,_internalSetRoutes:function(newRoutes){inFlightDataRoutes=newRoutes}},router}const UNSAFE_DEFERRED_SYMBOL=Symbol("deferred");function createStaticHandler(routes,opts){invariant(routes.length>0,"You must provide a non-empty routes array to createStaticHandler");let manifest={},detectErrorBoundary=(null==opts?void 0:opts.detectErrorBoundary)||defaultDetectErrorBoundary,dataRoutes=convertRoutesToDataRoutes(routes,detectErrorBoundary,void 0,manifest),basename=(opts?opts.basename:null)||"/";async function queryImpl(request,location,matches,requestContext,routeMatch){invariant(request.signal,"query()/queryRoute() requests must contain an AbortController signal");try{if(isMutationMethod(request.method.toLowerCase())){let result=await async function(request,matches,actionMatch,requestContext,isRouteRequest){let result;if(actionMatch.route.action||actionMatch.route.lazy){if(result=await callLoaderOrAction("action",request,actionMatch,matches,manifest,detectErrorBoundary,basename,!0,isRouteRequest,requestContext),request.signal.aborted){throw new Error((isRouteRequest?"queryRoute":"query")+"() call aborted")}}else{let error=getInternalRouterError(405,{method:request.method,pathname:new URL(request.url).pathname,routeId:actionMatch.route.id});if(isRouteRequest)throw error;result={type:ResultType.error,error:error}}if(isRedirectResult(result))throw new Response(null,{status:result.status,headers:{Location:result.location}});if(isDeferredResult(result)){let error=getInternalRouterError(400,{type:"defer-action"});if(isRouteRequest)throw error;result={type:ResultType.error,error:error}}if(isRouteRequest){if(isErrorResult(result))throw result.error;return{matches:[actionMatch],loaderData:{},actionData:{[actionMatch.route.id]:result.data},errors:null,statusCode:200,loaderHeaders:{},actionHeaders:{},activeDeferreds:null}}if(isErrorResult(result)){let boundaryMatch=findNearestBoundary(matches,actionMatch.route.id);return _extends({},await loadRouteData(request,matches,requestContext,void 0,{[boundaryMatch.route.id]:result.error}),{statusCode:isRouteErrorResponse(result.error)?result.error.status:500,actionData:null,actionHeaders:_extends({},result.headers?{[actionMatch.route.id]:result.headers}:{})})}let loaderRequest=new Request(request.url,{headers:request.headers,redirect:request.redirect,signal:request.signal}),context=await loadRouteData(loaderRequest,matches,requestContext);return _extends({},context,result.statusCode?{statusCode:result.statusCode}:{},{actionData:{[actionMatch.route.id]:result.data},actionHeaders:_extends({},result.headers?{[actionMatch.route.id]:result.headers}:{})})}(request,matches,routeMatch||getTargetMatch(matches,location),requestContext,null!=routeMatch);return result}let result=await loadRouteData(request,matches,requestContext,routeMatch);return isResponse(result)?result:_extends({},result,{actionData:null,actionHeaders:{}})}catch(e){if(isQueryRouteResponse(e)){if(e.type===ResultType.error&&!isRedirectResponse(e.response))throw e.response;return e.response}if(isRedirectResponse(e))return e;throw e}}async function loadRouteData(request,matches,requestContext,routeMatch,pendingActionError){let isRouteRequest=null!=routeMatch;if(isRouteRequest&&(null==routeMatch||!routeMatch.route.loader)&&(null==routeMatch||!routeMatch.route.lazy))throw getInternalRouterError(400,{method:request.method,pathname:new URL(request.url).pathname,routeId:null==routeMatch?void 0:routeMatch.route.id});let matchesToLoad=(routeMatch?[routeMatch]:getLoaderMatchesUntilBoundary(matches,Object.keys(pendingActionError||{})[0])).filter((m=>m.route.loader||m.route.lazy));if(0===matchesToLoad.length)return{matches:matches,loaderData:matches.reduce(((acc,m)=>Object.assign(acc,{[m.route.id]:null})),{}),errors:pendingActionError||null,statusCode:200,loaderHeaders:{},activeDeferreds:null};let results=await Promise.all([...matchesToLoad.map((match=>callLoaderOrAction("loader",request,match,matches,manifest,detectErrorBoundary,basename,!0,isRouteRequest,requestContext)))]);if(request.signal.aborted){throw new Error((isRouteRequest?"queryRoute":"query")+"() call aborted")}let activeDeferreds=new Map,context=processRouteLoaderData(matches,matchesToLoad,results,pendingActionError,activeDeferreds),executedLoaders=new Set(matchesToLoad.map((match=>match.route.id)));return matches.forEach((match=>{executedLoaders.has(match.route.id)||(context.loaderData[match.route.id]=null)})),_extends({},context,{matches:matches,activeDeferreds:activeDeferreds.size>0?Object.fromEntries(activeDeferreds.entries()):null})}return{dataRoutes:dataRoutes,query:async function(request,_temp2){let{requestContext:requestContext}=void 0===_temp2?{}:_temp2,url=new URL(request.url),method=request.method,location=createLocation("",createPath(url),null,"default"),matches=matchRoutes(dataRoutes,location,basename);if(!isValidMethod(method)&&"HEAD"!==method){let error=getInternalRouterError(405,{method:method}),{matches:methodNotAllowedMatches,route:route}=getShortCircuitMatches(dataRoutes);return{basename:basename,location:location,matches:methodNotAllowedMatches,loaderData:{},actionData:null,errors:{[route.id]:error},statusCode:error.status,loaderHeaders:{},actionHeaders:{},activeDeferreds:null}}if(!matches){let error=getInternalRouterError(404,{pathname:location.pathname}),{matches:notFoundMatches,route:route}=getShortCircuitMatches(dataRoutes);return{basename:basename,location:location,matches:notFoundMatches,loaderData:{},actionData:null,errors:{[route.id]:error},statusCode:error.status,loaderHeaders:{},actionHeaders:{},activeDeferreds:null}}let result=await queryImpl(request,location,matches,requestContext);return isResponse(result)?result:_extends({location:location,basename:basename},result)},queryRoute:async function(request,_temp3){let{routeId:routeId,requestContext:requestContext}=void 0===_temp3?{}:_temp3,url=new URL(request.url),method=request.method,location=createLocation("",createPath(url),null,"default"),matches=matchRoutes(dataRoutes,location,basename);if(!isValidMethod(method)&&"HEAD"!==method&&"OPTIONS"!==method)throw getInternalRouterError(405,{method:method});if(!matches)throw getInternalRouterError(404,{pathname:location.pathname});let match=routeId?matches.find((m=>m.route.id===routeId)):getTargetMatch(matches,location);if(routeId&&!match)throw getInternalRouterError(403,{pathname:location.pathname,routeId:routeId});if(!match)throw getInternalRouterError(404,{pathname:location.pathname});let result=await queryImpl(request,location,matches,requestContext,match);if(isResponse(result))return result;let error=result.errors?Object.values(result.errors)[0]:void 0;if(void 0!==error)throw error;if(result.actionData)return Object.values(result.actionData)[0];if(result.loaderData){var _result$activeDeferre;let data=Object.values(result.loaderData)[0];return null!=(_result$activeDeferre=result.activeDeferreds)&&_result$activeDeferre[match.route.id]&&(data[UNSAFE_DEFERRED_SYMBOL]=result.activeDeferreds[match.route.id]),data}}}}function getStaticContextFromError(routes,context,error){return _extends({},context,{statusCode:500,errors:{[context._deepestRenderedBoundaryId||routes[0].id]:error}})}function isSubmissionNavigation(opts){return null!=opts&&"formData"in opts}function normalizeNavigateOptions(to,future,opts,isFetcher){void 0===isFetcher&&(isFetcher=!1);let submission,path="string"==typeof to?to:createPath(to);if(!opts||!isSubmissionNavigation(opts))return{path:path};if(opts.formMethod&&!isValidMethod(opts.formMethod))return{path:path,error:getInternalRouterError(405,{method:opts.formMethod})};if(opts.formData){let formMethod=opts.formMethod||"get";if(submission={formMethod:future.v7_normalizeFormMethod?formMethod.toUpperCase():formMethod.toLowerCase(),formAction:stripHashFromPath(path),formEncType:opts&&opts.formEncType||"application/x-www-form-urlencoded",formData:opts.formData},isMutationMethod(submission.formMethod))return{path:path,submission:submission}}let parsedPath=parsePath(path),searchParams=convertFormDataToSearchParams(opts.formData);return isFetcher&&parsedPath.search&&hasNakedIndexQuery(parsedPath.search)&&searchParams.append("index",""),parsedPath.search="?"+searchParams,{path:createPath(parsedPath),submission:submission}}function getLoaderMatchesUntilBoundary(matches,boundaryId){let boundaryMatches=matches;if(boundaryId){let index=matches.findIndex((m=>m.route.id===boundaryId));index>=0&&(boundaryMatches=matches.slice(0,index))}return boundaryMatches}function getMatchesToLoad(history,state,matches,submission,location,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,fetchLoadMatches,routesToUse,basename,pendingActionData,pendingError){let actionResult=pendingError?Object.values(pendingError)[0]:pendingActionData?Object.values(pendingActionData)[0]:void 0,currentUrl=history.createURL(state.location),nextUrl=history.createURL(location),defaultShouldRevalidate=isRevalidationRequired||currentUrl.toString()===nextUrl.toString()||currentUrl.search!==nextUrl.search,boundaryId=pendingError?Object.keys(pendingError)[0]:void 0,navigationMatches=getLoaderMatchesUntilBoundary(matches,boundaryId).filter(((match,index)=>{if(match.route.lazy)return!0;if(null==match.route.loader)return!1;if(isNewLoader(state.loaderData,state.matches[index],match)||cancelledDeferredRoutes.some((id=>id===match.route.id)))return!0;let currentRouteMatch=state.matches[index],nextRouteMatch=match;return shouldRevalidateLoader(match,_extends({currentUrl:currentUrl,currentParams:currentRouteMatch.params,nextUrl:nextUrl,nextParams:nextRouteMatch.params},submission,{actionResult:actionResult,defaultShouldRevalidate:defaultShouldRevalidate||isNewRouteInstance(currentRouteMatch,nextRouteMatch)}))})),revalidatingFetchers=[];return fetchLoadMatches.forEach(((f,key)=>{if(!matches.some((m=>m.route.id===f.routeId)))return;let fetcherMatches=matchRoutes(routesToUse,f.path,basename);if(!fetcherMatches)return void revalidatingFetchers.push(_extends({key:key},f,{matches:null,match:null}));let fetcherMatch=getTargetMatch(fetcherMatches,f.path);(cancelledFetcherLoads.includes(key)||shouldRevalidateLoader(fetcherMatch,_extends({currentUrl:currentUrl,currentParams:state.matches[state.matches.length-1].params,nextUrl:nextUrl,nextParams:matches[matches.length-1].params},submission,{actionResult:actionResult,defaultShouldRevalidate:defaultShouldRevalidate})))&&revalidatingFetchers.push(_extends({key:key,matches:fetcherMatches,match:fetcherMatch},f))})),[navigationMatches,revalidatingFetchers]}function isNewLoader(currentLoaderData,currentMatch,match){let isNew=!currentMatch||match.route.id!==currentMatch.route.id,isMissingData=void 0===currentLoaderData[match.route.id];return isNew||isMissingData}function isNewRouteInstance(currentMatch,match){let currentPath=currentMatch.route.path;return currentMatch.pathname!==match.pathname||null!=currentPath&&currentPath.endsWith("*")&&currentMatch.params["*"]!==match.params["*"]}function shouldRevalidateLoader(loaderMatch,arg){if(loaderMatch.route.shouldRevalidate){let routeChoice=loaderMatch.route.shouldRevalidate(arg);if("boolean"==typeof routeChoice)return routeChoice}return arg.defaultShouldRevalidate}async function loadLazyRouteModule(route,detectErrorBoundary,manifest){if(!route.lazy)return;let lazyRoute=await route.lazy();if(!route.lazy)return;let routeToUpdate=manifest[route.id];invariant(routeToUpdate,"No route found in manifest");let routeUpdates={};for(let lazyRouteProperty in lazyRoute){let isPropertyStaticallyDefined=void 0!==routeToUpdate[lazyRouteProperty]&&"hasErrorBoundary"!==lazyRouteProperty;warning(!isPropertyStaticallyDefined,'Route "'+routeToUpdate.id+'" has a static property "'+lazyRouteProperty+'" defined but its lazy function is also returning a value for this property. The lazy route property "'+lazyRouteProperty+'" will be ignored.'),isPropertyStaticallyDefined||immutableRouteKeys.has(lazyRouteProperty)||(routeUpdates[lazyRouteProperty]=lazyRoute[lazyRouteProperty])}Object.assign(routeToUpdate,routeUpdates),Object.assign(routeToUpdate,{hasErrorBoundary:detectErrorBoundary(_extends({},routeToUpdate)),lazy:void 0})}async function callLoaderOrAction(type,request,match,matches,manifest,detectErrorBoundary,basename,isStaticRequest,isRouteRequest,requestContext){let resultType,result,onReject;void 0===basename&&(basename="/"),void 0===isStaticRequest&&(isStaticRequest=!1),void 0===isRouteRequest&&(isRouteRequest=!1);let runHandler=handler=>{let reject,abortPromise=new Promise(((_,r)=>reject=r));return onReject=()=>reject(),request.signal.addEventListener("abort",onReject),Promise.race([handler({request:request,params:match.params,context:requestContext}),abortPromise])};try{let handler=match.route[type];if(match.route.lazy)if(handler){result=(await Promise.all([runHandler(handler),loadLazyRouteModule(match.route,detectErrorBoundary,manifest)]))[0]}else{if(await loadLazyRouteModule(match.route,detectErrorBoundary,manifest),handler=match.route[type],!handler){if("action"===type)throw getInternalRouterError(405,{method:request.method,pathname:new URL(request.url).pathname,routeId:match.route.id});return{type:ResultType.data,data:void 0}}result=await runHandler(handler)}else invariant(handler,"Could not find the "+type+' to run on the "'+match.route.id+'" route'),result=await runHandler(handler);invariant(void 0!==result,"You defined "+("action"===type?"an action":"a loader")+' for route "'+match.route.id+"\" but didn't return anything from your `"+type+"` function. Please return a value or `null`.")}catch(e){resultType=ResultType.error,result=e}finally{onReject&&request.signal.removeEventListener("abort",onReject)}if(isResponse(result)){let data,status=result.status;if(redirectStatusCodes.has(status)){let location=result.headers.get("Location");if(invariant(location,"Redirects returned/thrown from loaders/actions must have a Location header"),ABSOLUTE_URL_REGEX.test(location)){if(!isStaticRequest){let currentUrl=new URL(request.url),url=location.startsWith("//")?new URL(currentUrl.protocol+location):new URL(location),isSameBasename=null!=stripBasename(url.pathname,basename);url.origin===currentUrl.origin&&isSameBasename&&(location=url.pathname+url.search+url.hash)}}else{let resolvedLocation=resolveTo(location,getPathContributingMatches(matches.slice(0,matches.indexOf(match)+1)).map((match=>match.pathnameBase)),new URL(request.url).pathname);if(invariant(createPath(resolvedLocation),"Unable to resolve redirect location: "+location),basename){let path=resolvedLocation.pathname;resolvedLocation.pathname="/"===path?basename:joinPaths([basename,path])}location=createPath(resolvedLocation)}if(isStaticRequest)throw result.headers.set("Location",location),result;return{type:ResultType.redirect,status:status,location:location,revalidate:null!==result.headers.get("X-Remix-Revalidate")}}if(isRouteRequest)throw{type:resultType||ResultType.data,response:result};let contentType=result.headers.get("Content-Type");return data=contentType&&/\bapplication\/json\b/.test(contentType)?await result.json():await result.text(),resultType===ResultType.error?{type:resultType,error:new ErrorResponse(status,result.statusText,data),headers:result.headers}:{type:ResultType.data,data:data,statusCode:result.status,headers:result.headers}}return resultType===ResultType.error?{type:resultType,error:result}:isDeferredData(result)?{type:ResultType.deferred,deferredData:result,statusCode:null==(_result$init=result.init)?void 0:_result$init.status,headers:(null==(_result$init2=result.init)?void 0:_result$init2.headers)&&new Headers(result.init.headers)}:{type:ResultType.data,data:result};var _result$init,_result$init2}function createClientSideRequest(history,location,signal,submission){let url=history.createURL(stripHashFromPath(location)).toString(),init={signal:signal};if(submission&&isMutationMethod(submission.formMethod)){let{formMethod:formMethod,formEncType:formEncType,formData:formData}=submission;init.method=formMethod.toUpperCase(),init.body="application/x-www-form-urlencoded"===formEncType?convertFormDataToSearchParams(formData):formData}return new Request(url,init)}function convertFormDataToSearchParams(formData){let searchParams=new URLSearchParams;for(let[key,value]of formData.entries())searchParams.append(key,value instanceof File?value.name:value);return searchParams}function processRouteLoaderData(matches,matchesToLoad,results,pendingError,activeDeferreds){let statusCode,loaderData={},errors=null,foundError=!1,loaderHeaders={};return results.forEach(((result,index)=>{let id=matchesToLoad[index].route.id;if(invariant(!isRedirectResult(result),"Cannot handle redirect results in processLoaderData"),isErrorResult(result)){let boundaryMatch=findNearestBoundary(matches,id),error=result.error;pendingError&&(error=Object.values(pendingError)[0],pendingError=void 0),errors=errors||{},null==errors[boundaryMatch.route.id]&&(errors[boundaryMatch.route.id]=error),loaderData[id]=void 0,foundError||(foundError=!0,statusCode=isRouteErrorResponse(result.error)?result.error.status:500),result.headers&&(loaderHeaders[id]=result.headers)}else isDeferredResult(result)?(activeDeferreds.set(id,result.deferredData),loaderData[id]=result.deferredData.data):loaderData[id]=result.data,null==result.statusCode||200===result.statusCode||foundError||(statusCode=result.statusCode),result.headers&&(loaderHeaders[id]=result.headers)})),pendingError&&(errors=pendingError,loaderData[Object.keys(pendingError)[0]]=void 0),{loaderData:loaderData,errors:errors,statusCode:statusCode||200,loaderHeaders:loaderHeaders}}function processLoaderData(state,matches,matchesToLoad,results,pendingError,revalidatingFetchers,fetcherResults,activeDeferreds){let{loaderData:loaderData,errors:errors}=processRouteLoaderData(matches,matchesToLoad,results,pendingError,activeDeferreds);for(let index=0;index<revalidatingFetchers.length;index++){let{key:key,match:match}=revalidatingFetchers[index];invariant(void 0!==fetcherResults&&void 0!==fetcherResults[index],"Did not find corresponding fetcher result");let result=fetcherResults[index];if(isErrorResult(result)){let boundaryMatch=findNearestBoundary(state.matches,null==match?void 0:match.route.id);errors&&errors[boundaryMatch.route.id]||(errors=_extends({},errors,{[boundaryMatch.route.id]:result.error})),state.fetchers.delete(key)}else if(isRedirectResult(result))invariant(!1,"Unhandled fetcher revalidation redirect");else if(isDeferredResult(result))invariant(!1,"Unhandled fetcher deferred data");else{let doneFetcher={state:"idle",data:result.data,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0," _hasFetcherDoneAnything ":!0};state.fetchers.set(key,doneFetcher)}}return{loaderData:loaderData,errors:errors}}function mergeLoaderData(loaderData,newLoaderData,matches,errors){let mergedLoaderData=_extends({},newLoaderData);for(let match of matches){let id=match.route.id;if(newLoaderData.hasOwnProperty(id)?void 0!==newLoaderData[id]&&(mergedLoaderData[id]=newLoaderData[id]):void 0!==loaderData[id]&&match.route.loader&&(mergedLoaderData[id]=loaderData[id]),errors&&errors.hasOwnProperty(id))break}return mergedLoaderData}function findNearestBoundary(matches,routeId){return(routeId?matches.slice(0,matches.findIndex((m=>m.route.id===routeId))+1):[...matches]).reverse().find((m=>!0===m.route.hasErrorBoundary))||matches[0]}function getShortCircuitMatches(routes){let route=routes.find((r=>r.index||!r.path||"/"===r.path))||{id:"__shim-error-route__"};return{matches:[{params:{},pathname:"",pathnameBase:"",route:route}],route:route}}function getInternalRouterError(status,_temp4){let{pathname:pathname,routeId:routeId,method:method,type:type}=void 0===_temp4?{}:_temp4,statusText="Unknown Server Error",errorMessage="Unknown @remix-run/router error";return 400===status?(statusText="Bad Request",method&&pathname&&routeId?errorMessage="You made a "+method+' request to "'+pathname+'" but did not provide a `loader` for route "'+routeId+'", so there is no way to handle the request.':"defer-action"===type&&(errorMessage="defer() is not supported in actions")):403===status?(statusText="Forbidden",errorMessage='Route "'+routeId+'" does not match URL "'+pathname+'"'):404===status?(statusText="Not Found",errorMessage='No route matches URL "'+pathname+'"'):405===status&&(statusText="Method Not Allowed",method&&pathname&&routeId?errorMessage="You made a "+method.toUpperCase()+' request to "'+pathname+'" but did not provide an `action` for route "'+routeId+'", so there is no way to handle the request.':method&&(errorMessage='Invalid request method "'+method.toUpperCase()+'"')),new ErrorResponse(status||500,statusText,new Error(errorMessage),!0)}function findRedirect(results){for(let i=results.length-1;i>=0;i--){let result=results[i];if(isRedirectResult(result))return result}}function stripHashFromPath(path){return createPath(_extends({},"string"==typeof path?parsePath(path):path,{hash:""}))}function isHashChangeOnly(a,b){return a.pathname===b.pathname&&a.search===b.search&&a.hash!==b.hash}function isDeferredResult(result){return result.type===ResultType.deferred}function isErrorResult(result){return result.type===ResultType.error}function isRedirectResult(result){return(result&&result.type)===ResultType.redirect}function isDeferredData(value){let deferred=value;return deferred&&"object"==typeof deferred&&"object"==typeof deferred.data&&"function"==typeof deferred.subscribe&&"function"==typeof deferred.cancel&&"function"==typeof deferred.resolveData}function isResponse(value){return null!=value&&"number"==typeof value.status&&"string"==typeof value.statusText&&"object"==typeof value.headers&&void 0!==value.body}function isRedirectResponse(result){if(!isResponse(result))return!1;let status=result.status,location=result.headers.get("Location");return status>=300&&status<=399&&null!=location}function isQueryRouteResponse(obj){return obj&&isResponse(obj.response)&&(obj.type===ResultType.data||ResultType.error)}function isValidMethod(method){return validRequestMethods.has(method.toLowerCase())}function isMutationMethod(method){return validMutationMethods.has(method.toLowerCase())}async function resolveDeferredResults(currentMatches,matchesToLoad,results,signal,isFetcher,currentLoaderData){for(let index=0;index<results.length;index++){let result=results[index],match=matchesToLoad[index];if(!match)continue;let currentMatch=currentMatches.find((m=>m.route.id===match.route.id)),isRevalidatingLoader=null!=currentMatch&&!isNewRouteInstance(currentMatch,match)&&void 0!==(currentLoaderData&&currentLoaderData[match.route.id]);isDeferredResult(result)&&(isFetcher||isRevalidatingLoader)&&await resolveDeferredData(result,signal,isFetcher).then((result=>{result&&(results[index]=result||results[index])}))}}async function resolveDeferredData(result,signal,unwrap){if(void 0===unwrap&&(unwrap=!1),!await result.deferredData.resolveData(signal)){if(unwrap)try{return{type:ResultType.data,data:result.deferredData.unwrappedData}}catch(e){return{type:ResultType.error,error:e}}return{type:ResultType.data,data:result.deferredData.data}}}function hasNakedIndexQuery(search){return new URLSearchParams(search).getAll("index").some((v=>""===v))}function createUseMatchesMatch(match,loaderData){let{route:route,pathname:pathname,params:params}=match;return{id:route.id,pathname:pathname,params:params,data:loaderData[route.id],handle:route.handle}}function getTargetMatch(matches,location){let search="string"==typeof location?parsePath(location).search:location.search;if(matches[matches.length-1].route.index&&hasNakedIndexQuery(search||""))return matches[matches.length-1];let pathMatches=getPathContributingMatches(matches);return pathMatches[pathMatches.length-1]}export{AbortedDeferredError,Action,ErrorResponse,IDLE_BLOCKER,IDLE_FETCHER,IDLE_NAVIGATION,UNSAFE_DEFERRED_SYMBOL,DeferredData as UNSAFE_DeferredData,convertRoutesToDataRoutes as UNSAFE_convertRoutesToDataRoutes,getPathContributingMatches as UNSAFE_getPathContributingMatches,invariant as UNSAFE_invariant,warning as UNSAFE_warning,createBrowserHistory,createHashHistory,createMemoryHistory,createPath,createRouter,createStaticHandler,defer,generatePath,getStaticContextFromError,getToPathname,isDeferredData,isRouteErrorResponse,joinPaths,json,matchPath,matchRoutes,normalizePathname,parsePath,redirect,resolvePath,resolveTo,stripBasename};