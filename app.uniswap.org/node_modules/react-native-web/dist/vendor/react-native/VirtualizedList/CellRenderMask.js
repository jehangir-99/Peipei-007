import _objectSpread from"@babel/runtime/helpers/objectSpread2";import invariant from"fbjs/lib/invariant";export class CellRenderMask{constructor(numCells){invariant(numCells>=0,"CellRenderMask must contain a non-negative number os cells"),this._numCells=numCells,this._regions=0===numCells?[]:[{first:0,last:numCells-1,isSpacer:!0}]}enumerateRegions(){return this._regions}addCells(cells){if(invariant(cells.first>=0&&cells.first<this._numCells&&cells.last>=-1&&cells.last<this._numCells&&cells.last>=cells.first-1,"CellRenderMask.addCells called with invalid cell range"),!(cells.last<cells.first)){var _this$_findRegion=this._findRegion(cells.first),firstIntersect=_this$_findRegion[0],firstIntersectIdx=_this$_findRegion[1],_this$_findRegion2=this._findRegion(cells.last),lastIntersect=_this$_findRegion2[0],lastIntersectIdx=_this$_findRegion2[1];if(firstIntersectIdx!==lastIntersectIdx||firstIntersect.isSpacer){var newLeadRegion=[],newTailRegion=[],newMainRegion=_objectSpread(_objectSpread({},cells),{},{isSpacer:!1});firstIntersect.first<newMainRegion.first&&(firstIntersect.isSpacer?newLeadRegion.push({first:firstIntersect.first,last:newMainRegion.first-1,isSpacer:!0}):newMainRegion.first=firstIntersect.first),lastIntersect.last>newMainRegion.last&&(lastIntersect.isSpacer?newTailRegion.push({first:newMainRegion.last+1,last:lastIntersect.last,isSpacer:!0}):newMainRegion.last=lastIntersect.last);var replacementRegions=[...newLeadRegion,newMainRegion,...newTailRegion],numRegionsToDelete=lastIntersectIdx-firstIntersectIdx+1;this._regions.splice(firstIntersectIdx,numRegionsToDelete,...replacementRegions)}}}numCells(){return this._numCells}equals(other){return this._numCells===other._numCells&&this._regions.length===other._regions.length&&this._regions.every(((region,i)=>region.first===other._regions[i].first&&region.last===other._regions[i].last&&region.isSpacer===other._regions[i].isSpacer))}_findRegion(cellIdx){for(var firstIdx=0,lastIdx=this._regions.length-1;firstIdx<=lastIdx;){var middleIdx=Math.floor((firstIdx+lastIdx)/2),middleRegion=this._regions[middleIdx];if(cellIdx>=middleRegion.first&&cellIdx<=middleRegion.last)return[middleRegion,middleIdx];cellIdx<middleRegion.first?lastIdx=middleIdx-1:cellIdx>middleRegion.last&&(firstIdx=middleIdx+1)}invariant(!1,"A region was not found containing cellIdx "+cellIdx)}}