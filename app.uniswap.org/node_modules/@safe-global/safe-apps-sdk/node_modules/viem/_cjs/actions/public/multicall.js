"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.multicall=void 0;const abis_js_1=require("../../constants/abis.js"),abi_js_1=require("../../errors/abi.js"),base_js_1=require("../../errors/base.js"),contract_js_1=require("../../errors/contract.js"),decodeFunctionResult_js_1=require("../../utils/abi/decodeFunctionResult.js"),encodeFunctionData_js_1=require("../../utils/abi/encodeFunctionData.js"),getChainContractAddress_js_1=require("../../utils/chain/getChainContractAddress.js"),getContractError_js_1=require("../../utils/errors/getContractError.js"),getAction_js_1=require("../../utils/getAction.js"),readContract_js_1=require("./readContract.js");async function multicall(client,args){const{allowFailure:allowFailure=!0,batchSize:batchSize_,blockNumber:blockNumber,blockTag:blockTag,contracts:contracts,multicallAddress:multicallAddress_}=args,batchSize=batchSize_??("object"==typeof client.batch?.multicall&&client.batch.multicall.batchSize||1024);let multicallAddress=multicallAddress_;if(!multicallAddress){if(!client.chain)throw new Error("client chain not configured. multicallAddress is required.");multicallAddress=(0,getChainContractAddress_js_1.getChainContractAddress)({blockNumber:blockNumber,chain:client.chain,contract:"multicall3"})}const chunkedCalls=[[]];let currentChunk=0,currentChunkSize=0;for(let i=0;i<contracts.length;i++){const{abi:abi,address:address,args:args,functionName:functionName}=contracts[i];try{const callData=(0,encodeFunctionData_js_1.encodeFunctionData)({abi:abi,args:args,functionName:functionName});currentChunkSize+=(callData.length-2)/2,batchSize>0&&currentChunkSize>batchSize&&chunkedCalls[currentChunk].length>0&&(currentChunk++,currentChunkSize=(callData.length-2)/2,chunkedCalls[currentChunk]=[]),chunkedCalls[currentChunk]=[...chunkedCalls[currentChunk],{allowFailure:!0,callData:callData,target:address}]}catch(err){const error=(0,getContractError_js_1.getContractError)(err,{abi:abi,address:address,args:args,docsPath:"/docs/contract/multicall",functionName:functionName});if(!allowFailure)throw error;chunkedCalls[currentChunk]=[...chunkedCalls[currentChunk],{allowFailure:!0,callData:"0x",target:address}]}}const aggregate3Results=await Promise.allSettled(chunkedCalls.map((calls=>(0,getAction_js_1.getAction)(client,readContract_js_1.readContract,"readContract")({abi:abis_js_1.multicall3Abi,address:multicallAddress,args:[calls],blockNumber:blockNumber,blockTag:blockTag,functionName:"aggregate3"})))),results=[];for(let i=0;i<aggregate3Results.length;i++){const result=aggregate3Results[i];if("rejected"===result.status){if(!allowFailure)throw result.reason;for(let j=0;j<chunkedCalls[i].length;j++)results.push({status:"failure",error:result.reason,result:void 0});continue}const aggregate3Result=result.value;for(let j=0;j<aggregate3Result.length;j++){const{returnData:returnData,success:success}=aggregate3Result[j],{callData:callData}=chunkedCalls[i][j],{abi:abi,address:address,functionName:functionName,args:args}=contracts[results.length];try{if("0x"===callData)throw new abi_js_1.AbiDecodingZeroDataError;if(!success)throw new contract_js_1.RawContractError({data:returnData});const result=(0,decodeFunctionResult_js_1.decodeFunctionResult)({abi:abi,args:args,data:returnData,functionName:functionName});results.push(allowFailure?{result:result,status:"success"}:result)}catch(err){const error=(0,getContractError_js_1.getContractError)(err,{abi:abi,address:address,args:args,docsPath:"/docs/contract/multicall",functionName:functionName});if(!allowFailure)throw error;results.push({error:error,result:void 0,status:"failure"})}}}if(results.length!==contracts.length)throw new base_js_1.BaseError("multicall results mismatch");return results}exports.multicall=multicall;