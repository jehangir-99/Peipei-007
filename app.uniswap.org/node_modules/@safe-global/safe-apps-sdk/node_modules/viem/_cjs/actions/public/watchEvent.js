"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.watchEvent=void 0;const observe_js_1=require("../../utils/observe.js"),poll_js_1=require("../../utils/poll.js"),stringify_js_1=require("../../utils/stringify.js"),abi_js_1=require("../../errors/abi.js"),rpc_js_1=require("../../errors/rpc.js"),getAction_js_1=require("../../utils/getAction.js"),index_js_1=require("../../utils/index.js"),createEventFilter_js_1=require("./createEventFilter.js"),getBlockNumber_js_1=require("./getBlockNumber.js"),getFilterChanges_js_1=require("./getFilterChanges.js"),getLogs_js_1=require("./getLogs.js"),uninstallFilter_js_1=require("./uninstallFilter.js");function watchEvent(client,{address:address,args:args,batch:batch=!0,event:event,events:events,onError:onError,onLogs:onLogs,poll:poll_,pollingInterval:pollingInterval=client.pollingInterval,strict:strict_}){const enablePolling=void 0!==poll_?poll_:"webSocket"!==client.transport.type,strict=strict_??!1;return enablePolling?(()=>{const observerId=(0,stringify_js_1.stringify)(["watchEvent",address,args,batch,client.uid,event,pollingInterval]);return(0,observe_js_1.observe)(observerId,{onLogs:onLogs,onError:onError},(emit=>{let previousBlockNumber,filter,initialized=!1;const unwatch=(0,poll_js_1.poll)((async()=>{if(initialized)try{let logs;if(filter)logs=await(0,getAction_js_1.getAction)(client,getFilterChanges_js_1.getFilterChanges,"getFilterChanges")({filter:filter});else{const blockNumber=await(0,getAction_js_1.getAction)(client,getBlockNumber_js_1.getBlockNumber,"getBlockNumber")({});logs=previousBlockNumber&&previousBlockNumber!==blockNumber?await(0,getAction_js_1.getAction)(client,getLogs_js_1.getLogs,"getLogs")({address:address,args:args,event:event,events:events,fromBlock:previousBlockNumber+1n,toBlock:blockNumber}):[],previousBlockNumber=blockNumber}if(0===logs.length)return;if(batch)emit.onLogs(logs);else for(const log of logs)emit.onLogs([log])}catch(err){filter&&err instanceof rpc_js_1.InvalidInputRpcError&&(initialized=!1),emit.onError?.(err)}else{try{filter=await(0,getAction_js_1.getAction)(client,createEventFilter_js_1.createEventFilter,"createEventFilter")({address:address,args:args,event:event,events:events,strict:strict})}catch{}initialized=!0}}),{emitOnBegin:!0,interval:pollingInterval});return async()=>{filter&&await(0,getAction_js_1.getAction)(client,uninstallFilter_js_1.uninstallFilter,"uninstallFilter")({filter:filter}),unwatch()}}))})():(()=>{let active=!0,unsubscribe=()=>active=!1;return(async()=>{try{const events_=events??(event?[event]:void 0);let topics=[];events_&&(topics=[events_.flatMap((event=>(0,index_js_1.encodeEventTopics)({abi:[event],eventName:event.name,args:args})))],event&&(topics=topics[0]));const{unsubscribe:unsubscribe_}=await client.transport.subscribe({params:["logs",{address:address,topics:topics}],onData(data){if(!active)return;const log=data.result;try{const{eventName:eventName,args:args}=(0,index_js_1.decodeEventLog)({abi:events_,data:log.data,topics:log.topics,strict:strict}),formatted=(0,index_js_1.formatLog)(log,{args:args,eventName:eventName});onLogs([formatted])}catch(err){let eventName,isUnnamed;if(err instanceof abi_js_1.DecodeLogDataMismatch||err instanceof abi_js_1.DecodeLogTopicsMismatch){if(strict_)return;eventName=err.abiItem.name,isUnnamed=err.abiItem.inputs?.some((x=>!("name"in x&&x.name)))}const formatted=(0,index_js_1.formatLog)(log,{args:isUnnamed?[]:{},eventName:eventName});onLogs([formatted])}},onError(error){onError?.(error)}});unsubscribe=unsubscribe_,active||unsubscribe()}catch(err){onError?.(err)}})(),unsubscribe})()}exports.watchEvent=watchEvent;