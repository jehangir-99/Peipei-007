"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rankTransports=exports.fallback=void 0;const buildRequest_js_1=require("../../utils/buildRequest.js"),wait_js_1=require("../../utils/wait.js"),createTransport_js_1=require("./createTransport.js");function fallback(transports_,config={}){const{key:key="fallback",name:name="Fallback",rank:rank=!1,retryCount:retryCount,retryDelay:retryDelay}=config;return({chain:chain,pollingInterval:pollingInterval=4e3,timeout:timeout})=>{let transports=transports_,onResponse=()=>{};const transport=(0,createTransport_js_1.createTransport)({key:key,name:name,async request({method:method,params:params}){const fetch=async(i=0)=>{const transport=transports[i]({chain:chain,retryCount:0,timeout:timeout});try{const response=await transport.request({method:method,params:params});return onResponse({method:method,params:params,response:response,transport:transport,status:"success"}),response}catch(err){if(onResponse({error:err,method:method,params:params,transport:transport,status:"error"}),(0,buildRequest_js_1.isDeterministicError)(err))throw err;if(i===transports.length-1)throw err;return fetch(i+1)}};return fetch()},retryCount:retryCount,retryDelay:retryDelay,type:"fallback"},{onResponse:fn=>onResponse=fn,transports:transports.map((fn=>fn({chain:chain,retryCount:0})))});if(rank){const rankOptions="object"==typeof rank?rank:{};rankTransports({chain:chain,interval:rankOptions.interval??pollingInterval,onTransports:transports_=>transports=transports_,sampleCount:rankOptions.sampleCount,timeout:rankOptions.timeout,transports:transports,weights:rankOptions.weights})}return transport}}function rankTransports({chain:chain,interval:interval=4e3,onTransports:onTransports,sampleCount:sampleCount=10,timeout:timeout=1e3,transports:transports,weights:weights={}}){const{stability:stabilityWeight=.7,latency:latencyWeight=.3}=weights,samples=[],rankTransports_=async()=>{const sample=await Promise.all(transports.map((async transport=>{const transport_=transport({chain:chain,retryCount:0,timeout:timeout}),start=Date.now();let end,success;try{await transport_.request({method:"net_listening"}),success=1}catch{success=0}finally{end=Date.now()}return{latency:end-start,success:success}})));samples.push(sample),samples.length>sampleCount&&samples.shift();const maxLatency=Math.max(...samples.map((sample=>Math.max(...sample.map((({latency:latency})=>latency)))))),scores=transports.map(((_,i)=>{const latencies=samples.map((sample=>sample[i].latency)),latencyScore=1-latencies.reduce(((acc,latency)=>acc+latency),0)/latencies.length/maxLatency,successes=samples.map((sample=>sample[i].success)),stabilityScore=successes.reduce(((acc,success)=>acc+success),0)/successes.length;return 0===stabilityScore?[0,i]:[latencyWeight*latencyScore+stabilityWeight*stabilityScore,i]})).sort(((a,b)=>b[0]-a[0]));onTransports(scores.map((([,i])=>transports[i]))),await(0,wait_js_1.wait)(interval),rankTransports_()};rankTransports_()}exports.fallback=fallback,exports.rankTransports=rankTransports;