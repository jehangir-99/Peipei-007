"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rpc=exports.getSocket=exports.socketsCache=void 0;const isows_1=require("isows"),request_js_1=require("../errors/request.js"),createBatchScheduler_js_1=require("./promise/createBatchScheduler.js"),withTimeout_js_1=require("./promise/withTimeout.js"),stringify_js_1=require("./stringify.js");let id=0;async function http(url,{body:body,fetchOptions:fetchOptions={},timeout:timeout=1e4}){const{headers:headers,method:method,signal:signal_}=fetchOptions;try{const response=await(0,withTimeout_js_1.withTimeout)((async({signal:signal})=>await fetch(url,{...fetchOptions,body:Array.isArray(body)?(0,stringify_js_1.stringify)(body.map((body=>({jsonrpc:"2.0",id:body.id??id++,...body})))):(0,stringify_js_1.stringify)({jsonrpc:"2.0",id:body.id??id++,...body}),headers:{...headers,"Content-Type":"application/json"},method:method||"POST",signal:signal_||(timeout>0?signal:void 0)})),{errorInstance:new request_js_1.TimeoutError({body:body,url:url}),timeout:timeout,signal:!0});let data;if(data=response.headers.get("Content-Type")?.startsWith("application/json")?await response.json():await response.text(),!response.ok)throw new request_js_1.HttpRequestError({body:body,details:(0,stringify_js_1.stringify)(data.error)||response.statusText,headers:response.headers,status:response.status,url:url});return data}catch(err){if(err instanceof request_js_1.HttpRequestError)throw err;if(err instanceof request_js_1.TimeoutError)throw err;throw new request_js_1.HttpRequestError({body:body,details:err.message,url:url})}}async function getSocket(url){let socket=exports.socketsCache.get(url);if(socket)return socket;const{schedule:schedule}=(0,createBatchScheduler_js_1.createBatchScheduler)({id:url,fn:async()=>{const webSocket=new isows_1.WebSocket(url),requests=new Map,subscriptions=new Map,onMessage=({data:data})=>{const message=JSON.parse(data),isSubscription="eth_subscription"===message.method,id=isSubscription?message.params.subscription:message.id,cache=isSubscription?subscriptions:requests,callback=cache.get(id);callback&&callback({data:data}),isSubscription||cache.delete(id)},onClose=()=>{exports.socketsCache.delete(url),webSocket.removeEventListener("close",onClose),webSocket.removeEventListener("message",onMessage)};return webSocket.addEventListener("close",onClose),webSocket.addEventListener("message",onMessage),webSocket.readyState===isows_1.WebSocket.CONNECTING&&await new Promise(((resolve,reject)=>{webSocket&&(webSocket.onopen=resolve,webSocket.onerror=reject)})),socket=Object.assign(webSocket,{requests:requests,subscriptions:subscriptions}),exports.socketsCache.set(url,socket),[socket]}}),[_,[socket_]]=await schedule();return socket_}function webSocket(socket,{body:body,onResponse:onResponse}){if(socket.readyState===socket.CLOSED||socket.readyState===socket.CLOSING)throw new request_js_1.WebSocketRequestError({body:body,url:socket.url,details:"Socket is closed."});const id_=id++,callback=({data:data})=>{const message=JSON.parse(data);"number"==typeof message.id&&id_!==message.id||(onResponse?.(message),"eth_subscribe"===body.method&&"string"==typeof message.result&&socket.subscriptions.set(message.result,callback),"eth_unsubscribe"===body.method&&socket.subscriptions.delete(body.params?.[0]))};return socket.requests.set(id_,callback),socket.send(JSON.stringify({jsonrpc:"2.0",...body,id:id_})),socket}async function webSocketAsync(socket,{body:body,timeout:timeout=1e4}){return(0,withTimeout_js_1.withTimeout)((()=>new Promise((onResponse=>exports.rpc.webSocket(socket,{body:body,onResponse:onResponse})))),{errorInstance:new request_js_1.TimeoutError({body:body,url:socket.url}),timeout:timeout})}exports.socketsCache=new Map,exports.getSocket=getSocket,exports.rpc={http:http,webSocket:webSocket,webSocketAsync:webSocketAsync};