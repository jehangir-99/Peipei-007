"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.hexToString=exports.hexToNumber=exports.hexToBool=exports.hexToBigInt=exports.fromHex=exports.assertSize=void 0;const encoding_js_1=require("../../errors/encoding.js"),size_js_1=require("../data/size.js"),trim_js_1=require("../data/trim.js"),toBytes_js_1=require("./toBytes.js");function assertSize(hexOrBytes,{size:size}){if((0,size_js_1.size)(hexOrBytes)>size)throw new encoding_js_1.SizeOverflowError({givenSize:(0,size_js_1.size)(hexOrBytes),maxSize:size})}function fromHex(hex,toOrOpts){const opts="string"==typeof toOrOpts?{to:toOrOpts}:toOrOpts,to=opts.to;return"number"===to?hexToNumber(hex,opts):"bigint"===to?hexToBigInt(hex,opts):"string"===to?hexToString(hex,opts):"boolean"===to?hexToBool(hex,opts):(0,toBytes_js_1.hexToBytes)(hex,opts)}function hexToBigInt(hex,opts={}){const{signed:signed}=opts;opts.size&&assertSize(hex,{size:opts.size});const value=BigInt(hex);if(!signed)return value;const size=(hex.length-2)/2;return value<=(1n<<8n*BigInt(size)-1n)-1n?value:value-BigInt(`0x${"f".padStart(2*size,"f")}`)-1n}function hexToBool(hex_,opts={}){let hex=hex_;if(opts.size&&(assertSize(hex,{size:opts.size}),hex=(0,trim_js_1.trim)(hex)),"0x00"===(0,trim_js_1.trim)(hex))return!1;if("0x01"===(0,trim_js_1.trim)(hex))return!0;throw new encoding_js_1.InvalidHexBooleanError(hex)}function hexToNumber(hex,opts={}){return Number(hexToBigInt(hex,opts))}function hexToString(hex,opts={}){let bytes=(0,toBytes_js_1.hexToBytes)(hex);return opts.size&&(assertSize(bytes,{size:opts.size}),bytes=(0,trim_js_1.trim)(bytes,{dir:"right"})),(new TextDecoder).decode(bytes)}exports.assertSize=assertSize,exports.fromHex=fromHex,exports.hexToBigInt=hexToBigInt,exports.hexToBool=hexToBool,exports.hexToNumber=hexToNumber,exports.hexToString=hexToString;