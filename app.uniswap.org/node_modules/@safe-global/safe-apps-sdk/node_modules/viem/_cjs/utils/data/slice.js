"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sliceHex=exports.sliceBytes=exports.slice=void 0;const data_js_1=require("../../errors/data.js"),isHex_js_1=require("./isHex.js"),size_js_1=require("./size.js");function slice(value,start,end,{strict:strict}={}){return(0,isHex_js_1.isHex)(value,{strict:!1})?sliceHex(value,start,end,{strict:strict}):sliceBytes(value,start,end,{strict:strict})}function assertStartOffset(value,start){if("number"==typeof start&&start>0&&start>(0,size_js_1.size)(value)-1)throw new data_js_1.SliceOffsetOutOfBoundsError({offset:start,position:"start",size:(0,size_js_1.size)(value)})}function assertEndOffset(value,start,end){if("number"==typeof start&&"number"==typeof end&&(0,size_js_1.size)(value)!==end-start)throw new data_js_1.SliceOffsetOutOfBoundsError({offset:end,position:"end",size:(0,size_js_1.size)(value)})}function sliceBytes(value_,start,end,{strict:strict}={}){assertStartOffset(value_,start);const value=value_.slice(start,end);return strict&&assertEndOffset(value,start,end),value}function sliceHex(value_,start,end,{strict:strict}={}){assertStartOffset(value_,start);const value=`0x${value_.replace("0x","").slice(2*(start??0),2*(end??value_.length))}`;return strict&&assertEndOffset(value,start,end),value}exports.slice=slice,exports.sliceBytes=sliceBytes,exports.sliceHex=sliceHex;