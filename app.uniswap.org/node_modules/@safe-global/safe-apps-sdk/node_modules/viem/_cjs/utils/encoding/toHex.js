"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringToHex=exports.numberToHex=exports.bytesToHex=exports.boolToHex=exports.toHex=void 0;const encoding_js_1=require("../../errors/encoding.js"),pad_js_1=require("../data/pad.js"),fromHex_js_1=require("./fromHex.js"),hexes=Array.from({length:256},((_v,i)=>i.toString(16).padStart(2,"0")));function toHex(value,opts={}){return"number"==typeof value||"bigint"==typeof value?numberToHex(value,opts):"string"==typeof value?stringToHex(value,opts):"boolean"==typeof value?boolToHex(value,opts):bytesToHex(value,opts)}function boolToHex(value,opts={}){const hex=`0x${Number(value)}`;return"number"==typeof opts.size?((0,fromHex_js_1.assertSize)(hex,{size:opts.size}),(0,pad_js_1.pad)(hex,{size:opts.size})):hex}function bytesToHex(value,opts={}){let string="";for(let i=0;i<value.length;i++)string+=hexes[value[i]];const hex=`0x${string}`;return"number"==typeof opts.size?((0,fromHex_js_1.assertSize)(hex,{size:opts.size}),(0,pad_js_1.pad)(hex,{dir:"right",size:opts.size})):hex}function numberToHex(value_,opts={}){const{signed:signed,size:size}=opts,value=BigInt(value_);let maxValue;size?maxValue=signed?(1n<<8n*BigInt(size)-1n)-1n:2n**(8n*BigInt(size))-1n:"number"==typeof value_&&(maxValue=BigInt(Number.MAX_SAFE_INTEGER));const minValue="bigint"==typeof maxValue&&signed?-maxValue-1n:0;if(maxValue&&value>maxValue||value<minValue){const suffix="bigint"==typeof value_?"n":"";throw new encoding_js_1.IntegerOutOfRangeError({max:maxValue?`${maxValue}${suffix}`:void 0,min:`${minValue}${suffix}`,signed:signed,size:size,value:`${value_}${suffix}`})}const hex=`0x${(signed&&value<0?(1n<<BigInt(8*size))+BigInt(value):value).toString(16)}`;return size?(0,pad_js_1.pad)(hex,{size:size}):hex}exports.toHex=toHex,exports.boolToHex=boolToHex,exports.bytesToHex=bytesToHex,exports.numberToHex=numberToHex;const encoder=new TextEncoder;function stringToHex(value_,opts={}){return bytesToHex(encoder.encode(value_),opts)}exports.stringToHex=stringToHex;