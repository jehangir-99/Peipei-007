import{useCallback,useEffect}from"react";import{useAnimatedStyle,useSharedValue,withDecay,withSpring,withTiming,withDelay,withRepeat,withSequence,runOnJS}from"react-native-reanimated";import{PackageName}from"./constants/package-name";const debug=(...args)=>{global.shouldDebugMoti&&console.log("[moti]",...args)},isColor=styleKey=>Boolean({backgroundColor:!0,borderBottomColor:!0,borderLeftColor:!0,borderRightColor:!0,borderTopColor:!0,color:!0,shadowColor:!0,borderColor:!0,borderEndColor:!0,borderStartColor:!0}[styleKey]),isTransform=styleKey=>Boolean({perspective:!0,rotate:!0,rotateX:!0,rotateY:!0,rotateZ:!0,scale:!0,scaleX:!0,scaleY:!0,translateX:!0,translateY:!0,skewX:!0,skewY:!0}[styleKey]);function animationDelay(_key,transition,defaultDelay){const key=_key;let delayMs=defaultDelay;return null!=transition?.[key]?.delay?delayMs=transition?.[key]?.delay:null!=transition?.delay&&(delayMs=transition.delay),{delayMs:delayMs}}const withSpringConfigKeys=["stiffness","overshootClamping","restDisplacementThreshold","restSpeedThreshold","velocity","reduceMotion","mass","damping","duration","dampingRatio"];function animationConfig(styleProp,transition){const key=styleProp;let repeatCount=0,repeatReverse=!0,animationType="spring";(isColor(key)||"opacity"===key)&&(animationType="timing");const styleSpecificTransition=transition?.[key];styleSpecificTransition?.type?animationType=styleSpecificTransition.type:transition?.type&&(animationType=transition.type);const loop=styleSpecificTransition?.loop??transition?.loop;null!=loop&&(repeatCount=loop?-1:0),null!=styleSpecificTransition?.repeat?repeatCount=styleSpecificTransition?.repeat:null!=transition?.repeat&&(repeatCount=transition.repeat),null!=styleSpecificTransition?.repeatReverse?repeatReverse=styleSpecificTransition.repeatReverse:null!=transition?.repeatReverse&&(repeatReverse=transition.repeatReverse);let config={},animation=(...props)=>props;if("timing"===animationType){const duration=transition?.[key]?.duration??transition?.duration,easing=transition?.[key]?.easing??transition?.easing;easing&&(config.easing=easing),null!=duration&&(config.duration=duration),animation=withTiming}else if("spring"===animationType){animation=withSpring,config={};for(const configKey of withSpringConfigKeys){const styleSpecificConfig=transition?.[key]?.[configKey],transitionConfigForKey=transition?.[configKey];null!=styleSpecificConfig?config[configKey]=styleSpecificConfig:null!=transitionConfigForKey&&(config[configKey]=transitionConfigForKey)}}else if("decay"===animationType){animation=withDecay,config={};const configKeys=["clamp","velocity","deceleration","velocityFactor","reduceMotion","velocityFactor"];for(const configKey of configKeys){const styleSpecificConfig=transition?.[key]?.[configKey],transitionConfigForKey=transition?.[configKey];null!=styleSpecificConfig?config[configKey]=styleSpecificConfig:null!=transitionConfigForKey&&(config[configKey]=transitionConfigForKey)}}else"no-animation"===animationType&&(animation=value=>value,config={},repeatCount=0);return{animation:animation,config:config,repeatReverse:repeatReverse,repeatCount:repeatCount,shouldRepeat:!!repeatCount}}const getSequenceArray=(sequenceKey,sequenceArray,delayMs,config,animation,callback)=>{const sequence=[];for(const step of sequenceArray){let stepOnDidAnimate;if("object"==typeof step?step&&null!=step?.value&&!1!==step?.value:null!=step&&!1!==step){let stepDelay=delayMs,stepValue=step,stepConfig=Object.assign({},config),stepAnimation=animation;if("object"==typeof step){const stepTransition=Object.assign({},step);delete stepTransition.delay,delete stepTransition.value;const{config:inlineStepConfig,animation:animation}=animationConfig(sequenceKey,stepTransition);stepConfig=Object.assign({},stepConfig,inlineStepConfig),stepAnimation=animation,null!=step.delay&&(stepDelay=step.delay),stepValue=step.value,stepOnDidAnimate=step.onDidAnimate}const sequenceValue=stepAnimation(stepValue,stepConfig,((completed=!1,maybeValue)=>{callback(completed,maybeValue,{attemptedSequenceValue:stepValue}),stepOnDidAnimate&&runOnJS(stepOnDidAnimate)(completed,maybeValue,{attemptedSequenceItemValue:stepValue,attemptedSequenceArray:maybeValue})}));null!=stepDelay?sequence.push(withDelay(stepDelay,sequenceValue)):sequence.push(sequenceValue)}}return sequence};export function useMotify({animate:animateProp,from:fromProp=!1,transition:transitionProp,exitTransition:exitTransitionProp,delay:defaultDelay,state:state,stylePriority:stylePriority="animate",onDidAnimate:onDidAnimate,exit:exitProp,animateInitialState:animateInitialState=!1,usePresenceValue:usePresenceValue,presenceContext:presenceContext}){const isMounted=useSharedValue(!1),[isPresent,safeToUnmount]=usePresenceValue??[],disableInitialAnimation=!1===presenceContext?.initial&&!animateInitialState,custom=useCallback((()=>presenceContext?.custom),[presenceContext]),reanimatedSafeToUnmount=useCallback((()=>{safeToUnmount?.()}),[safeToUnmount]),reanimatedOnDidAnimated=useCallback(((...args)=>{onDidAnimate?.(...args)}),[onDidAnimate]),hasExitStyle=Boolean("function"==typeof exitProp||"object"==typeof exitProp&&exitProp&&Object.keys(exitProp).length>0),style=useAnimatedStyle((()=>{const final={transform:[]},variantStyle=state?.__state?.value||{};let animateStyle;animateStyle=animateProp&&"value"in animateProp?animateProp.value||{}:animateProp||{},debug("style",animateStyle);const initialStyle=fromProp||{};let exitStyle=exitProp||{};"function"==typeof exitStyle&&(exitStyle=exitStyle(custom()));const isExiting=!isPresent&&hasExitStyle;let mergedStyles={};mergedStyles="state"===stylePriority?Object.assign({},animateStyle,variantStyle):Object.assign({},variantStyle,animateStyle),mergedStyles=isMounted.value||disableInitialAnimation||!Object.keys(initialStyle).length?Object.assign({},initialStyle,mergedStyles):initialStyle,isExiting&&exitStyle&&(mergedStyles=Object.assign({},exitStyle));const exitingStyleProps={};let transition;if(Object.keys(exitStyle||{}).forEach((key=>{({position:!0,zIndex:!0})[key]||(exitingStyleProps[key]=!0)})),transition=transitionProp&&"value"in transitionProp?transitionProp.value:transitionProp,variantStyle.transition&&(transition=Object.assign({},transition,variantStyle.transition)),isExiting&&exitTransitionProp){let exitTransition;exitTransition=exitTransitionProp&&"value"in exitTransitionProp?exitTransitionProp.value:"function"==typeof exitTransitionProp?exitTransitionProp(custom()):exitTransitionProp,transition=Object.assign({},transition,exitTransition)}return Object.keys(mergedStyles).forEach((key=>{let inlineOnDidAnimate,value=mergedStyles[key];"object"==typeof value&&value&&"onDidAnimate"in value&&(inlineOnDidAnimate=value.onDidAnimate,value=value.value);const{animation:animation,config:config,shouldRepeat:shouldRepeat,repeatCount:repeatCount,repeatReverse:repeatReverse}=animationConfig(key,transition),callback=(completed=!1,recentValue,info)=>{if(onDidAnimate&&runOnJS(reanimatedOnDidAnimated)(key,completed,recentValue,{attemptedValue:value,attemptedSequenceItemValue:info?.attemptedSequenceValue}),inlineOnDidAnimate&&runOnJS(inlineOnDidAnimate)(completed,recentValue,{attemptedValue:value}),isExiting){exitingStyleProps[key]=!1;Object.values(exitingStyleProps).some(Boolean)||runOnJS(reanimatedSafeToUnmount)()}};let{delayMs:delayMs}=animationDelay(key,transition,defaultDelay);if(null!=value&&!1!==value)if("transform"===key)Array.isArray(value)?value.forEach((transformObject=>{final.transform=final.transform||[];const transformKey=Object.keys(transformObject)[0],transformValue=transformObject[transformKey],transform={};if(Array.isArray(transformValue)){const sequence=getSequenceArray(transformKey,transformValue,delayMs,config,animation,callback);if(sequence.length){let finalValue=withSequence(sequence[0],...sequence.slice(1));shouldRepeat&&(finalValue=withRepeat(finalValue,repeatCount,repeatReverse)),transform[transformKey]=finalValue}}else{null!=transition?.[transformKey]?.delay&&(delayMs=transition?.[transformKey]?.delay);let finalValue=animation(transformValue,config,callback);shouldRepeat&&(finalValue=withRepeat(finalValue,repeatCount,repeatReverse)),transform[transformKey]=null!=delayMs?withDelay(delayMs,finalValue):finalValue}Object.keys(transform).length&&final.transform.push(transform)})):console.error(`[${PackageName}]: Invalid transform value. Needs to be an array.`);else if(Array.isArray(value)){const sequence=getSequenceArray(key,value,delayMs,config,animation,callback);let finalValue=withSequence(sequence[0],...sequence.slice(1));if(shouldRepeat&&(finalValue=withRepeat(finalValue,repeatCount,repeatReverse)),isTransform(key)){if(final.transform=final.transform||[],sequence.length){const transform={};transform[key]=finalValue,final.transform.push(transform)}}else sequence.length&&(final[key]=finalValue)}else if(isTransform(key)){final.transform=final.transform||[],null!=transition?.[key]?.delay&&(delayMs=transition?.[key]?.delay);const transform={};let finalValue=animation(value,config,callback);shouldRepeat&&(finalValue=withRepeat(finalValue,repeatCount,repeatReverse)),transform[key]=null!=delayMs?withDelay(delayMs,finalValue):finalValue,final.transform.push(transform)}else if("object"==typeof value){final[key]={};for(const innerStyleKey in value||{}){let finalValue=animation(value,config,callback);shouldRepeat&&(finalValue=withRepeat(finalValue,repeatCount,repeatReverse)),final[key][innerStyleKey]=null!=delayMs?withDelay(delayMs,finalValue):finalValue}}else{let finalValue=animation(value,config,callback);shouldRepeat&&(finalValue=withRepeat(finalValue,repeatCount,repeatReverse)),final[key]=null!=delayMs&&"number"==typeof delayMs?withDelay(delayMs,finalValue):finalValue}})),final.transform?.length||delete final.transform,final}),[animateProp,custom,defaultDelay,disableInitialAnimation,exitProp,exitTransitionProp,fromProp,hasExitStyle,isMounted,isPresent,onDidAnimate,reanimatedOnDidAnimated,reanimatedSafeToUnmount,state,stylePriority,transitionProp]);return useEffect((()=>{isMounted.value=!0}),[isMounted]),useEffect((function(){isPresent||hasExitStyle||reanimatedSafeToUnmount()}),[hasExitStyle,isPresent,reanimatedSafeToUnmount]),{style:style}}