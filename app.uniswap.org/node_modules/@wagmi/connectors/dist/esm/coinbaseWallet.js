import{ChainNotConfiguredError,createConnector}from"@wagmi/core";import{SwitchChainError,UserRejectedRequestError,getAddress,numberToHex}from"viem";coinbaseWallet.type="coinbaseWallet";export function coinbaseWallet(parameters){let sdk,walletProvider,accountsChanged,chainChanged,disconnect;return createConnector((config=>({id:"coinbaseWalletSDK",name:"Coinbase Wallet",supportsSimulation:!0,type:coinbaseWallet.type,async connect({chainId:chainId}={}){try{const provider=await this.getProvider(),accounts=(await provider.request({method:"eth_requestAccounts"})).map((x=>getAddress(x)));accountsChanged||(accountsChanged=this.onAccountsChanged.bind(this),provider.on("accountsChanged",accountsChanged)),chainChanged||(chainChanged=this.onChainChanged.bind(this),provider.on("chainChanged",chainChanged)),disconnect||(disconnect=this.onDisconnect.bind(this),provider.on("disconnect",disconnect));let currentChainId=await this.getChainId();if(chainId&&currentChainId!==chainId){const chain=await this.switchChain({chainId:chainId}).catch((error=>{if(error.code===UserRejectedRequestError.code)throw error;return{id:currentChainId}}));currentChainId=chain?.id??currentChainId}return{accounts:accounts,chainId:currentChainId}}catch(error){if(/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))throw new UserRejectedRequestError(error);throw error}},async disconnect(){const provider=await this.getProvider();accountsChanged&&(provider.removeListener("accountsChanged",accountsChanged),accountsChanged=void 0),chainChanged&&(provider.removeListener("chainChanged",chainChanged),chainChanged=void 0),disconnect&&(provider.removeListener("disconnect",disconnect),disconnect=void 0),provider.disconnect(),provider.close()},async getAccounts(){const provider=await this.getProvider();return(await provider.request({method:"eth_accounts"})).map((x=>getAddress(x)))},async getChainId(){const provider=await this.getProvider(),chainId=await provider.request({method:"eth_chainId"});return Number(chainId)},async getProvider(){if(!walletProvider){const{default:CoinbaseWalletSDK}=await import("@coinbase/wallet-sdk");let SDK;SDK="function"!=typeof CoinbaseWalletSDK&&"function"==typeof CoinbaseWalletSDK.default?CoinbaseWalletSDK.default:CoinbaseWalletSDK,sdk=new SDK({reloadOnDisconnect:false,...parameters});const walletExtensionChainId=sdk.walletExtension?.getChainId(),chain=config.chains.find((chain=>parameters.chainId?chain.id===parameters.chainId:chain.id===walletExtensionChainId))||config.chains[0],chainId=parameters.chainId||chain?.id,jsonRpcUrl=parameters.jsonRpcUrl||chain?.rpcUrls.default.http[0];walletProvider=sdk.makeWeb3Provider(jsonRpcUrl,chainId)}return walletProvider},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:addEthereumChainParameter,chainId:chainId}){const chain=config.chains.find((chain=>chain.id===chainId));if(!chain)throw new SwitchChainError(new ChainNotConfiguredError);const provider=await this.getProvider();try{return await provider.request({method:"wallet_switchEthereumChain",params:[{chainId:numberToHex(chain.id)}]}),chain}catch(error){if(4902===error.code)try{let blockExplorerUrls,rpcUrls;blockExplorerUrls=addEthereumChainParameter?.blockExplorerUrls?addEthereumChainParameter.blockExplorerUrls:chain.blockExplorers?.default.url?[chain.blockExplorers?.default.url]:[],rpcUrls=addEthereumChainParameter?.rpcUrls?.length?addEthereumChainParameter.rpcUrls:[chain.rpcUrls.default?.http[0]??""];const addEthereumChain={blockExplorerUrls:blockExplorerUrls,chainId:numberToHex(chainId),chainName:addEthereumChainParameter?.chainName??chain.name,iconUrls:addEthereumChainParameter?.iconUrls,nativeCurrency:addEthereumChainParameter?.nativeCurrency??chain.nativeCurrency,rpcUrls:rpcUrls};return await provider.request({method:"wallet_addEthereumChain",params:[addEthereumChain]}),chain}catch(error){throw new UserRejectedRequestError(error)}throw new SwitchChainError(error)}},onAccountsChanged(accounts){0===accounts.length?this.onDisconnect():config.emitter.emit("change",{accounts:accounts.map((x=>getAddress(x)))})},onChainChanged(chain){const chainId=Number(chain);config.emitter.emit("change",{chainId:chainId})},async onDisconnect(_error){config.emitter.emit("disconnect");const provider=await this.getProvider();accountsChanged&&(provider.removeListener("accountsChanged",accountsChanged),accountsChanged=void 0),chainChanged&&(provider.removeListener("chainChanged",chainChanged),chainChanged=void 0),disconnect&&(provider.removeListener("disconnect",disconnect),disconnect=void 0)}})))}