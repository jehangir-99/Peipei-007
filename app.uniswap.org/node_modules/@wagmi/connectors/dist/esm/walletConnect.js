import{ChainNotConfiguredError,ProviderNotFoundError,createConnector}from"@wagmi/core";import{}from"@wagmi/core/internal";import{SwitchChainError,UserRejectedRequestError,getAddress,numberToHex}from"viem";walletConnect.type="walletConnect";export function walletConnect(parameters){const isNewChainsStale=parameters.isNewChainsStale??!0;let provider_,providerPromise;return createConnector((config=>({id:"walletConnect",name:"WalletConnect",type:walletConnect.type,async setup(){const provider=await this.getProvider().catch((()=>null));provider&&(provider.on("connect",this.onConnect.bind(this)),provider.on("session_delete",this.onSessionDelete.bind(this)))},async connect({chainId:chainId,...rest}={}){try{const provider=await this.getProvider();if(!provider)throw new ProviderNotFoundError;provider.on("display_uri",this.onDisplayUri);let targetChainId=chainId;if(!targetChainId){const state=await(config.storage?.getItem("state"))??{},isChainSupported=config.chains.some((x=>x.id===state.chainId));targetChainId=isChainSupported?state.chainId:config.chains[0]?.id}if(!targetChainId)throw new Error("No chains found on connector.");const isChainsStale=await this.isChainsStale();if(provider.session&&isChainsStale&&await provider.disconnect(),!provider.session||isChainsStale){const optionalChains=config.chains.filter((chain=>chain.id!==targetChainId)).map((optionalChain=>optionalChain.id));await provider.connect({optionalChains:[targetChainId,...optionalChains],..."pairingTopic"in rest?{pairingTopic:rest.pairingTopic}:{}}),this.setRequestedChainsIds(config.chains.map((x=>x.id)))}const accounts=(await provider.enable()).map((x=>getAddress(x))),currentChainId=await this.getChainId();return provider.removeListener("display_uri",this.onDisplayUri),provider.removeListener("connect",this.onConnect.bind(this)),provider.on("accountsChanged",this.onAccountsChanged.bind(this)),provider.on("chainChanged",this.onChainChanged),provider.on("disconnect",this.onDisconnect.bind(this)),provider.on("session_delete",this.onSessionDelete.bind(this)),{accounts:accounts,chainId:currentChainId}}catch(error){if(/(user rejected|connection request reset)/i.test(error?.message))throw new UserRejectedRequestError(error);throw error}},async disconnect(){const provider=await this.getProvider();try{await(provider?.disconnect())}catch(error){if(!/No matching key/i.test(error.message))throw error}finally{provider?.removeListener("accountsChanged",this.onAccountsChanged.bind(this)),provider?.removeListener("chainChanged",this.onChainChanged),provider?.removeListener("disconnect",this.onDisconnect.bind(this)),provider?.removeListener("session_delete",this.onSessionDelete.bind(this)),provider?.on("connect",this.onConnect.bind(this)),this.setRequestedChainsIds([])}},async getAccounts(){return(await this.getProvider()).accounts.map((x=>getAddress(x)))},async getProvider({chainId:chainId}={}){return provider_||(providerPromise||(providerPromise=async function(){const optionalChains=config.chains.map((x=>x.id));if(!optionalChains.length)return;const{EthereumProvider:EthereumProvider}=await import("@walletconnect/ethereum-provider");return await EthereumProvider.init({...parameters,disableProviderPing:!0,optionalChains:optionalChains,projectId:parameters.projectId,rpcMap:Object.fromEntries(config.chains.map((chain=>[chain.id,chain.rpcUrls.default.http[0]]))),showQrModal:parameters.showQrModal??!0})}()),provider_=await providerPromise,provider_?.events.setMaxListeners(1/0)),chainId&&await(this.switchChain?.({chainId:chainId})),provider_},async getChainId(){return(await this.getProvider()).chainId},async isAuthorized(){try{const[accounts,provider]=await Promise.all([this.getAccounts(),this.getProvider()]);if(!accounts.length)return!1;return!await this.isChainsStale()||!provider.session||(await provider.disconnect().catch((()=>{})),!1)}catch{return!1}},async switchChain({addEthereumChainParameter:addEthereumChainParameter,chainId:chainId}){const chain=config.chains.find((chain=>chain.id===chainId));if(!chain)throw new SwitchChainError(new ChainNotConfiguredError);try{const provider=await this.getProvider(),namespaceChains=this.getNamespaceChainsIds(),namespaceMethods=this.getNamespaceMethods();if(!namespaceChains.includes(chainId)&&namespaceMethods.includes("wallet_addEthereumChain")){let blockExplorerUrls,rpcUrls;blockExplorerUrls=addEthereumChainParameter?.blockExplorerUrls?addEthereumChainParameter.blockExplorerUrls:chain.blockExplorers?.default.url?[chain.blockExplorers?.default.url]:[],rpcUrls=addEthereumChainParameter?.rpcUrls?.length?addEthereumChainParameter.rpcUrls:[...chain.rpcUrls.default.http];const addEthereumChain={blockExplorerUrls:blockExplorerUrls,chainId:numberToHex(chainId),chainName:addEthereumChainParameter?.chainName??chain.name,iconUrls:addEthereumChainParameter?.iconUrls,nativeCurrency:addEthereumChainParameter?.nativeCurrency??chain.nativeCurrency,rpcUrls:rpcUrls};await provider.request({method:"wallet_addEthereumChain",params:[addEthereumChain]});const requestedChains=await this.getRequestedChainsIds();this.setRequestedChainsIds([...requestedChains,chainId])}return await provider.request({method:"wallet_switchEthereumChain",params:[{chainId:numberToHex(chainId)}]}),chain}catch(error){if(/user rejected request/i.test("string"==typeof error?error:error?.message))throw new UserRejectedRequestError(error);throw new SwitchChainError(error)}},onAccountsChanged(accounts){0===accounts.length?this.onDisconnect():config.emitter.emit("change",{accounts:accounts.map((x=>getAddress(x)))})},onChainChanged(chain){const chainId=Number(chain);config.emitter.emit("change",{chainId:chainId})},async onConnect(connectInfo){const chainId=Number(connectInfo.chainId),accounts=await this.getAccounts();config.emitter.emit("connect",{accounts:accounts,chainId:chainId})},async onDisconnect(_error){this.setRequestedChainsIds([]),config.emitter.emit("disconnect");const provider=await this.getProvider();provider.removeListener("accountsChanged",this.onAccountsChanged.bind(this)),provider.removeListener("chainChanged",this.onChainChanged),provider.removeListener("disconnect",this.onDisconnect.bind(this)),provider.removeListener("session_delete",this.onSessionDelete.bind(this)),provider.on("connect",this.onConnect.bind(this))},onDisplayUri(uri){config.emitter.emit("message",{type:"display_uri",data:uri})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){if(!provider_)return[];const chainIds=provider_.session?.namespaces.eip155?.chains?.map((chain=>parseInt(chain.split(":")[1]||"")));return chainIds??[]},getNamespaceMethods(){if(!provider_)return[];const methods=provider_.session?.namespaces.eip155?.methods;return methods??[]},async getRequestedChainsIds(){return await(config.storage?.getItem(this.requestedChainsStorageKey))??[]},async isChainsStale(){if(this.getNamespaceMethods().includes("wallet_addEthereumChain"))return!1;if(!isNewChainsStale)return!1;const connectorChains=config.chains.map((x=>x.id)),namespaceChains=this.getNamespaceChainsIds();if(namespaceChains.length&&!namespaceChains.some((id=>connectorChains.includes(id))))return!1;const requestedChains=await this.getRequestedChainsIds();return!connectorChains.every((id=>requestedChains.includes(id)))},async setRequestedChainsIds(chains){await(config.storage?.setItem(this.requestedChainsStorageKey,chains))},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}})))}