import{createStore as createMipd}from"mipd";import{createClient}from"viem";import{persist,subscribeWithSelector}from"zustand/middleware";import{createStore}from"zustand/vanilla";import{}from"./connectors/createConnector.js";import{injected}from"./connectors/injected.js";import{Emitter,createEmitter}from"./createEmitter.js";import{createStorage,noopStorage}from"./createStorage.js";import{ChainNotConfiguredError}from"./errors/config.js";import{uid}from"./utils/uid.js";import{version}from"./version.js";export function createConfig(parameters){const{multiInjectedProviderDiscovery:multiInjectedProviderDiscovery=!0,storage:storage=createStorage({storage:"undefined"!=typeof window&&window.localStorage?window.localStorage:noopStorage}),syncConnectedChain:syncConnectedChain=!0,ssr:ssr,...rest}=parameters,mipd="undefined"!=typeof window&&multiInjectedProviderDiscovery?createMipd():void 0,chains=createStore((()=>rest.chains)),connectors=createStore((()=>[...rest.connectors??[],...ssr?[]:mipd?.getProviders().map(providerDetailToConnector)??[]].map(setup)));function setup(connectorFn){const emitter=createEmitter(uid()),connector={...connectorFn({emitter:emitter,chains:chains.getState(),storage:storage}),emitter:emitter,uid:emitter.uid};return emitter.on("connect",connect),connector.setup?.(),connector}function providerDetailToConnector(providerDetail){const{info:info}=providerDetail,provider=providerDetail.provider;return injected({target:{...info,id:info.rdns,provider:provider}})}const clients=new Map;function getInitialState(){return{chainId:chains.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let currentVersion;currentVersion=version.startsWith("0.0.0-canary-")?parseInt(version.replace("0.0.0-canary-","")):parseInt(version.split(".")[0]??"0");const store=createStore(subscribeWithSelector(storage?persist(getInitialState,{migrate(persistedState,version){if(version===currentVersion)return persistedState;const initialState=getInitialState(),chainId=persistedState&&"object"==typeof persistedState&&"chainId"in persistedState&&"number"==typeof persistedState.chainId?persistedState.chainId:initialState.chainId;return{...initialState,chainId:chainId}},name:"store",partialize:state=>({connections:{__type:"Map",value:Array.from(state.connections.entries()).map((([key,connection])=>{const{id:id,name:name,type:type,uid:uid}=connection.connector,connector={id:id,name:name,type:type,uid:uid};return[key,{...connection,connector:connector}]}))},chainId:state.chainId,current:state.current}),skipHydration:ssr,storage:storage,version:currentVersion}):getInitialState));function change(data){store.setState((x=>{const connection=x.connections.get(data.uid);return connection?{...x,connections:new Map(x.connections).set(data.uid,{accounts:data.accounts??connection.accounts,chainId:data.chainId??connection.chainId,connector:connection.connector})}:x}))}function connect(data){"connecting"!==store.getState().status&&"reconnecting"!==store.getState().status&&store.setState((x=>{const connector=connectors.getState().find((x=>x.uid===data.uid));return connector?(connector.emitter.listenerCount("connect")&&connector.emitter.off("connect",change),connector.emitter.listenerCount("change")||connector.emitter.on("change",change),connector.emitter.listenerCount("disconnect")||connector.emitter.on("disconnect",disconnect),{...x,connections:new Map(x.connections).set(data.uid,{accounts:data.accounts,chainId:data.chainId,connector:connector}),current:data.uid,status:"connected"}):x}))}function disconnect(data){store.setState((x=>{const connection=x.connections.get(data.uid);if(connection){const connector=connection.connector;connector.emitter.listenerCount("change")&&connection.connector.emitter.off("change",change),connector.emitter.listenerCount("disconnect")&&connection.connector.emitter.off("disconnect",disconnect),connector.emitter.listenerCount("connect")||connection.connector.emitter.on("connect",connect)}if(x.connections.delete(data.uid),0===x.connections.size)return{...x,connections:new Map,current:null,status:"disconnected"};const nextConnection=x.connections.values().next().value;return{...x,connections:new Map(x.connections),current:nextConnection.connector.uid}}))}return syncConnectedChain&&store.subscribe((({connections:connections,current:current})=>current?connections.get(current)?.chainId:void 0),(chainId=>{if(chains.getState().some((x=>x.id===chainId)))return store.setState((x=>({...x,chainId:chainId??x.chainId})))})),mipd?.subscribe((providerDetails=>{const currentConnectorIds=new Map;for(const connector of connectors.getState())currentConnectorIds.set(connector.id,!0);const newConnectors=[];for(const providerDetail of providerDetails){const connector=setup(providerDetailToConnector(providerDetail));currentConnectorIds.has(connector.id)||newConnectors.push(connector)}storage&&!store.persist.hasHydrated()||connectors.setState((x=>[...x,...newConnectors]),!0)})),{get chains(){return chains.getState()},get connectors(){return connectors.getState()},storage:storage,getClient:function(config={}){const chainId=config.chainId??store.getState().chainId,chain=chains.getState().find((x=>x.id===chainId));if(config.chainId&&!chain)throw new ChainNotConfiguredError;{const client=clients.get(store.getState().chainId);if(client&&!chain)return client;if(!chain)throw new ChainNotConfiguredError}{const client=clients.get(chainId);if(client)return client}let client;if(rest.client)client=rest.client({chain:chain});else{const chainId=chain.id,chainIds=chains.getState().map((x=>x.id)),properties={},entries=Object.entries(rest);for(const[key,value]of entries)if("chains"!==key&&"client"!==key&&"connectors"!==key&&"transports"!==key)if("object"==typeof value)if(chainId in value)properties[key]=value[chainId];else{if(chainIds.some((x=>x in value)))continue;properties[key]=value}else properties[key]=value;client=createClient({...properties,chain:chain,batch:properties.batch??{multicall:!0},transport:parameters=>rest.transports[chainId]({...parameters,connectors:connectors})})}return clients.set(chainId,client),client},get state(){return store.getState()},setState(value){let newState;newState="function"==typeof value?value(store.getState()):value;const initialState=getInitialState();"object"!=typeof newState&&(newState=initialState);Object.keys(initialState).some((x=>!(x in newState)))&&(newState=initialState),store.setState(newState,!0)},subscribe:(selector,listener,options)=>store.subscribe(selector,listener,options?{...options,fireImmediately:options.emitImmediately}:void 0),_internal:{mipd:mipd,store:store,ssr:Boolean(ssr),syncConnectedChain:syncConnectedChain,transports:rest.transports,chains:{setState(value){const nextChains="function"==typeof value?value(chains.getState()):value;if(0!==nextChains.length)return chains.setState(nextChains,!0)},subscribe:listener=>chains.subscribe(listener)},connectors:{providerDetailToConnector:providerDetailToConnector,setup:setup,setState:value=>connectors.setState("function"==typeof value?value(connectors.getState()):value,!0),subscribe:listener=>connectors.subscribe(listener)},events:{change:change,connect:connect,disconnect:disconnect}}}}