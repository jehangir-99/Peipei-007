import{ProviderRpcError,ResourceUnavailableRpcError,RpcError,SwitchChainError,UserRejectedRequestError,getAddress,numberToHex,withRetry,withTimeout}from"viem";import{ChainNotConfiguredError}from"../errors/config.js";import{ProviderNotFoundError}from"../errors/connector.js";import{}from"../types/utils.js";import{createConnector}from"./createConnector.js";const supportsSimulationIdRegex=/(rabby|trustwallet)/,targetMap={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider:window=>window?.coinbaseWalletExtension?window.coinbaseWalletExtension:findProvider(window,"isCoinbaseWallet")},metaMask:{id:"metaMask",name:"MetaMask",provider:window=>findProvider(window,(provider=>{if(!provider.isMetaMask)return!1;if(provider.isBraveWallet&&!provider._events&&!provider._state)return!1;const flags=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isRabby","isTokenPocket","isTokenary","isZerion"];for(const flag of flags)if(provider[flag])return!1;return!0}))},phantom:{id:"phantom",name:"Phantom",provider:window=>window?.phantom?.ethereum?window.phantom?.ethereum:findProvider(window,"isPhantom")}};injected.type="injected";export function injected(parameters={}){const{shimDisconnect:shimDisconnect=!0,unstable_shimAsyncInject:unstable_shimAsyncInject}=parameters;function getTarget(){const target=parameters.target;if("function"==typeof target){const result=target();if(result)return result}return"object"==typeof target?target:"string"==typeof target?{...targetMap[target]??{id:target,name:`${target[0].toUpperCase()}${target.slice(1)}`,provider:`is${target[0].toUpperCase()}${target.slice(1)}`}}:{id:"injected",name:"Injected",provider:window=>window?.ethereum}}let accountsChanged,chainChanged,connect,disconnect;return createConnector((config=>({get icon(){return getTarget().icon},get id(){return getTarget().id},get name(){return getTarget().name},get supportsSimulation(){return supportsSimulationIdRegex.test(this.id.toLowerCase())},type:injected.type,async setup(){const provider=await this.getProvider();provider&&parameters.target&&(connect||(connect=this.onConnect.bind(this),provider.on("connect",connect)),accountsChanged||(accountsChanged=this.onAccountsChanged.bind(this),provider.on("accountsChanged",accountsChanged)))},async connect({chainId:chainId,isReconnecting:isReconnecting}={}){const provider=await this.getProvider();if(!provider)throw new ProviderNotFoundError;let accounts=[];if(isReconnecting)accounts=await this.getAccounts().catch((()=>[]));else if(shimDisconnect)try{const permissions=await provider.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]});accounts=permissions[0]?.caveats?.[0]?.value?.map((x=>getAddress(x)))}catch(err){const error=err;if(error.code===UserRejectedRequestError.code)throw new UserRejectedRequestError(error);if(error.code===ResourceUnavailableRpcError.code)throw error}try{if(!accounts?.length&&!isReconnecting){accounts=(await provider.request({method:"eth_requestAccounts"})).map((x=>getAddress(x)))}connect&&(provider.removeListener("connect",connect),connect=void 0),accountsChanged||(accountsChanged=this.onAccountsChanged.bind(this),provider.on("accountsChanged",accountsChanged)),chainChanged||(chainChanged=this.onChainChanged.bind(this),provider.on("chainChanged",chainChanged)),disconnect||(disconnect=this.onDisconnect.bind(this),provider.on("disconnect",disconnect));let currentChainId=await this.getChainId();if(chainId&&currentChainId!==chainId){const chain=await this.switchChain({chainId:chainId}).catch((error=>{if(error.code===UserRejectedRequestError.code)throw error;return{id:currentChainId}}));currentChainId=chain?.id??currentChainId}return shimDisconnect&&await(config.storage?.removeItem(`${this.id}.disconnected`)),parameters.target||await(config.storage?.setItem("injected.connected",!0)),{accounts:accounts,chainId:currentChainId}}catch(err){const error=err;if(error.code===UserRejectedRequestError.code)throw new UserRejectedRequestError(error);if(error.code===ResourceUnavailableRpcError.code)throw new ResourceUnavailableRpcError(error);throw error}},async disconnect(){const provider=await this.getProvider();if(!provider)throw new ProviderNotFoundError;chainChanged&&(provider.removeListener("chainChanged",chainChanged),chainChanged=void 0),disconnect&&(provider.removeListener("disconnect",disconnect),disconnect=void 0),connect||(connect=this.onConnect.bind(this),provider.on("connect",connect));try{await provider.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}shimDisconnect&&await(config.storage?.setItem(`${this.id}.disconnected`,!0)),parameters.target||await(config.storage?.removeItem("injected.connected"))},async getAccounts(){const provider=await this.getProvider();if(!provider)throw new ProviderNotFoundError;return(await provider.request({method:"eth_accounts"})).map((x=>getAddress(x)))},async getChainId(){const provider=await this.getProvider();if(!provider)throw new ProviderNotFoundError;const hexChainId=await provider.request({method:"eth_chainId"});return Number(hexChainId)},async getProvider(){if("undefined"==typeof window)return;let provider;const target=getTarget();return provider="function"==typeof target.provider?target.provider(window):"string"==typeof target.provider?findProvider(window,target.provider):target.provider,provider&&!provider.removeListener&&("off"in provider&&"function"==typeof provider.off?provider.removeListener=provider.off:provider.removeListener=()=>{}),provider},async isAuthorized(){try{if(shimDisconnect&&await(config.storage?.getItem(`${this.id}.disconnected`)))return!1;if(!parameters.target){if(!await(config.storage?.getItem("injected.connected")))return!1}if(!await this.getProvider()){if(void 0!==unstable_shimAsyncInject&&!1!==unstable_shimAsyncInject){const handleEthereum=async()=>{"undefined"!=typeof window&&window.removeEventListener("ethereum#initialized",handleEthereum);return!!await this.getProvider()},timeout="number"==typeof unstable_shimAsyncInject?unstable_shimAsyncInject:1e3;if(await Promise.race([..."undefined"!=typeof window?[new Promise((resolve=>window.addEventListener("ethereum#initialized",(()=>resolve(handleEthereum())),{once:!0})))]:[],new Promise((resolve=>setTimeout((()=>resolve(handleEthereum())),timeout)))]))return!0}throw new ProviderNotFoundError}return!!(await withRetry((()=>withTimeout((()=>this.getAccounts()),{timeout:100})))).length}catch{return!1}},async switchChain({addEthereumChainParameter:addEthereumChainParameter,chainId:chainId}){const provider=await this.getProvider();if(!provider)throw new ProviderNotFoundError;const chain=config.chains.find((x=>x.id===chainId));if(!chain)throw new SwitchChainError(new ChainNotConfiguredError);try{return await Promise.all([provider.request({method:"wallet_switchEthereumChain",params:[{chainId:numberToHex(chainId)}]}).then((async()=>{await this.getChainId()===chainId&&config.emitter.emit("change",{chainId:chainId})})),new Promise((resolve=>config.emitter.once("change",(({chainId:currentChainId})=>{currentChainId===chainId&&resolve()}))))]),chain}catch(err){const error=err;if(4902===error.code||4902===error?.data?.originalError?.code)try{const{default:blockExplorer,...blockExplorers}=chain.blockExplorers??{};let blockExplorerUrls,rpcUrls;addEthereumChainParameter?.blockExplorerUrls?blockExplorerUrls=addEthereumChainParameter.blockExplorerUrls:blockExplorer&&(blockExplorerUrls=[blockExplorer.url,...Object.values(blockExplorers).map((x=>x.url))]),rpcUrls=addEthereumChainParameter?.rpcUrls?.length?addEthereumChainParameter.rpcUrls:[chain.rpcUrls.default?.http[0]??""];const addEthereumChain={blockExplorerUrls:blockExplorerUrls,chainId:numberToHex(chainId),chainName:addEthereumChainParameter?.chainName??chain.name,iconUrls:addEthereumChainParameter?.iconUrls,nativeCurrency:addEthereumChainParameter?.nativeCurrency??chain.nativeCurrency,rpcUrls:rpcUrls};await provider.request({method:"wallet_addEthereumChain",params:[addEthereumChain]});if(await this.getChainId()!==chainId)throw new UserRejectedRequestError(new Error("User rejected switch after adding network."));return chain}catch(error){throw new UserRejectedRequestError(error)}if(error.code===UserRejectedRequestError.code)throw new UserRejectedRequestError(error);throw new SwitchChainError(error)}},async onAccountsChanged(accounts){if(0===accounts.length)this.onDisconnect();else if(config.emitter.listenerCount("connect")){const chainId=(await this.getChainId()).toString();this.onConnect({chainId:chainId}),shimDisconnect&&await(config.storage?.removeItem(`${this.id}.disconnected`))}else config.emitter.emit("change",{accounts:accounts.map((x=>getAddress(x)))})},onChainChanged(chain){const chainId=Number(chain);config.emitter.emit("change",{chainId:chainId})},async onConnect(connectInfo){const accounts=await this.getAccounts();if(0===accounts.length)return;const chainId=Number(connectInfo.chainId);config.emitter.emit("connect",{accounts:accounts,chainId:chainId});const provider=await this.getProvider();provider&&(connect&&(provider.removeListener("connect",connect),connect=void 0),accountsChanged||(accountsChanged=this.onAccountsChanged.bind(this),provider.on("accountsChanged",accountsChanged)),chainChanged||(chainChanged=this.onChainChanged.bind(this),provider.on("chainChanged",chainChanged)),disconnect||(disconnect=this.onDisconnect.bind(this),provider.on("disconnect",disconnect)))},async onDisconnect(error){const provider=await this.getProvider();error&&1013===error.code&&provider&&(await this.getAccounts()).length||(config.emitter.emit("disconnect"),provider&&(chainChanged&&(provider.removeListener("chainChanged",chainChanged),chainChanged=void 0),disconnect&&(provider.removeListener("disconnect",disconnect),disconnect=void 0),connect||(connect=this.onConnect.bind(this),provider.on("connect",connect))))}})))}function findProvider(window,select){function isProvider(provider){return"function"==typeof select?select(provider):"string"!=typeof select||provider[select]}const ethereum=window.ethereum;return ethereum?.providers?ethereum.providers.find((provider=>isProvider(provider))):ethereum&&isProvider(ethereum)?ethereum:void 0}