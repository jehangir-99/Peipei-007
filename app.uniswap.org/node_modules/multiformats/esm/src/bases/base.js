import basex from"../../vendor/base-x.js";import{coerce}from"../bytes.js";class Encoder{constructor(name,prefix,baseEncode){this.name=name,this.prefix=prefix,this.baseEncode=baseEncode}encode(bytes){if(bytes instanceof Uint8Array)return`${this.prefix}${this.baseEncode(bytes)}`;throw Error("Unknown type, must be binary type")}}class Decoder{constructor(name,prefix,baseDecode){this.name=name,this.prefix=prefix,this.baseDecode=baseDecode}decode(text){if("string"==typeof text){if(text[0]===this.prefix)return this.baseDecode(text.slice(1));throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)}throw Error("Can only multibase decode strings")}or(decoder){const decoders={[this.prefix]:this,...decoder.decoders||{[decoder.prefix]:decoder}};return new ComposedDecoder(decoders)}}class ComposedDecoder{constructor(decoders){this.decoders=decoders}or(decoder){const other=decoder.decoders||{[decoder.prefix]:decoder};return new ComposedDecoder({...this.decoders,...other})}decode(input){const prefix=input[0],decoder=this.decoders[prefix];if(decoder)return decoder.decode(input);throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}export class Codec{constructor(name,prefix,baseEncode,baseDecode){this.name=name,this.prefix=prefix,this.baseEncode=baseEncode,this.baseDecode=baseDecode,this.encoder=new Encoder(name,prefix,baseEncode),this.decoder=new Decoder(name,prefix,baseDecode)}encode(input){return this.encoder.encode(input)}decode(input){return this.decoder.decode(input)}}export const from=({name:name,prefix:prefix,encode:encode,decode:decode})=>new Codec(name,prefix,encode,decode);export const baseX=({prefix:prefix,name:name,alphabet:alphabet})=>{const{encode:encode,decode:decode}=basex(alphabet,name);return from({prefix:prefix,name:name,encode:encode,decode:text=>coerce(decode(text))})};const decode=(string,alphabet,bitsPerChar,name)=>{const codes={};for(let i=0;i<alphabet.length;++i)codes[alphabet[i]]=i;let end=string.length;for(;"="===string[end-1];)--end;const out=new Uint8Array(end*bitsPerChar/8|0);let bits=0,buffer=0,written=0;for(let i=0;i<end;++i){const value=codes[string[i]];if(void 0===value)throw new SyntaxError(`Non-${name} character`);buffer=buffer<<bitsPerChar|value,bits+=bitsPerChar,bits>=8&&(bits-=8,out[written++]=255&buffer>>bits)}if(bits>=bitsPerChar||255&buffer<<8-bits)throw new SyntaxError("Unexpected end of data");return out},encode=(data,alphabet,bitsPerChar)=>{const pad="="===alphabet[alphabet.length-1],mask=(1<<bitsPerChar)-1;let out="",bits=0,buffer=0;for(let i=0;i<data.length;++i)for(buffer=buffer<<8|data[i],bits+=8;bits>bitsPerChar;)bits-=bitsPerChar,out+=alphabet[mask&buffer>>bits];if(bits&&(out+=alphabet[mask&buffer<<bitsPerChar-bits]),pad)for(;out.length*bitsPerChar&7;)out+="=";return out};export const rfc4648=({name:name,prefix:prefix,bitsPerChar:bitsPerChar,alphabet:alphabet})=>from({prefix:prefix,name:name,encode:input=>encode(input,alphabet,bitsPerChar),decode:input=>decode(input,alphabet,bitsPerChar,name)});