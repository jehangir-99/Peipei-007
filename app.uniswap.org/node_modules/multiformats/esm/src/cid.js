import*as varint from"./varint.js";import*as Digest from"./hashes/digest.js";import{base58btc}from"./bases/base58.js";import{base32}from"./bases/base32.js";import{coerce}from"./bytes.js";export class CID{constructor(version,code,multihash,bytes){this.code=code,this.version=version,this.multihash=multihash,this.bytes=bytes,this.byteOffset=bytes.byteOffset,this.byteLength=bytes.byteLength,this.asCID=this,this._baseCache=new Map,Object.defineProperties(this,{byteOffset:hidden,byteLength:hidden,code:readonly,version:readonly,multihash:readonly,bytes:readonly,_baseCache:hidden,asCID:hidden})}toV0(){if(0===this.version)return this;{const{code:code,multihash:multihash}=this;if(code!==DAG_PB_CODE)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(multihash.code!==SHA_256_CODE)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID.createV0(multihash)}}toV1(){switch(this.version){case 0:{const{code:code,digest:digest}=this.multihash,multihash=Digest.create(code,digest);return CID.createV1(this.code,multihash)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}equals(other){return other&&this.code===other.code&&this.version===other.version&&Digest.equals(this.multihash,other.multihash)}toString(base){const{bytes:bytes,version:version,_baseCache:_baseCache}=this;return 0===version?toStringV0(bytes,_baseCache,base||base58btc.encoder):toStringV1(bytes,_baseCache,base||base32.encoder)}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID("+this.toString()+")"}static isCID(value){return deprecate(/^0\.0/,IS_CID_DEPRECATION),!(!value||!value[cidSymbol]&&value.asCID!==value)}get toBaseEncodedString(){throw new Error("Deprecated, use .toString()")}get codec(){throw new Error('"codec" property is deprecated, use integer "code" property instead')}get buffer(){throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")}get multibaseName(){throw new Error('"multibaseName" property is deprecated')}get prefix(){throw new Error('"prefix" property is deprecated')}static asCID(value){if(value instanceof CID)return value;if(null!=value&&value.asCID===value){const{version:version,code:code,multihash:multihash,bytes:bytes}=value;return new CID(version,code,multihash,bytes||encodeCID(version,code,multihash.bytes))}if(null!=value&&!0===value[cidSymbol]){const{version:version,multihash:multihash,code:code}=value,digest=Digest.decode(multihash);return CID.create(version,code,digest)}return null}static create(version,code,digest){if("number"!=typeof code)throw new Error("String codecs are no longer supported");switch(version){case 0:if(code!==DAG_PB_CODE)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);return new CID(version,code,digest,digest.bytes);case 1:{const bytes=encodeCID(version,code,digest.bytes);return new CID(version,code,digest,bytes)}default:throw new Error("Invalid version")}}static createV0(digest){return CID.create(0,DAG_PB_CODE,digest)}static createV1(code,digest){return CID.create(1,code,digest)}static decode(bytes){const[cid,remainder]=CID.decodeFirst(bytes);if(remainder.length)throw new Error("Incorrect length");return cid}static decodeFirst(bytes){const specs=CID.inspectBytes(bytes),prefixSize=specs.size-specs.multihashSize,multihashBytes=coerce(bytes.subarray(prefixSize,prefixSize+specs.multihashSize));if(multihashBytes.byteLength!==specs.multihashSize)throw new Error("Incorrect length");const digestBytes=multihashBytes.subarray(specs.multihashSize-specs.digestSize),digest=new Digest.Digest(specs.multihashCode,specs.digestSize,digestBytes,multihashBytes);return[0===specs.version?CID.createV0(digest):CID.createV1(specs.codec,digest),bytes.subarray(specs.size)]}static inspectBytes(initialBytes){let offset=0;const next=()=>{const[i,length]=varint.decode(initialBytes.subarray(offset));return offset+=length,i};let version=next(),codec=DAG_PB_CODE;if(18===version?(version=0,offset=0):1===version&&(codec=next()),0!==version&&1!==version)throw new RangeError(`Invalid CID version ${version}`);const prefixSize=offset,multihashCode=next(),digestSize=next(),size=offset+digestSize;return{version:version,codec:codec,multihashCode:multihashCode,digestSize:digestSize,multihashSize:size-prefixSize,size:size}}static parse(source,base){const[prefix,bytes]=parseCIDtoBytes(source,base),cid=CID.decode(bytes);return cid._baseCache.set(prefix,source),cid}}const parseCIDtoBytes=(source,base)=>{switch(source[0]){case"Q":{const decoder=base||base58btc;return[base58btc.prefix,decoder.decode(`${base58btc.prefix}${source}`)]}case base58btc.prefix:{const decoder=base||base58btc;return[base58btc.prefix,decoder.decode(source)]}case base32.prefix:{const decoder=base||base32;return[base32.prefix,decoder.decode(source)]}default:if(null==base)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[source[0],base.decode(source)]}},toStringV0=(bytes,cache,base)=>{const{prefix:prefix}=base;if(prefix!==base58btc.prefix)throw Error(`Cannot string encode V0 in ${base.name} encoding`);const cid=cache.get(prefix);if(null==cid){const cid=base.encode(bytes).slice(1);return cache.set(prefix,cid),cid}return cid},toStringV1=(bytes,cache,base)=>{const{prefix:prefix}=base,cid=cache.get(prefix);if(null==cid){const cid=base.encode(bytes);return cache.set(prefix,cid),cid}return cid},DAG_PB_CODE=112,SHA_256_CODE=18,encodeCID=(version,code,multihash)=>{const codeOffset=varint.encodingLength(version),hashOffset=codeOffset+varint.encodingLength(code),bytes=new Uint8Array(hashOffset+multihash.byteLength);return varint.encodeTo(version,bytes,0),varint.encodeTo(code,bytes,codeOffset),bytes.set(multihash,hashOffset),bytes},cidSymbol=Symbol.for("@ipld/js-cid/CID"),readonly={writable:!1,configurable:!1,enumerable:!0},hidden={writable:!1,enumerable:!1,configurable:!1},version="0.0.0-dev",deprecate=(range,message)=>{if(!range.test(version))throw new Error(message);console.warn(message)},IS_CID_DEPRECATION="CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n";