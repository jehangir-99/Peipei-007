"use strict";function _defineProperty(obj,key,value){return(key=_toPropertyKey(key))in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _toPropertyKey(arg){var key=_toPrimitive(arg,"string");return"symbol"==typeof key?key:String(key)}function _toPrimitive(input,hint){if("object"!=typeof input||null===input)return input;var prim=input[Symbol.toPrimitive];if(void 0!==prim){var res=prim.call(input,hint||"default");if("object"!=typeof res)return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===hint?String:Number)(input)}import{flattenArray}from"./utils";import{makeViewDescriptorsSet}from"../reanimated2/ViewDescriptorsSet";import{adaptViewConfig}from"../ConfigHelper";import updateProps from"../reanimated2/UpdateProps";import{stopMapper,startMapper}from"../reanimated2/mappers";import{isSharedValue}from"../reanimated2/isSharedValue";import{shouldBeUseWeb}from"../reanimated2/PlatformChecker";const SHOULD_BE_USE_WEB=shouldBeUseWeb();function isInlineStyleTransform(transform){return!!Array.isArray(transform)&&transform.some((t=>hasInlineStyles(t)))}function inlinePropsHasChanged(styles1,styles2){if(Object.keys(styles1).length!==Object.keys(styles2).length)return!0;for(const key of Object.keys(styles1))if(styles1[key]!==styles2[key])return!0;return!1}function getInlinePropsUpdate(inlineProps){const update={};for(const[key,styleValue]of Object.entries(inlineProps))isSharedValue(styleValue)?update[key]=styleValue.value:Array.isArray(styleValue)?update[key]=styleValue.map((item=>getInlinePropsUpdate(item))):update[key]="object"==typeof styleValue?getInlinePropsUpdate(styleValue):styleValue;return update}function extractSharedValuesMapFromProps(props){const inlineProps={};for(const key in props){const value=props[key];if("style"===key){flattenArray(props.style??[]).forEach((style=>{if(style)for(const[styleKey,styleValue]of Object.entries(style))(isSharedValue(styleValue)||"transform"===styleKey&&isInlineStyleTransform(styleValue))&&(inlineProps[styleKey]=styleValue)}))}else isSharedValue(value)&&(inlineProps[key]=value)}return inlineProps}export function hasInlineStyles(style){return!!style&&Object.keys(style).some((key=>{const styleValue=style[key];return isSharedValue(styleValue)||"transform"===key&&isInlineStyleTransform(styleValue)}))}export function getInlineStyle(style,isFirstRender){if(isFirstRender)return getInlinePropsUpdate(style);const newStyle={};for(const[key,styleValue]of Object.entries(style))isSharedValue(styleValue)||"transform"===key&&isInlineStyleTransform(styleValue)||(newStyle[key]=styleValue);return newStyle}export class InlinePropManager{constructor(){_defineProperty(this,"_inlinePropsViewDescriptors",null),_defineProperty(this,"_inlinePropsMapperId",null),_defineProperty(this,"_inlineProps",{})}attachInlineProps(animatedComponent,viewInfo){const newInlineProps=extractSharedValuesMapFromProps(animatedComponent.props);if(inlinePropsHasChanged(newInlineProps,this._inlineProps)){if(!this._inlinePropsViewDescriptors){this._inlinePropsViewDescriptors=makeViewDescriptorsSet();const{viewTag:viewTag,viewName:viewName,shadowNodeWrapper:shadowNodeWrapper,viewConfig:viewConfig}=viewInfo;Object.keys(newInlineProps).length&&viewConfig&&adaptViewConfig(viewConfig),this._inlinePropsViewDescriptors.add({tag:viewTag,name:viewName,shadowNodeWrapper:shadowNodeWrapper})}const shareableViewDescriptors=this._inlinePropsViewDescriptors.shareableViewDescriptors,maybeViewRef=SHOULD_BE_USE_WEB?{items:new Set([animatedComponent])}:void 0,updaterFunction=()=>{const update=getInlinePropsUpdate(newInlineProps);updateProps(shareableViewDescriptors,update,maybeViewRef)};this._inlineProps=newInlineProps,this._inlinePropsMapperId&&stopMapper(this._inlinePropsMapperId),this._inlinePropsMapperId=null,Object.keys(newInlineProps).length&&(this._inlinePropsMapperId=startMapper(updaterFunction,Object.values(newInlineProps)))}}detachInlineProps(){this._inlinePropsMapperId&&stopMapper(this._inlinePropsMapperId)}}