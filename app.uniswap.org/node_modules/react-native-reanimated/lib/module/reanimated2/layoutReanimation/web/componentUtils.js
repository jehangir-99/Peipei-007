"use strict";import{Animations,TransitionType,WebEasings}from"./config";import{convertTransformToString}from"./animationParser";import{TransitionGenerator}from"./createAnimation";import{scheduleAnimationCleanup}from"./domUtils";import{_updatePropsJS}from"../../js-reanimated";import{ReduceMotion}from"../../commonTypes";import{isReducedMotion}from"../../PlatformChecker";import{LayoutAnimationType}from"../animationBuilder/commonTypes";import{setDummyPosition,snapshots}from"./componentStyle";function getEasingFromConfig(config){const easingName=config.easingV&&config.easingV.name in WebEasings?config.easingV.name:"linear";return`cubic-bezier(${WebEasings[easingName].toString()})`}function getRandomDelay(){let maxDelay=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3;return Math.floor(Math.random()*(maxDelay+1))/1e3}function getDelayFromConfig(config){const shouldRandomizeDelay=config.randomizeDelay,delay=shouldRandomizeDelay?getRandomDelay():0;return config.delayV?shouldRandomizeDelay?getRandomDelay(config.delayV):config.delayV/1e3:delay}export function getReducedMotionFromConfig(config){if(!config.reduceMotionV)return isReducedMotion();switch(config.reduceMotionV){case ReduceMotion.Never:return!1;case ReduceMotion.Always:return!0;default:return isReducedMotion()}}function getDurationFromConfig(config,isLayoutTransition,animationName){const defaultDuration=isLayoutTransition?.3:Animations[animationName].duration;return void 0!==config.durationV?config.durationV/1e3:defaultDuration}function getCallbackFromConfig(config){return void 0!==config.callbackV?config.callbackV:null}function getReversedFromConfig(config){return!!config.reversed}export function extractTransformFromStyle(style){if(style){if("string"==typeof style.transform)throw new Error("[Reanimated] String transform is currently unsupported.");if(!Array.isArray(style))return style.transform;for(let i=style.length-1;i>=0;--i){var _style$i;if(null!==(_style$i=style[i])&&void 0!==_style$i&&_style$i.transform)return style[i].transform}}}export function getProcessedConfig(animationName,animationType,config,initialAnimationName){return{animationName:animationName,animationType:animationType,duration:getDurationFromConfig(config,animationType===LayoutAnimationType.LAYOUT,initialAnimationName),delay:getDelayFromConfig(config),easing:getEasingFromConfig(config),callback:getCallbackFromConfig(config),reversed:getReversedFromConfig(config)}}export function saveSnapshot(element){const rect=element.getBoundingClientRect(),snapshot={top:rect.top,left:rect.left,width:rect.width,height:rect.height,scrollOffsets:getElementScrollValue(element)};snapshots.set(element,snapshot)}export function setElementAnimation(element,animationConfig,existingTransform){const{animationName:animationName,duration:duration,delay:delay,easing:easing}=animationConfig;element.style.animationName=animationName,element.style.animationDuration=`${duration}s`,element.style.animationDelay=`${delay}s`,element.style.animationTimingFunction=easing,element.onanimationend=()=>{var _animationConfig$call;null===(_animationConfig$call=animationConfig.callback)||void 0===_animationConfig$call||_animationConfig$call.call(animationConfig,!0),element.removeEventListener("animationcancel",animationCancelHandler)};const animationCancelHandler=()=>{var _animationConfig$call2;null===(_animationConfig$call2=animationConfig.callback)||void 0===_animationConfig$call2||_animationConfig$call2.call(animationConfig,!1),element.removeEventListener("animationcancel",animationCancelHandler)};element.onanimationstart=()=>{animationConfig.animationType===LayoutAnimationType.ENTERING&&_updatePropsJS({visibility:"initial"},{_component:element}),element.addEventListener("animationcancel",animationCancelHandler),element.style.transform=convertTransformToString(existingTransform)},animationName in Animations||scheduleAnimationCleanup(animationName,duration+delay)}export function handleLayoutTransition(element,animationConfig,transitionData,existingTransform){const{animationName:animationName}=animationConfig;let animationType;switch(animationName){case"LinearTransition":default:animationType=TransitionType.LINEAR;break;case"SequencedTransition":animationType=TransitionType.SEQUENCED;break;case"FadingTransition":animationType=TransitionType.FADING}animationConfig.animationName=TransitionGenerator(animationType,transitionData,existingTransform);const transformCopy=existingTransform?structuredClone(existingTransform):[];transformCopy.push(transitionData),element.style.transform=convertTransformToString(transformCopy),setElementAnimation(element,animationConfig,existingTransform)}function getElementScrollValue(element){let current=element;const scrollOffsets={scrollTopOffset:0,scrollLeftOffset:0};for(;current;)0!==current.scrollTop&&0===scrollOffsets.scrollTopOffset&&(scrollOffsets.scrollTopOffset=current.scrollTop),0!==current.scrollLeft&&0===scrollOffsets.scrollLeftOffset&&(scrollOffsets.scrollLeftOffset=current.scrollLeft),current=current.parentElement;return scrollOffsets}export function handleExitingAnimation(element,animationConfig){const parent=element.offsetParent,dummy=element.cloneNode();for(dummy.reanimatedDummy=!0,element.style.animationName="",element.style.visibility="hidden";element.firstChild;)dummy.appendChild(element.firstChild);setElementAnimation(dummy,animationConfig),null==parent||parent.appendChild(dummy);const snapshot=snapshots.get(element),scrollOffsets=getElementScrollValue(element),currentScrollTopOffset=scrollOffsets.scrollTopOffset,lastScrollTopOffset=snapshot.scrollOffsets.scrollTopOffset;currentScrollTopOffset!==lastScrollTopOffset&&(snapshot.top+=lastScrollTopOffset-currentScrollTopOffset);const currentScrollLeftOffset=scrollOffsets.scrollLeftOffset,lastScrollLeftOffset=snapshot.scrollOffsets.scrollLeftOffset;currentScrollLeftOffset!==lastScrollLeftOffset&&(snapshot.left+=lastScrollLeftOffset-currentScrollLeftOffset),snapshots.set(dummy,snapshot),setDummyPosition(dummy,snapshot);const originalOnAnimationEnd=dummy.onanimationend;dummy.onanimationend=function(event){null!=parent&&parent.contains(dummy)&&(dummy.removedAfterAnimation=!0,parent.removeChild(dummy)),null==originalOnAnimationEnd||originalOnAnimationEnd.call(this,event)},dummy.addEventListener("animationcancel",(()=>{null!=parent&&parent.contains(dummy)&&(dummy.removedAfterAnimation=!0,parent.removeChild(dummy))}))}