"use strict";function _defineProperty(obj,key,value){return(key=_toPropertyKey(key))in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _toPropertyKey(arg){var key=_toPrimitive(arg,"string");return"symbol"==typeof key?key:String(key)}function _toPrimitive(input,hint){if("object"!=typeof input||null===input)return input;var prim=input[Symbol.toPrimitive];if(void 0!==prim){var res=prim.call(input,hint||"default");if("object"!=typeof res)return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===hint?String:Number)(input)}import{BaseAnimationBuilder}from"../animationBuilder";import{withSequence,withTiming}from"../../animation";import{FadeIn,FadeOut}from"../defaultAnimations/Fade";export class EntryExitTransition extends BaseAnimationBuilder{constructor(){super(...arguments),_defineProperty(this,"enteringV",FadeIn),_defineProperty(this,"exitingV",FadeOut),_defineProperty(this,"build",(()=>{const delayFunction=this.getDelayFunction(),callback=this.callbackV,delay=this.getDelay(),enteringAnimation=this.enteringV.build(),exitingAnimation=this.exitingV.build(),exitingDuration=this.exitingV.getDuration();return values=>{const enteringValues=enteringAnimation(values),exitingValues=exitingAnimation(values),animations={transform:[]};for(const prop of Object.keys(exitingValues.animations))if("transform"===prop){if(!Array.isArray(exitingValues.animations.transform))continue;exitingValues.animations.transform.forEach(((value,index)=>{for(const transformProp of Object.keys(value))animations.transform.push({[transformProp]:delayFunction(delay,withSequence(value[transformProp],withTiming(exitingValues.initialValues.transform?exitingValues.initialValues.transform[index][transformProp]:0,{duration:0})))})}))}else{const sequence=void 0!==enteringValues.animations[prop]?[exitingValues.animations[prop],withTiming(enteringValues.initialValues[prop],{duration:0}),enteringValues.animations[prop]]:[exitingValues.animations[prop],withTiming(Object.keys(values).includes(prop)?values[prop]:exitingValues.initialValues[prop],{duration:0})];animations[prop]=delayFunction(delay,withSequence(...sequence))}for(const prop of Object.keys(enteringValues.animations))if("transform"===prop){if(!Array.isArray(enteringValues.animations.transform))continue;enteringValues.animations.transform.forEach(((value,index)=>{for(const transformProp of Object.keys(value))animations.transform.push({[transformProp]:delayFunction(delay+exitingDuration,withSequence(withTiming(enteringValues.initialValues.transform?enteringValues.initialValues.transform[index][transformProp]:0,{duration:exitingDuration}),value[transformProp]))})}))}else{if(void 0!==animations[prop])continue;animations[prop]=delayFunction(delay,withSequence(withTiming(enteringValues.initialValues[prop],{duration:0}),enteringValues.animations[prop]))}const mergedTransform=(Array.isArray(exitingValues.initialValues.transform)?exitingValues.initialValues.transform:[]).concat((Array.isArray(enteringValues.animations.transform)?enteringValues.animations.transform:[]).map((value=>{const objectKeys=Object.keys(value);if((null==objectKeys?void 0:objectKeys.length)<1)return console.error("[Reanimated]: ${value} is not a valid Transform object"),value;const transformProp=objectKeys[0],current=value[transformProp].current;return"string"==typeof current?current.includes("deg")?{[transformProp]:"0deg"}:{[transformProp]:"0"}:transformProp.includes("translate")?{[transformProp]:0}:{[transformProp]:1}})));return{initialValues:{...exitingValues.initialValues,originX:values.currentOriginX,originY:values.currentOriginY,width:values.currentWidth,height:values.currentHeight,transform:mergedTransform},animations:{originX:delayFunction(delay+exitingDuration,withTiming(values.targetOriginX,{duration:exitingDuration})),originY:delayFunction(delay+exitingDuration,withTiming(values.targetOriginY,{duration:exitingDuration})),width:delayFunction(delay+exitingDuration,withTiming(values.targetWidth,{duration:exitingDuration})),height:delayFunction(delay+exitingDuration,withTiming(values.targetHeight,{duration:exitingDuration})),...animations},callback:callback}}}))}static createInstance(){return new EntryExitTransition}static entering(animation){return this.createInstance().entering(animation)}entering(animation){return this.enteringV=animation,this}static exiting(animation){return this.createInstance().exiting(animation)}exiting(animation){return this.exitingV=animation,this}}export function combineTransition(exiting,entering){return EntryExitTransition.entering(entering).exiting(exiting)}