"use strict";function _defineProperty(obj,key,value){return(key=_toPropertyKey(key))in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _toPropertyKey(arg){var key=_toPrimitive(arg,"string");return"symbol"==typeof key?key:String(key)}function _toPrimitive(input,hint){if("object"!=typeof input||null===input)return input;var prim=input[Symbol.toPrimitive];if(void 0!==prim){var res=prim.call(input,hint||"default");if("object"!=typeof res)return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===hint?String:Number)(input)}import{Easing}from"../../Easing";import{withDelay,withSequence,withTiming}from"../../animation";import{ReduceMotion}from"../../commonTypes";import{getReduceMotionFromConfig}from"../../animation/util";class InnerKeyframe{constructor(definitions){_defineProperty(this,"durationV",void 0),_defineProperty(this,"delayV",void 0),_defineProperty(this,"reduceMotionV",ReduceMotion.System),_defineProperty(this,"callbackV",void 0),_defineProperty(this,"definitions",void 0),_defineProperty(this,"build",(()=>{const delay=this.delayV,delayFunction=this.getDelayFunction(),{keyframes:keyframes,initialValues:initialValues}=this.parseDefinitions(),callback=this.callbackV;return()=>{const animations={},addAnimation=key=>{const keyframePoints=keyframes[key];if(0===keyframePoints.length)return;const animation=delayFunction(delay,1===keyframePoints.length?withTiming(keyframePoints[0].value,{duration:keyframePoints[0].duration,easing:keyframePoints[0].easing?keyframePoints[0].easing:Easing.linear}):withSequence(...keyframePoints.map((keyframePoint=>withTiming(keyframePoint.value,{duration:keyframePoint.duration,easing:keyframePoint.easing?keyframePoint.easing:Easing.linear})))));key.includes("transform")?("transform"in animations||(animations.transform=[]),animations.transform.push({[key.split(":")[1]]:animation})):animations[key]=animation};return Object.keys(initialValues).forEach((key=>{key.includes("transform")?initialValues[key].forEach(((transformProp,index)=>{Object.keys(transformProp).forEach((transformPropKey=>{addAnimation(makeKeyframeKey(index,transformPropKey))}))})):addAnimation(key)})),{animations:animations,initialValues:initialValues,callback:callback}}})),this.definitions=definitions}parseDefinitions(){const parsedKeyframes={};if(this.definitions.from){if(this.definitions[0])throw new Error("[Reanimated] You cannot provide both keyframe 0 and 'from' as they both specified initial values.");this.definitions[0]=this.definitions.from,delete this.definitions.from}if(this.definitions.to){if(this.definitions[100])throw new Error("[Reanimated] You cannot provide both keyframe 100 and 'to' as they both specified values at the end of the animation.");this.definitions[100]=this.definitions.to,delete this.definitions.to}if(!this.definitions[0])throw new Error("[Reanimated] Please provide 0 or 'from' keyframe with initial state of your object.");const initialValues=this.definitions[0];Object.keys(initialValues).forEach((styleProp=>{if("transform"===styleProp){if(!Array.isArray(initialValues.transform))return;initialValues.transform.forEach(((transformStyle,index)=>{Object.keys(transformStyle).forEach((transformProp=>{parsedKeyframes[makeKeyframeKey(index,transformProp)]=[]}))}))}else parsedKeyframes[styleProp]=[]}));const duration=this.durationV?this.durationV:500,animationKeyPoints=Array.from(Object.keys(this.definitions)),getAnimationDuration=(key,currentKeyPoint)=>currentKeyPoint/100*duration-parsedKeyframes[key].reduce(((acc,value)=>acc+value.duration),0);return animationKeyPoints.filter((value=>0!==parseInt(value))).sort(((a,b)=>parseInt(a)-parseInt(b))).forEach((keyPoint=>{if(parseInt(keyPoint)<0||parseInt(keyPoint)>100)throw new Error("[Reanimated] Keyframe should be in between range 0 - 100.");const keyframe=this.definitions[keyPoint],easing=keyframe.easing;delete keyframe.easing;const addKeyPointWith=(key,value)=>(_ref=>{let{key:key,value:value,currentKeyPoint:currentKeyPoint,easing:easing}=_ref;if(!(key in parsedKeyframes))throw new Error("[Reanimated] Keyframe can contain only that set of properties that were provide with initial values (keyframe 0 or 'from')");parsedKeyframes[key].push({duration:getAnimationDuration(key,currentKeyPoint),value:value,easing:easing})})({key:key,value:value,currentKeyPoint:parseInt(keyPoint),easing:easing});Object.keys(keyframe).forEach((key=>{if("transform"===key){if(!Array.isArray(keyframe.transform))return;keyframe.transform.forEach(((transformStyle,index)=>{Object.keys(transformStyle).forEach((transformProp=>{addKeyPointWith(makeKeyframeKey(index,transformProp),transformStyle[transformProp])}))}))}else addKeyPointWith(key,keyframe[key])}))})),{initialValues:initialValues,keyframes:parsedKeyframes}}duration(durationMs){return this.durationV=durationMs,this}delay(delayMs){return this.delayV=delayMs,this}withCallback(callback){return this.callbackV=callback,this}reduceMotion(reduceMotionV){return this.reduceMotionV=reduceMotionV,this}getDelayFunction(){const delay=this.delayV,reduceMotion=this.reduceMotionV;return delay?(delay,animation)=>withDelay(delay,animation,reduceMotion):(_,animation)=>(animation.reduceMotion=getReduceMotionFromConfig(reduceMotion),animation)}}function makeKeyframeKey(index,transformProp){return`${index}_transform:${transformProp}`}export const Keyframe=InnerKeyframe;