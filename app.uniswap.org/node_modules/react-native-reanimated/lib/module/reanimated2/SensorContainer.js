"use strict";function _defineProperty(obj,key,value){return(key=_toPropertyKey(key))in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _toPropertyKey(arg){var key=_toPrimitive(arg,"string");return"symbol"==typeof key?key:String(key)}function _toPrimitive(input,hint){if("object"!=typeof input||null===input)return input;var prim=input[Symbol.toPrimitive];if(void 0!==prim){var res=prim.call(input,hint||"default");if("object"!=typeof res)return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===hint?String:Number)(input)}import Sensor from"./Sensor";export class SensorContainer{constructor(){_defineProperty(this,"nativeSensors",new Map)}getSensorId(sensorType,config){return 100*sensorType+10*config.iosReferenceFrame+Number(config.adjustToInterfaceOrientation)}initializeSensor(sensorType,config){const sensorId=this.getSensorId(sensorType,config);if(!this.nativeSensors.has(sensorId)){const newSensor=new Sensor(sensorType,config);this.nativeSensors.set(sensorId,newSensor)}return this.nativeSensors.get(sensorId).getSharedValue()}registerSensor(sensorType,config,handler){const sensorId=this.getSensorId(sensorType,config);if(!this.nativeSensors.has(sensorId))return-1;const sensor=this.nativeSensors.get(sensorId);return sensor&&sensor.isAvailable()&&(sensor.isRunning()||sensor.register(handler))?(sensor.listenersNumber++,sensorId):-1}unregisterSensor(sensorId){if(this.nativeSensors.has(sensorId)){const sensor=this.nativeSensors.get(sensorId);sensor&&sensor.isRunning()&&(sensor.listenersNumber--,0===sensor.listenersNumber&&sensor.unregister())}}}