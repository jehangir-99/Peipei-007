"use strict";import{hsvToColor,RGBtoHSV,rgbaColor,processColor,red,green,blue,opacity}from"./Colors";import{makeMutable}from"./core";import{Extrapolation,interpolate}from"./interpolation";import{useSharedValue}from"./hook/useSharedValue";export const Extrapolate=Extrapolation;const interpolateColorsHSV=(value,inputRange,colors,options)=>{let h=0;const{useCorrectedHSVInterpolation:useCorrectedHSVInterpolation=!0}=options;if(useCorrectedHSVInterpolation){const correctedInputRange=[inputRange[0]],originalH=colors.h,correctedH=[originalH[0]];for(let i=1;i<originalH.length;++i){const d=originalH[i]-originalH[i-1];originalH[i]>originalH[i-1]&&d>.5?(correctedInputRange.push(inputRange[i]),correctedInputRange.push(inputRange[i]+1e-5),correctedH.push(originalH[i]-1),correctedH.push(originalH[i])):originalH[i]<originalH[i-1]&&d<-.5?(correctedInputRange.push(inputRange[i]),correctedInputRange.push(inputRange[i]+1e-5),correctedH.push(originalH[i]+1),correctedH.push(originalH[i])):(correctedInputRange.push(inputRange[i]),correctedH.push(originalH[i]))}h=(interpolate(value,correctedInputRange,correctedH,Extrapolation.CLAMP)+1)%1}else h=interpolate(value,inputRange,colors.h,Extrapolation.CLAMP);const s=interpolate(value,inputRange,colors.s,Extrapolation.CLAMP),v=interpolate(value,inputRange,colors.v,Extrapolation.CLAMP),a=interpolate(value,inputRange,colors.a,Extrapolation.CLAMP);return hsvToColor(h,s,v,a)},toLinearSpace=(x,gamma)=>x.map((v=>Math.pow(v/255,gamma))),toGammaSpace=(x,gamma)=>Math.round(255*Math.pow(x,1/gamma)),interpolateColorsRGB=(value,inputRange,colors,options)=>{const{gamma:gamma=2.2}=options;let{r:outputR,g:outputG,b:outputB}=colors;1!==gamma&&(outputR=toLinearSpace(outputR,gamma),outputG=toLinearSpace(outputG,gamma),outputB=toLinearSpace(outputB,gamma));const r=interpolate(value,inputRange,outputR,Extrapolation.CLAMP),g=interpolate(value,inputRange,outputG,Extrapolation.CLAMP),b=interpolate(value,inputRange,outputB,Extrapolation.CLAMP),a=interpolate(value,inputRange,colors.a,Extrapolation.CLAMP);return 1===gamma?rgbaColor(r,g,b,a):rgbaColor(toGammaSpace(r,gamma),toGammaSpace(g,gamma),toGammaSpace(b,gamma),a)},getInterpolateRGB=colors=>{const r=[],g=[],b=[],a=[];for(let i=0;i<colors.length;++i){const color=colors[i],processedColor=processColor(color);null!=processedColor&&(r.push(red(processedColor)),g.push(green(processedColor)),b.push(blue(processedColor)),a.push(opacity(processedColor)))}return{r:r,g:g,b:b,a:a}},getInterpolateHSV=colors=>{const h=[],s=[],v=[],a=[];for(let i=0;i<colors.length;++i){const color=colors[i],processedColor=processColor(color);if("number"==typeof processedColor){const processedHSVColor=RGBtoHSV(red(processedColor),green(processedColor),blue(processedColor));h.push(processedHSVColor.h),s.push(processedHSVColor.s),v.push(processedHSVColor.v),a.push(opacity(processedColor))}}return{h:h,s:s,v:v,a:a}};export function interpolateColor(value,inputRange,outputRange){let colorSpace=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"RGB",options=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};if("HSV"===colorSpace)return interpolateColorsHSV(value,inputRange,getInterpolateHSV(outputRange),options);if("RGB"===colorSpace)return interpolateColorsRGB(value,inputRange,getInterpolateRGB(outputRange),options);throw new Error(`[Reanimated] Invalid color space provided: ${colorSpace}. Supported values are: ['RGB', 'HSV'].`)}export let ColorSpace=function(ColorSpace){return ColorSpace[ColorSpace.RGB=0]="RGB",ColorSpace[ColorSpace.HSV=1]="HSV",ColorSpace}({});export function useInterpolateConfig(inputRange,outputRange){let colorSpace=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ColorSpace.RGB,options=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return useSharedValue({inputRange:inputRange,outputRange:outputRange,colorSpace:colorSpace,cache:makeMutable(null),options:options})}