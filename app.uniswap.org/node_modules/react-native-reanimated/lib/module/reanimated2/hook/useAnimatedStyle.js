"use strict";import{useEffect,useRef}from"react";import{makeShareable,startMapper,stopMapper}from"../core";import updateProps,{updatePropsJestWrapper}from"../UpdateProps";import{initialUpdaterRun}from"../animation";import{useSharedValue}from"./useSharedValue";import{buildWorkletsHash,isAnimated,shallowEqual,validateAnimatedStyles}from"./utils";import{makeViewDescriptorsSet,useViewRefSet}from"../ViewDescriptorsSet";import{isJest,shouldBeUseWeb}from"../PlatformChecker";import{isWorkletFunction}from"../commonTypes";const SHOULD_BE_USE_WEB=shouldBeUseWeb();function prepareAnimation(frameTimestamp,animatedProp,lastAnimation,lastValue){if(Array.isArray(animatedProp)&&animatedProp.forEach(((prop,index)=>{prepareAnimation(frameTimestamp,prop,lastAnimation&&lastAnimation[index],lastValue&&lastValue[index])})),"object"==typeof animatedProp&&animatedProp.onFrame){const animation=animatedProp;let value=animation.current;null!=lastValue&&("object"==typeof lastValue?void 0!==lastValue.value?value=lastValue.value:void 0!==lastValue.onFrame&&(void 0!==(null==lastAnimation?void 0:lastAnimation.current)?value=lastAnimation.current:void 0!==(null==lastValue?void 0:lastValue.current)&&(value=lastValue.current)):value=lastValue),animation.callStart=timestamp=>{animation.onStart(animation,value,timestamp,lastAnimation)},animation.callStart(frameTimestamp),animation.callStart=null}else"object"==typeof animatedProp&&Object.keys(animatedProp).forEach((key=>prepareAnimation(frameTimestamp,animatedProp[key],lastAnimation&&lastAnimation[key],lastValue&&lastValue[key])))}function runAnimations(animation,timestamp,key,result,animationsActive){if(!animationsActive.value)return!0;if(Array.isArray(animation)){result[key]=[];let allFinished=!0;return animation.forEach(((entry,index)=>{runAnimations(entry,timestamp,index,result[key],animationsActive)||(allFinished=!1)})),allFinished}if("object"==typeof animation&&animation.onFrame){let finished=!0;return animation.finished||(animation.callStart&&(animation.callStart(timestamp),animation.callStart=null),finished=animation.onFrame(animation,timestamp),animation.timestamp=timestamp,finished&&(animation.finished=!0,animation.callback&&animation.callback(!0))),result[key]=animation.current,finished}if("object"==typeof animation){result[key]={};let allFinished=!0;return Object.keys(animation).forEach((k=>{runAnimations(animation[k],timestamp,k,result[key],animationsActive)||(allFinished=!1)})),allFinished}return result[key]=animation,!0}function styleUpdater(viewDescriptors,updater,state,maybeViewRef,animationsActive){let isAnimatedProps=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const animations=state.animations??{},newValues=updater()??{},oldValues=state.last,nonAnimatedNewValues={};let frameTimestamp,hasAnimations=!1,hasNonAnimatedValues=!1;for(const key in newValues){const value=newValues[key];isAnimated(value)?(frameTimestamp=global.__frameTimestamp||global._getAnimationTimestamp(),prepareAnimation(frameTimestamp,value,animations[key],oldValues[key]),animations[key]=value,hasAnimations=!0):(hasNonAnimatedValues=!0,nonAnimatedNewValues[key]=value,delete animations[key])}if(hasAnimations){const frame=timestamp=>{const{animations:animations,last:last,isAnimationCancelled:isAnimationCancelled}=state;if(isAnimationCancelled)return void(state.isAnimationRunning=!1);const updates={};let allFinished=!0;for(const propName in animations){runAnimations(animations[propName],timestamp,propName,updates,animationsActive)?(last[propName]=updates[propName],delete animations[propName]):allFinished=!1}updates&&updateProps(viewDescriptors,updates,maybeViewRef),allFinished?state.isAnimationRunning=!1:requestAnimationFrame(frame)};state.animations=animations,state.isAnimationRunning||(state.isAnimationCancelled=!1,state.isAnimationRunning=!0,frame(frameTimestamp)),hasNonAnimatedValues&&updateProps(viewDescriptors,nonAnimatedNewValues,maybeViewRef)}else state.isAnimationCancelled=!0,state.animations=[],shallowEqual(oldValues,newValues)||updateProps(viewDescriptors,newValues,maybeViewRef,isAnimatedProps);state.last=newValues}function jestStyleUpdater(viewDescriptors,updater,state,maybeViewRef,animationsActive,animatedStyle,adapters){const animations=state.animations??{},newValues=updater()??{},oldValues=state.last;let frameTimestamp,hasAnimations=!1;Object.keys(animations).forEach((key=>{const value=newValues[key];isAnimated(value)||delete animations[key]})),Object.keys(newValues).forEach((key=>{const value=newValues[key];isAnimated(value)&&(frameTimestamp=global.__frameTimestamp||global._getAnimationTimestamp(),prepareAnimation(frameTimestamp,value,animations[key],oldValues[key]),animations[key]=value,hasAnimations=!0)})),hasAnimations?(state.animations=animations,state.isAnimationRunning||(state.isAnimationCancelled=!1,state.isAnimationRunning=!0,function frame(timestamp){const{animations:animations,last:last,isAnimationCancelled:isAnimationCancelled}=state;if(isAnimationCancelled)return void(state.isAnimationRunning=!1);const updates={};let allFinished=!0;Object.keys(animations).forEach((propName=>{runAnimations(animations[propName],timestamp,propName,updates,animationsActive)?(last[propName]=updates[propName],delete animations[propName]):allFinished=!1})),Object.keys(updates).length&&updatePropsJestWrapper(viewDescriptors,updates,maybeViewRef,animatedStyle,adapters),allFinished?state.isAnimationRunning=!1:requestAnimationFrame(frame)}(frameTimestamp))):(state.isAnimationCancelled=!0,state.animations=[]),state.last=newValues,shallowEqual(oldValues,newValues)||updatePropsJestWrapper(viewDescriptors,newValues,maybeViewRef,animatedStyle,adapters)}function checkSharedValueUsage(prop,currentKey){if(Array.isArray(prop))for(const element of prop)checkSharedValueUsage(element,currentKey);else if("object"==typeof prop&&null!==prop&&void 0===prop.value)for(const key of Object.keys(prop))checkSharedValueUsage(prop[key],key);else if(void 0!==currentKey&&"object"==typeof prop&&null!==prop&&void 0!==prop.value)throw new Error(`[Reanimated] Invalid value passed to \`${currentKey}\`, maybe you forgot to use \`.value\`?`)}export function useAnimatedStyle(updater,dependencies,adapters){let isAnimatedProps=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const viewsRef=useViewRefSet(),animatedUpdaterData=useRef();let inputs=Object.values(updater.__closure??{});var _dependencies;if(SHOULD_BE_USE_WEB&&(!inputs.length&&null!==(_dependencies=dependencies)&&void 0!==_dependencies&&_dependencies.length&&(inputs=dependencies),__DEV__&&!inputs.length&&!dependencies&&!isWorkletFunction(updater)))throw new Error("[Reanimated] `useAnimatedStyle` was used without a dependency array or Babel plugin. Please explicitly pass a dependency array, or enable the Babel plugin.\nFor more, see the docs: `https://docs.swmansion.com/react-native-reanimated/docs/guides/web-support#web-without-the-babel-plugin`.");const adaptersArray=adapters?Array.isArray(adapters)?adapters:[adapters]:[],adaptersHash=adapters?buildWorkletsHash(adaptersArray):null,areAnimationsActive=useSharedValue(!0),jestAnimatedStyle=useRef({});if(dependencies?dependencies.push(updater.__workletHash):dependencies=[...inputs,updater.__workletHash],adaptersHash&&dependencies.push(adaptersHash),!animatedUpdaterData.current){const initialStyle=initialUpdaterRun(updater);__DEV__&&validateAnimatedStyles(initialStyle),animatedUpdaterData.current={initial:{value:initialStyle,updater:updater},remoteState:makeShareable({last:initialStyle,animations:{},isAnimationCancelled:!1,isAnimationRunning:!1}),viewDescriptors:makeViewDescriptorsSet()}}const{initial:initial,remoteState:remoteState,viewDescriptors:viewDescriptors}=animatedUpdaterData.current,shareableViewDescriptors=viewDescriptors.shareableViewDescriptors;dependencies.push(shareableViewDescriptors),useEffect((()=>{let fun,updaterFn=updater;adapters&&(updaterFn=()=>{const newValues=updater();return adaptersArray.forEach((adapter=>{adapter(newValues)})),newValues}),fun=isJest()?()=>{jestStyleUpdater(shareableViewDescriptors,updater,remoteState,viewsRef,areAnimationsActive,jestAnimatedStyle,adaptersArray)}:()=>{styleUpdater(shareableViewDescriptors,updaterFn,remoteState,viewsRef,areAnimationsActive,isAnimatedProps)};const mapperId=startMapper(fun,inputs);return()=>{stopMapper(mapperId)}}),dependencies),useEffect((()=>(areAnimationsActive.value=!0,()=>{areAnimationsActive.value=!1})),[areAnimationsActive]),checkSharedValueUsage(initial.value);const animatedStyleHandle=useRef(null);return animatedStyleHandle.current||(animatedStyleHandle.current=isJest()?{viewDescriptors:viewDescriptors,initial:initial,viewsRef:viewsRef,jestAnimatedStyle:jestAnimatedStyle}:{initial:initial,viewsRef:viewsRef,viewDescriptors:viewDescriptors}),animatedStyleHandle.current}