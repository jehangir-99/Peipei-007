"use strict";import{isColor,convertToRGBA,rgbaArrayToRGBAColor,toGammaSpace,toLinearSpace}from"../Colors";import{ReduceMotion}from"../commonTypes";import{flatten,multiplyMatrices,scaleMatrix,addMatrices,decomposeMatrixIntoMatricesAndAngles,isAffineMatrixFlat,subtractMatrices,getRotationMatrix}from"./transformationMatrix/matrixUtils";import{isReducedMotion,shouldBeUseWeb}from"../PlatformChecker";let IN_STYLE_UPDATER=!1;const IS_REDUCED_MOTION=isReducedMotion();__DEV__&&IS_REDUCED_MOTION&&console.warn("[Reanimated] Reduced motion setting is enabled on this device. This warning is visible only in the development mode. Some animations will be disabled by default. You can override the behavior for individual animations, see https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#reduced-motion-setting-is-enabled-on-this-device.");export function initialUpdaterRun(updater){IN_STYLE_UPDATER=!0;const result=updater();return IN_STYLE_UPDATER=!1,result}export function recognizePrefixSuffix(value){if("string"==typeof value){const match=value.match(/([A-Za-z]*)(-?\d*\.?\d*)([eE][-+]?[0-9]+)?([A-Za-z%]*)/);if(!match)throw new Error("[Reanimated] Couldn't parse animation value.");const prefix=match[1],suffix=match[4],number=match[2]+(match[3]??"");return{prefix:prefix,suffix:suffix,strippedValue:parseFloat(number)}}return{strippedValue:value}}export function getReduceMotionFromConfig(config){return config&&config!==ReduceMotion.System?config===ReduceMotion.Always:IS_REDUCED_MOTION}export function getReduceMotionForAnimation(config){if(config)return getReduceMotionFromConfig(config)}function applyProgressToMatrix(progress,a,b){return addMatrices(a,scaleMatrix(subtractMatrices(b,a),progress))}function applyProgressToNumber(progress,a,b){return a+progress*(b-a)}function decorateAnimation(animation){const baseOnStart=animation.onStart,baseOnFrame=animation.onFrame;if(animation.isHigherOrder)return void(animation.onStart=(animation,value,timestamp,previousAnimation)=>(void 0===animation.reduceMotion&&(animation.reduceMotion=getReduceMotionFromConfig()),baseOnStart(animation,value,timestamp,previousAnimation)));const animationCopy=Object.assign({},animation);delete animationCopy.callback;const prefNumberSuffOnFrame=(animation,timestamp)=>{animation.current=animation.strippedCurrent;const res=baseOnFrame(animation,timestamp);return animation.strippedCurrent=animation.current,animation.current=(animation.__prefix??"")+animation.current+(animation.__suffix??""),res},tab=["R","G","B","A"],colorOnFrame=(animation,timestamp)=>{const RGBACurrent=toLinearSpace(convertToRGBA(animation.current)),res=[];let finished=!0;return tab.forEach(((i,index)=>{animation[i].current=RGBACurrent[index];const result=animation[i].onFrame(animation[i],timestamp);finished=finished&&result,res.push(animation[i].current)})),animation.current=rgbaArrayToRGBAColor(toGammaSpace(res)),finished},transformationMatrixOnFrame=(animation,timestamp)=>{let finished=!0;const result=animation[0].onFrame(animation[0],timestamp);finished=finished&&result;const progress=animation[0].current/100,mappedTransforms=[];["translationMatrix","scaleMatrix","skewMatrix"].forEach(((key,_)=>mappedTransforms.push(applyProgressToMatrix(progress,animation.startMatrices[key],animation.stopMatrices[key]))));const[currentTranslation,currentScale,skewMatrix]=mappedTransforms,mappedRotations=[];["x","y","z"].forEach(((key,_)=>{const angle=applyProgressToNumber(progress,animation.startMatrices["r"+key],animation.stopMatrices["r"+key]);mappedRotations.push(getRotationMatrix(angle,key))}));const[rotationMatrixX,rotationMatrixY,rotationMatrixZ]=mappedRotations,rotationMatrix=multiplyMatrices(rotationMatrixX,multiplyMatrices(rotationMatrixY,rotationMatrixZ)),updated=flatten(multiplyMatrices(multiplyMatrices(currentScale,multiplyMatrices(skewMatrix,rotationMatrix)),currentTranslation));return animation.current=updated,finished},arrayOnFrame=(animation,timestamp)=>{let finished=!0;return animation.current.forEach(((_,i)=>{const result=animation[i].onFrame(animation[i],timestamp);finished=finished&&result,animation.current[i]=animation[i].current})),finished},objectOnFrame=(animation,timestamp)=>{let finished=!0;const newObject={};for(const key in animation.current){const result=animation[key].onFrame(animation[key],timestamp);finished=finished&&result,newObject[key]=animation[key].current}return animation.current=newObject,finished};animation.onStart=(animation,value,timestamp,previousAnimation)=>(void 0===animation.reduceMotion&&(animation.reduceMotion=getReduceMotionFromConfig()),animation.reduceMotion?(void 0!==animation.toValue?animation.current=animation.toValue:baseOnStart(animation,value,timestamp,previousAnimation),animation.startTime=0,void(animation.onFrame=()=>!0)):isColor(value)?(((animation,value,timestamp,previousAnimation)=>{let RGBAValue,RGBACurrent,RGBAToValue;const res=[];isColor(value)&&(RGBACurrent=toLinearSpace(convertToRGBA(animation.current)),RGBAValue=toLinearSpace(convertToRGBA(value)),animation.toValue&&(RGBAToValue=toLinearSpace(convertToRGBA(animation.toValue)))),tab.forEach(((i,index)=>{animation[i]=Object.assign({},animationCopy),animation[i].current=RGBACurrent[index],animation[i].toValue=RGBAToValue?RGBAToValue[index]:void 0,animation[i].onStart(animation[i],RGBAValue[index],timestamp,previousAnimation?previousAnimation[i]:void 0),res.push(animation[i].current)})),animation.current=rgbaArrayToRGBAColor(toGammaSpace(res))})(animation,value,timestamp,previousAnimation),void(animation.onFrame=colorOnFrame)):isAffineMatrixFlat(value)?(((animation,value,timestamp,previousAnimation)=>{const toValue=animation.toValue;animation.startMatrices=decomposeMatrixIntoMatricesAndAngles(value),animation.stopMatrices=decomposeMatrixIntoMatricesAndAngles(toValue),animation[0]=Object.assign({},animationCopy),animation[0].current=0,animation[0].toValue=100,animation[0].onStart(animation[0],0,timestamp,previousAnimation?previousAnimation[0]:void 0),animation.current=value})(animation,value,timestamp,previousAnimation),void(animation.onFrame=transformationMatrixOnFrame)):Array.isArray(value)?(((animation,value,timestamp,previousAnimation)=>{value.forEach(((v,i)=>{animation[i]=Object.assign({},animationCopy),animation[i].current=v,animation[i].toValue=animation.toValue[i],animation[i].onStart(animation[i],v,timestamp,previousAnimation?previousAnimation[i]:void 0)})),animation.current=value})(animation,value,timestamp,previousAnimation),void(animation.onFrame=arrayOnFrame)):"string"==typeof value?(((animation,value,timestamp,previousAnimation)=>{const{prefix:prefix,suffix:suffix,strippedValue:strippedValue}=recognizePrefixSuffix(value);animation.__prefix=prefix,animation.__suffix=suffix,animation.strippedCurrent=strippedValue;const{strippedValue:strippedToValue}=recognizePrefixSuffix(animation.toValue);if(animation.current=strippedValue,animation.startValue=strippedValue,animation.toValue=strippedToValue,previousAnimation&&previousAnimation!==animation){const{prefix:paPrefix,suffix:paSuffix,strippedValue:paStrippedValue}=recognizePrefixSuffix(previousAnimation.current);previousAnimation.current=paStrippedValue,previousAnimation.__prefix=paPrefix,previousAnimation.__suffix=paSuffix}baseOnStart(animation,strippedValue,timestamp,previousAnimation),animation.current=(animation.__prefix??"")+animation.current+(animation.__suffix??""),previousAnimation&&previousAnimation!==animation&&(previousAnimation.current=(previousAnimation.__prefix??"")+previousAnimation.current+(previousAnimation.__suffix??""))})(animation,value,timestamp,previousAnimation),void(animation.onFrame=prefNumberSuffOnFrame)):"object"==typeof value&&null!==value?(((animation,value,timestamp,previousAnimation)=>{for(const key in value)animation[key]=Object.assign({},animationCopy),animation[key].onStart=animation.onStart,animation[key].current=value[key],animation[key].toValue=animation.toValue[key],animation[key].onStart(animation[key],value[key],timestamp,previousAnimation?previousAnimation[key]:void 0);animation.current=value})(animation,value,timestamp,previousAnimation),void(animation.onFrame=objectOnFrame)):void baseOnStart(animation,value,timestamp,previousAnimation))}const SHOULD_BE_USE_WEB=shouldBeUseWeb();export function defineAnimation(starting,factory){if(IN_STYLE_UPDATER)return starting;const create=()=>{const animation=factory();return decorateAnimation(animation),animation};return _WORKLET||SHOULD_BE_USE_WEB?create():create}export function cancelAnimation(sharedValue){sharedValue.value=sharedValue.value}