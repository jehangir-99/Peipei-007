"use strict";export function isAffineMatrixFlat(x){return Array.isArray(x)&&16===x.length&&x.every((element=>"number"==typeof element&&!isNaN(element)))}export function isAffineMatrix(x){return Array.isArray(x)&&4===x.length&&x.every((row=>Array.isArray(row)&&4===row.length&&row.every((element=>"number"==typeof element&&!isNaN(element)))))}export function flatten(matrix){return matrix.flat()}export function unflatten(m){return[[m[0],m[1],m[2],m[3]],[m[4],m[5],m[6],m[7]],[m[8],m[9],m[10],m[11]],[m[12],m[13],m[14],m[15]]]}function maybeFlattenMatrix(matrix){return isAffineMatrix(matrix)?flatten(matrix):matrix}export function multiplyMatrices(a,b){return[[a[0][0]*b[0][0]+a[0][1]*b[1][0]+a[0][2]*b[2][0]+a[0][3]*b[3][0],a[0][0]*b[0][1]+a[0][1]*b[1][1]+a[0][2]*b[2][1]+a[0][3]*b[3][1],a[0][0]*b[0][2]+a[0][1]*b[1][2]+a[0][2]*b[2][2]+a[0][3]*b[3][2],a[0][0]*b[0][3]+a[0][1]*b[1][3]+a[0][2]*b[2][3]+a[0][3]*b[3][3]],[a[1][0]*b[0][0]+a[1][1]*b[1][0]+a[1][2]*b[2][0]+a[1][3]*b[3][0],a[1][0]*b[0][1]+a[1][1]*b[1][1]+a[1][2]*b[2][1]+a[1][3]*b[3][1],a[1][0]*b[0][2]+a[1][1]*b[1][2]+a[1][2]*b[2][2]+a[1][3]*b[3][2],a[1][0]*b[0][3]+a[1][1]*b[1][3]+a[1][2]*b[2][3]+a[1][3]*b[3][3]],[a[2][0]*b[0][0]+a[2][1]*b[1][0]+a[2][2]*b[2][0]+a[2][3]*b[3][0],a[2][0]*b[0][1]+a[2][1]*b[1][1]+a[2][2]*b[2][1]+a[2][3]*b[3][1],a[2][0]*b[0][2]+a[2][1]*b[1][2]+a[2][2]*b[2][2]+a[2][3]*b[3][2],a[2][0]*b[0][3]+a[2][1]*b[1][3]+a[2][2]*b[2][3]+a[2][3]*b[3][3]],[a[3][0]*b[0][0]+a[3][1]*b[1][0]+a[3][2]*b[2][0]+a[3][3]*b[3][0],a[3][0]*b[0][1]+a[3][1]*b[1][1]+a[3][2]*b[2][1]+a[3][3]*b[3][1],a[3][0]*b[0][2]+a[3][1]*b[1][2]+a[3][2]*b[2][2]+a[3][3]*b[3][2],a[3][0]*b[0][3]+a[3][1]*b[1][3]+a[3][2]*b[2][3]+a[3][3]*b[3][3]]]}export function subtractMatrices(maybeFlatA,maybeFlatB){const isFlatOnStart=isAffineMatrixFlat(maybeFlatA),a=maybeFlattenMatrix(maybeFlatA),b=maybeFlattenMatrix(maybeFlatB),c=a.map(((_,i)=>a[i]-b[i]));return isFlatOnStart?c:unflatten(c)}export function addMatrices(maybeFlatA,maybeFlatB){const isFlatOnStart=isAffineMatrixFlat(maybeFlatA),a=maybeFlattenMatrix(maybeFlatA),b=maybeFlattenMatrix(maybeFlatB),c=a.map(((_,i)=>a[i]+b[i]));return isFlatOnStart?c:unflatten(c)}export function scaleMatrix(maybeFlatA,scalar){const isFlatOnStart=isAffineMatrixFlat(maybeFlatA),b=maybeFlattenMatrix(maybeFlatA).map((x=>x*scalar));return isFlatOnStart?b:unflatten(b)}export function getRotationMatrix(angle){let axis=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"z";const cos=Math.cos(angle),sin=Math.sin(angle);switch(axis){case"z":return[[cos,sin,0,0],[-sin,cos,0,0],[0,0,1,0],[0,0,0,1]];case"y":return[[cos,0,-sin,0],[0,1,0,0],[sin,0,cos,0],[0,0,0,1]];case"x":return[[1,0,0,0],[0,cos,sin,0],[0,-sin,cos,0],[0,0,0,1]]}}function norm3d(x,y,z){return Math.sqrt(x*x+y*y+z*z)}function transposeMatrix(matrix){const m=flatten(matrix);return[[m[0],m[4],m[8],m[12]],[m[1],m[5],m[9],m[13]],[m[2],m[6],m[10],m[14]],[m[3],m[7],m[11],m[15]]]}function assertVectorsHaveEqualLengths(a,b){if(__DEV__&&a.length!==b.length)throw new Error(`[Reanimated] Cannot calculate inner product of two vectors of different lengths. Length of ${a.toString()} is ${a.length} and length of ${b.toString()} is ${b.length}.`)}function innerProduct(a,b){return assertVectorsHaveEqualLengths(a,b),a.reduce(((acc,_,i)=>acc+a[i]*b[i]),0)}function projection(u,a){assertVectorsHaveEqualLengths(u,a);const s=innerProduct(u,a)/innerProduct(u,u);return u.map((e=>e*s))}function subtractVectors(a,b){return assertVectorsHaveEqualLengths(a,b),a.map(((_,i)=>a[i]-b[i]))}function scaleVector(u,a){return u.map((e=>e*a))}function gramSchmidtAlgorithm(matrix){const[a0,a1,a2,a3]=matrix,u0=a0,u1=subtractVectors(a1,projection(u0,a1)),u2=subtractVectors(subtractVectors(a2,projection(u0,a2)),projection(u1,a2)),u3=subtractVectors(subtractVectors(subtractVectors(a3,projection(u0,a3)),projection(u1,a3)),projection(u2,a3)),[e0,e1,e2,e3]=[u0,u1,u2,u3].map((u=>scaleVector(u,1/Math.sqrt(innerProduct(u,u))))),rotationMatrix=[[e0[0],e1[0],e2[0],e3[0]],[e0[1],e1[1],e2[1],e3[1]],[e0[2],e1[2],e2[2],e3[2]],[e0[3],e1[3],e2[3],e3[3]]],skewMatrix=[[innerProduct(e0,a0),innerProduct(e0,a1),innerProduct(e0,a2),innerProduct(e0,a3)],[0,innerProduct(e1,a1),innerProduct(e1,a2),innerProduct(e1,a3)],[0,0,innerProduct(e2,a2),innerProduct(e2,a3)],[0,0,0,innerProduct(e3,a3)]];return{rotationMatrix:transposeMatrix(rotationMatrix),skewMatrix:transposeMatrix(skewMatrix)}}export function decomposeMatrix(unknownTypeMatrix){const matrix=maybeFlattenMatrix(unknownTypeMatrix);if(0===matrix[15])throw new Error("[Reanimated] Invalid transform matrix.");matrix.forEach(((_,i)=>matrix[i]/=matrix[15]));const translationMatrix=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[matrix[12],matrix[13],matrix[14],1]],sx=matrix[15]*norm3d(matrix[0],matrix[4],matrix[8]),sy=matrix[15]*norm3d(matrix[1],matrix[5],matrix[9]),sz=matrix[15]*norm3d(matrix[2],matrix[6],matrix[10]),scaleMatrix=[[sx,0,0,0],[0,sy,0,0],[0,0,sz,0],[0,0,0,1]],rotationAndSkewMatrix=[[matrix[0]/sx,matrix[1]/sx,matrix[2]/sx,0],[matrix[4]/sy,matrix[5]/sy,matrix[6]/sy,0],[matrix[8]/sz,matrix[9]/sz,matrix[10]/sz,0],[0,0,0,1]],{rotationMatrix:rotationMatrix,skewMatrix:skewMatrix}=gramSchmidtAlgorithm(rotationAndSkewMatrix);return{translationMatrix:translationMatrix,scaleMatrix:scaleMatrix,rotationMatrix:rotationMatrix,skewMatrix:skewMatrix}}export function decomposeMatrixIntoMatricesAndAngles(matrix){const{scaleMatrix:scaleMatrix,rotationMatrix:rotationMatrix,translationMatrix:translationMatrix,skewMatrix:skewMatrix}=decomposeMatrix(matrix),sinRy=-rotationMatrix[0][2],ry=Math.asin(sinRy);let rx,rz;return 1===sinRy||-1===sinRy?(rz=0,rx=Math.atan2(sinRy*rotationMatrix[0][1],sinRy*rotationMatrix[0][2])):(rz=Math.atan2(rotationMatrix[0][1],rotationMatrix[0][0]),rx=Math.atan2(rotationMatrix[1][2],rotationMatrix[2][2])),{scaleMatrix:scaleMatrix,rotationMatrix:rotationMatrix,translationMatrix:translationMatrix,skewMatrix:skewMatrix,rx:rx||0,ry:ry||0,rz:rz||0}}