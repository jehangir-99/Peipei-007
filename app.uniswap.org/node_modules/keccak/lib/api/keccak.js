const{Transform:Transform}=require("readable-stream");module.exports=KeccakState=>class Keccak extends Transform{constructor(rate,capacity,delimitedSuffix,hashBitLength,options){super(options),this._rate=rate,this._capacity=capacity,this._delimitedSuffix=delimitedSuffix,this._hashBitLength=hashBitLength,this._options=options,this._state=new KeccakState,this._state.initialize(rate,capacity),this._finalized=!1}_transform(chunk,encoding,callback){let error=null;try{this.update(chunk,encoding)}catch(err){error=err}callback(error)}_flush(callback){let error=null;try{this.push(this.digest())}catch(err){error=err}callback(error)}update(data,encoding){if(!Buffer.isBuffer(data)&&"string"!=typeof data)throw new TypeError("Data must be a string or a buffer");if(this._finalized)throw new Error("Digest already called");return Buffer.isBuffer(data)||(data=Buffer.from(data,encoding)),this._state.absorb(data),this}digest(encoding){if(this._finalized)throw new Error("Digest already called");this._finalized=!0,this._delimitedSuffix&&this._state.absorbLastFewBits(this._delimitedSuffix);let digest=this._state.squeeze(this._hashBitLength/8);return void 0!==encoding&&(digest=digest.toString(encoding)),this._resetState(),digest}_resetState(){return this._state.initialize(this._rate,this._capacity),this}_clone(){const clone=new Keccak(this._rate,this._capacity,this._delimitedSuffix,this._hashBitLength,this._options);return this._state.copy(clone._state),clone._finalized=this._finalized,clone}};