import{makeDsn,logger,checkOrSetAlreadyCaught,isPrimitive,resolvedSyncPromise,addItemToEnvelope,createAttachmentEnvelopeItem,SyncPromise,rejectedSyncPromise,SentryError,isThenable,isPlainObject}from"@sentry/utils";import{getEnvelopeEndpointWithUrlEncodedAuth}from"./api.js";import{createEventEnvelope,createSessionEnvelope}from"./envelope.js";import{setupIntegrations,setupIntegration}from"./integration.js";import{updateSession}from"./session.js";import{getDynamicSamplingContextFromClient}from"./tracing/dynamicSamplingContext.js";import{prepareEvent}from"./utils/prepareEvent.js";const ALREADY_SEEN_ERROR="Not capturing exception because it's already been captured.";class BaseClient{constructor(options){if(this._options=options,this._integrations={},this._integrationsInitialized=!1,this._numProcessing=0,this._outcomes={},this._hooks={},this._eventProcessors=[],options.dsn?this._dsn=makeDsn(options.dsn):("undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__)&&logger.warn("No DSN provided, client will not send events."),this._dsn){const url=getEnvelopeEndpointWithUrlEncodedAuth(this._dsn,options);this._transport=options.transport({recordDroppedEvent:this.recordDroppedEvent.bind(this),...options.transportOptions,url:url})}}captureException(exception,hint,scope){if(checkOrSetAlreadyCaught(exception))return void(("undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__)&&logger.log(ALREADY_SEEN_ERROR));let eventId=hint&&hint.event_id;return this._process(this.eventFromException(exception,hint).then((event=>this._captureEvent(event,hint,scope))).then((result=>{eventId=result}))),eventId}captureMessage(message,level,hint,scope){let eventId=hint&&hint.event_id;const promisedEvent=isPrimitive(message)?this.eventFromMessage(String(message),level,hint):this.eventFromException(message,hint);return this._process(promisedEvent.then((event=>this._captureEvent(event,hint,scope))).then((result=>{eventId=result}))),eventId}captureEvent(event,hint,scope){if(hint&&hint.originalException&&checkOrSetAlreadyCaught(hint.originalException))return void(("undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__)&&logger.log(ALREADY_SEEN_ERROR));let eventId=hint&&hint.event_id;return this._process(this._captureEvent(event,hint,scope).then((result=>{eventId=result}))),eventId}captureSession(session){"string"!=typeof session.release?("undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__)&&logger.warn("Discarded session because of missing or non-string release"):(this.sendSession(session),updateSession(session,{init:!1}))}getDsn(){return this._dsn}getOptions(){return this._options}getSdkMetadata(){return this._options._metadata}getTransport(){return this._transport}flush(timeout){const transport=this._transport;return transport?this._isClientDoneProcessing(timeout).then((clientFinished=>transport.flush(timeout).then((transportFlushed=>clientFinished&&transportFlushed)))):resolvedSyncPromise(!0)}close(timeout){return this.flush(timeout).then((result=>(this.getOptions().enabled=!1,result)))}getEventProcessors(){return this._eventProcessors}addEventProcessor(eventProcessor){this._eventProcessors.push(eventProcessor)}setupIntegrations(forceInitialize){(forceInitialize&&!this._integrationsInitialized||this._isEnabled()&&!this._integrationsInitialized)&&(this._integrations=setupIntegrations(this,this._options.integrations),this._integrationsInitialized=!0)}getIntegrationById(integrationId){return this._integrations[integrationId]}getIntegration(integration){try{return this._integrations[integration.id]||null}catch(_oO){return("undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__)&&logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`),null}}addIntegration(integration){setupIntegration(this,integration,this._integrations)}sendEvent(event,hint={}){this.emit("beforeSendEvent",event,hint);let env=createEventEnvelope(event,this._dsn,this._options._metadata,this._options.tunnel);for(const attachment of hint.attachments||[])env=addItemToEnvelope(env,createAttachmentEnvelopeItem(attachment,this._options.transportOptions&&this._options.transportOptions.textEncoder));const promise=this._sendEnvelope(env);promise&&promise.then((sendResponse=>this.emit("afterSendEvent",event,sendResponse)),null)}sendSession(session){const env=createSessionEnvelope(session,this._dsn,this._options._metadata,this._options.tunnel);this._sendEnvelope(env)}recordDroppedEvent(reason,category,_event){if(this._options.sendClientReports){const key=`${reason}:${category}`;("undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__)&&logger.log(`Adding outcome: "${key}"`),this._outcomes[key]=this._outcomes[key]+1||1}}on(hook,callback){this._hooks[hook]||(this._hooks[hook]=[]),this._hooks[hook].push(callback)}emit(hook,...rest){this._hooks[hook]&&this._hooks[hook].forEach((callback=>callback(...rest)))}_updateSessionFromEvent(session,event){let crashed=!1,errored=!1;const exceptions=event.exception&&event.exception.values;if(exceptions){errored=!0;for(const ex of exceptions){const mechanism=ex.mechanism;if(mechanism&&!1===mechanism.handled){crashed=!0;break}}}const sessionNonTerminal="ok"===session.status;(sessionNonTerminal&&0===session.errors||sessionNonTerminal&&crashed)&&(updateSession(session,{...crashed&&{status:"crashed"},errors:session.errors||Number(errored||crashed)}),this.captureSession(session))}_isClientDoneProcessing(timeout){return new SyncPromise((resolve=>{let ticked=0;const interval=setInterval((()=>{0==this._numProcessing?(clearInterval(interval),resolve(!0)):(ticked+=1,timeout&&ticked>=timeout&&(clearInterval(interval),resolve(!1)))}),1)}))}_isEnabled(){return!1!==this.getOptions().enabled&&void 0!==this._transport}_prepareEvent(event,hint,scope){const options=this.getOptions(),integrations=Object.keys(this._integrations);return!hint.integrations&&integrations.length>0&&(hint.integrations=integrations),this.emit("preprocessEvent",event,hint),prepareEvent(options,event,hint,scope,this).then((evt=>{if(null===evt)return evt;const{propagationContext:propagationContext}=evt.sdkProcessingMetadata||{};if(!(evt.contexts&&evt.contexts.trace)&&propagationContext){const{traceId:trace_id,spanId:spanId,parentSpanId:parentSpanId,dsc:dsc}=propagationContext;evt.contexts={trace:{trace_id:trace_id,span_id:spanId,parent_span_id:parentSpanId},...evt.contexts};const dynamicSamplingContext=dsc||getDynamicSamplingContextFromClient(trace_id,this,scope);evt.sdkProcessingMetadata={dynamicSamplingContext:dynamicSamplingContext,...evt.sdkProcessingMetadata}}return evt}))}_captureEvent(event,hint={},scope){return this._processEvent(event,hint,scope).then((finalEvent=>finalEvent.event_id),(reason=>{if("undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__){const sentryError=reason;"log"===sentryError.logLevel?logger.log(sentryError.message):logger.warn(sentryError)}}))}_processEvent(event,hint,scope){const options=this.getOptions(),{sampleRate:sampleRate}=options,isTransaction=isTransactionEvent(event),isError=isErrorEvent(event),eventType=event.type||"error",beforeSendLabel=`before send for type \`${eventType}\``;if(isError&&"number"==typeof sampleRate&&Math.random()>sampleRate)return this.recordDroppedEvent("sample_rate","error",event),rejectedSyncPromise(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,"log"));const dataCategory="replay_event"===eventType?"replay":eventType;return this._prepareEvent(event,hint,scope).then((prepared=>{if(null===prepared)throw this.recordDroppedEvent("event_processor",dataCategory,event),new SentryError("An event processor returned `null`, will not send event.","log");if(hint.data&&!0===hint.data.__sentry__)return prepared;return _validateBeforeSendResult(processBeforeSend(options,prepared,hint),beforeSendLabel)})).then((processedEvent=>{if(null===processedEvent)throw this.recordDroppedEvent("before_send",dataCategory,event),new SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`,"log");const session=scope&&scope.getSession();!isTransaction&&session&&this._updateSessionFromEvent(session,processedEvent);const transactionInfo=processedEvent.transaction_info;if(isTransaction&&transactionInfo&&processedEvent.transaction!==event.transaction){const source="custom";processedEvent.transaction_info={...transactionInfo,source:source}}return this.sendEvent(processedEvent,hint),processedEvent})).then(null,(reason=>{if(reason instanceof SentryError)throw reason;throw this.captureException(reason,{data:{__sentry__:!0},originalException:reason}),new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${reason}`)}))}_process(promise){this._numProcessing++,promise.then((value=>(this._numProcessing--,value)),(reason=>(this._numProcessing--,reason)))}_sendEnvelope(envelope){if(this.emit("beforeEnvelope",envelope),this._isEnabled()&&this._transport)return this._transport.send(envelope).then(null,(reason=>{("undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__)&&logger.error("Error while sending event:",reason)}));("undefined"==typeof __SENTRY_DEBUG__||__SENTRY_DEBUG__)&&logger.error("Transport disabled")}_clearOutcomes(){const outcomes=this._outcomes;return this._outcomes={},Object.keys(outcomes).map((key=>{const[reason,category]=key.split(":");return{reason:reason,category:category,quantity:outcomes[key]}}))}}function _validateBeforeSendResult(beforeSendResult,beforeSendLabel){const invalidValueError=`${beforeSendLabel} must return \`null\` or a valid event.`;if(isThenable(beforeSendResult))return beforeSendResult.then((event=>{if(!isPlainObject(event)&&null!==event)throw new SentryError(invalidValueError);return event}),(e=>{throw new SentryError(`${beforeSendLabel} rejected with ${e}`)}));if(!isPlainObject(beforeSendResult)&&null!==beforeSendResult)throw new SentryError(invalidValueError);return beforeSendResult}function processBeforeSend(options,event,hint){const{beforeSend:beforeSend,beforeSendTransaction:beforeSendTransaction}=options;return isErrorEvent(event)&&beforeSend?beforeSend(event,hint):isTransactionEvent(event)&&beforeSendTransaction?beforeSendTransaction(event,hint):event}function isErrorEvent(event){return void 0===event.type}function isTransactionEvent(event){return"transaction"===event.type}export{BaseClient};