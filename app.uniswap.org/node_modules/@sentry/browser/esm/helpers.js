import{withScope,captureException}from"@sentry/core";import{GLOBAL_OBJ,getOriginalFunction,markFunctionWrapped,addNonEnumerableProperty,addExceptionTypeValue,addExceptionMechanism}from"@sentry/utils";const WINDOW=GLOBAL_OBJ;let ignoreOnError=0;function shouldIgnoreOnError(){return ignoreOnError>0}function ignoreNextOnError(){ignoreOnError++,setTimeout((()=>{ignoreOnError--}))}function wrap(fn,options={},before){if("function"!=typeof fn)return fn;try{const wrapper=fn.__sentry_wrapped__;if(wrapper)return wrapper;if(getOriginalFunction(fn))return fn}catch(e){return fn}const sentryWrapped=function(){const args=Array.prototype.slice.call(arguments);try{before&&"function"==typeof before&&before.apply(this,arguments);const wrappedArguments=args.map((arg=>wrap(arg,options)));return fn.apply(this,wrappedArguments)}catch(ex){throw ignoreNextOnError(),withScope((scope=>{scope.addEventProcessor((event=>(options.mechanism&&(addExceptionTypeValue(event,void 0,void 0),addExceptionMechanism(event,options.mechanism)),event.extra={...event.extra,arguments:args},event))),captureException(ex)})),ex}};try{for(const property in fn)Object.prototype.hasOwnProperty.call(fn,property)&&(sentryWrapped[property]=fn[property])}catch(_oO){}markFunctionWrapped(sentryWrapped,fn),addNonEnumerableProperty(fn,"__sentry_wrapped__",sentryWrapped);try{Object.getOwnPropertyDescriptor(sentryWrapped,"name").configurable&&Object.defineProperty(sentryWrapped,"name",{get:()=>fn.name})}catch(_oO){}return sentryWrapped}export{WINDOW,ignoreNextOnError,shouldIgnoreOnError,wrap};