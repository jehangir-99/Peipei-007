import{fill,getFunctionName,getOriginalFunction}from"@sentry/utils";import{WINDOW,wrap}from"../helpers.js";const DEFAULT_EVENT_TARGET=["EventTarget","Window","Node","ApplicationCache","AudioTrackList","BroadcastChannel","ChannelMergerNode","CryptoOperation","EventSource","FileReader","HTMLUnknownElement","IDBDatabase","IDBRequest","IDBTransaction","KeyOperation","MediaController","MessagePort","ModalWindow","Notification","SVGElementInstance","Screen","SharedWorker","TextTrack","TextTrackCue","TextTrackList","WebSocket","WebSocketWorker","Worker","XMLHttpRequest","XMLHttpRequestEventTarget","XMLHttpRequestUpload"];class TryCatch{static __initStatic(){this.id="TryCatch"}constructor(options){this.name=TryCatch.id,this._options={XMLHttpRequest:!0,eventTarget:!0,requestAnimationFrame:!0,setInterval:!0,setTimeout:!0,...options}}setupOnce(){this._options.setTimeout&&fill(WINDOW,"setTimeout",_wrapTimeFunction),this._options.setInterval&&fill(WINDOW,"setInterval",_wrapTimeFunction),this._options.requestAnimationFrame&&fill(WINDOW,"requestAnimationFrame",_wrapRAF),this._options.XMLHttpRequest&&"XMLHttpRequest"in WINDOW&&fill(XMLHttpRequest.prototype,"send",_wrapXHR);const eventTargetOption=this._options.eventTarget;if(eventTargetOption){(Array.isArray(eventTargetOption)?eventTargetOption:DEFAULT_EVENT_TARGET).forEach(_wrapEventTarget)}}}function _wrapTimeFunction(original){return function(...args){const originalCallback=args[0];return args[0]=wrap(originalCallback,{mechanism:{data:{function:getFunctionName(original)},handled:!1,type:"instrument"}}),original.apply(this,args)}}function _wrapRAF(original){return function(callback){return original.apply(this,[wrap(callback,{mechanism:{data:{function:"requestAnimationFrame",handler:getFunctionName(original)},handled:!1,type:"instrument"}})])}}function _wrapXHR(originalSend){return function(...args){const xhr=this;return["onload","onerror","onprogress","onreadystatechange"].forEach((prop=>{prop in xhr&&"function"==typeof xhr[prop]&&fill(xhr,prop,(function(original){const wrapOptions={mechanism:{data:{function:prop,handler:getFunctionName(original)},handled:!1,type:"instrument"}},originalFunction=getOriginalFunction(original);return originalFunction&&(wrapOptions.mechanism.data.handler=getFunctionName(originalFunction)),wrap(original,wrapOptions)}))})),originalSend.apply(this,args)}}function _wrapEventTarget(target){const globalObject=WINDOW,proto=globalObject[target]&&globalObject[target].prototype;proto&&proto.hasOwnProperty&&proto.hasOwnProperty("addEventListener")&&(fill(proto,"addEventListener",(function(original){return function(eventName,fn,options){try{"function"==typeof fn.handleEvent&&(fn.handleEvent=wrap(fn.handleEvent,{mechanism:{data:{function:"handleEvent",handler:getFunctionName(fn),target:target},handled:!1,type:"instrument"}}))}catch(err){}return original.apply(this,[eventName,wrap(fn,{mechanism:{data:{function:"addEventListener",handler:getFunctionName(fn),target:target},handled:!1,type:"instrument"}}),options])}})),fill(proto,"removeEventListener",(function(originalRemoveEventListener){return function(eventName,fn,options){const wrappedEventHandler=fn;try{const originalEventHandler=wrappedEventHandler&&wrappedEventHandler.__sentry_wrapped__;originalEventHandler&&originalRemoveEventListener.call(this,eventName,originalEventHandler,options)}catch(e){}return originalRemoveEventListener.call(this,eventName,wrappedEventHandler,options)}})))}TryCatch.__initStatic();export{TryCatch};