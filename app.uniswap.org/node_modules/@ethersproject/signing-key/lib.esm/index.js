"use strict";import{EC}from"./elliptic";import{arrayify,hexDataLength,hexlify,hexZeroPad,splitSignature}from"@ethersproject/bytes";import{defineReadOnly}from"@ethersproject/properties";import{Logger}from"@ethersproject/logger";import{version}from"./_version";const logger=new Logger(version);let _curve=null;function getCurve(){return _curve||(_curve=new EC("secp256k1")),_curve}export class SigningKey{constructor(privateKey){defineReadOnly(this,"curve","secp256k1"),defineReadOnly(this,"privateKey",hexlify(privateKey)),32!==hexDataLength(this.privateKey)&&logger.throwArgumentError("invalid private key","privateKey","[[ REDACTED ]]");const keyPair=getCurve().keyFromPrivate(arrayify(this.privateKey));defineReadOnly(this,"publicKey","0x"+keyPair.getPublic(!1,"hex")),defineReadOnly(this,"compressedPublicKey","0x"+keyPair.getPublic(!0,"hex")),defineReadOnly(this,"_isSigningKey",!0)}_addPoint(other){const p0=getCurve().keyFromPublic(arrayify(this.publicKey)),p1=getCurve().keyFromPublic(arrayify(other));return"0x"+p0.pub.add(p1.pub).encodeCompressed("hex")}signDigest(digest){const keyPair=getCurve().keyFromPrivate(arrayify(this.privateKey)),digestBytes=arrayify(digest);32!==digestBytes.length&&logger.throwArgumentError("bad digest length","digest",digest);const signature=keyPair.sign(digestBytes,{canonical:!0});return splitSignature({recoveryParam:signature.recoveryParam,r:hexZeroPad("0x"+signature.r.toString(16),32),s:hexZeroPad("0x"+signature.s.toString(16),32)})}computeSharedSecret(otherKey){const keyPair=getCurve().keyFromPrivate(arrayify(this.privateKey)),otherKeyPair=getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));return hexZeroPad("0x"+keyPair.derive(otherKeyPair.getPublic()).toString(16),32)}static isSigningKey(value){return!(!value||!value._isSigningKey)}}export function recoverPublicKey(digest,signature){const sig=splitSignature(signature),rs={r:arrayify(sig.r),s:arrayify(sig.s)};return"0x"+getCurve().recoverPubKey(arrayify(digest),rs,sig.recoveryParam).encode("hex",!1)}export function computePublicKey(key,compressed){const bytes=arrayify(key);if(32===bytes.length){const signingKey=new SigningKey(bytes);return compressed?"0x"+getCurve().keyFromPrivate(bytes).getPublic(!0,"hex"):signingKey.publicKey}return 33===bytes.length?compressed?hexlify(bytes):"0x"+getCurve().keyFromPublic(bytes).getPublic(!1,"hex"):65===bytes.length?compressed?"0x"+getCurve().keyFromPublic(bytes).getPublic(!0,"hex"):hexlify(bytes):logger.throwArgumentError("invalid public or private key","key","[REDACTED]")}