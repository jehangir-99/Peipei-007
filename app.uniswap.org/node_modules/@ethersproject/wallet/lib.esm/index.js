"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P((function(resolve){resolve(value)}))).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))};import{getAddress}from"@ethersproject/address";import{Provider}from"@ethersproject/abstract-provider";import{Signer}from"@ethersproject/abstract-signer";import{arrayify,concat,hexDataSlice,isHexString,joinSignature}from"@ethersproject/bytes";import{hashMessage,_TypedDataEncoder}from"@ethersproject/hash";import{defaultPath,HDNode,entropyToMnemonic}from"@ethersproject/hdnode";import{keccak256}from"@ethersproject/keccak256";import{defineReadOnly,resolveProperties}from"@ethersproject/properties";import{randomBytes}from"@ethersproject/random";import{SigningKey}from"@ethersproject/signing-key";import{decryptJsonWallet,decryptJsonWalletSync,encryptKeystore}from"@ethersproject/json-wallets";import{computeAddress,recoverAddress,serialize}from"@ethersproject/transactions";import{Logger}from"@ethersproject/logger";import{version}from"./_version";const logger=new Logger(version);function isAccount(value){return null!=value&&isHexString(value.privateKey,32)&&null!=value.address}function hasMnemonic(value){const mnemonic=value.mnemonic;return mnemonic&&mnemonic.phrase}export class Wallet extends Signer{constructor(privateKey,provider){if(super(),isAccount(privateKey)){const signingKey=new SigningKey(privateKey.privateKey);if(defineReadOnly(this,"_signingKey",(()=>signingKey)),defineReadOnly(this,"address",computeAddress(this.publicKey)),this.address!==getAddress(privateKey.address)&&logger.throwArgumentError("privateKey/address mismatch","privateKey","[REDACTED]"),hasMnemonic(privateKey)){const srcMnemonic=privateKey.mnemonic;defineReadOnly(this,"_mnemonic",(()=>({phrase:srcMnemonic.phrase,path:srcMnemonic.path||defaultPath,locale:srcMnemonic.locale||"en"})));const mnemonic=this.mnemonic,node=HDNode.fromMnemonic(mnemonic.phrase,null,mnemonic.locale).derivePath(mnemonic.path);computeAddress(node.privateKey)!==this.address&&logger.throwArgumentError("mnemonic/address mismatch","privateKey","[REDACTED]")}else defineReadOnly(this,"_mnemonic",(()=>null))}else{if(SigningKey.isSigningKey(privateKey))"secp256k1"!==privateKey.curve&&logger.throwArgumentError("unsupported curve; must be secp256k1","privateKey","[REDACTED]"),defineReadOnly(this,"_signingKey",(()=>privateKey));else{"string"==typeof privateKey&&privateKey.match(/^[0-9a-f]*$/i)&&64===privateKey.length&&(privateKey="0x"+privateKey);const signingKey=new SigningKey(privateKey);defineReadOnly(this,"_signingKey",(()=>signingKey))}defineReadOnly(this,"_mnemonic",(()=>null)),defineReadOnly(this,"address",computeAddress(this.publicKey))}provider&&!Provider.isProvider(provider)&&logger.throwArgumentError("invalid provider","provider",provider),defineReadOnly(this,"provider",provider||null)}get mnemonic(){return this._mnemonic()}get privateKey(){return this._signingKey().privateKey}get publicKey(){return this._signingKey().publicKey}getAddress(){return Promise.resolve(this.address)}connect(provider){return new Wallet(this,provider)}signTransaction(transaction){return resolveProperties(transaction).then((tx=>{null!=tx.from&&(getAddress(tx.from)!==this.address&&logger.throwArgumentError("transaction from address mismatch","transaction.from",transaction.from),delete tx.from);const signature=this._signingKey().signDigest(keccak256(serialize(tx)));return serialize(tx,signature)}))}signMessage(message){return __awaiter(this,void 0,void 0,(function*(){return joinSignature(this._signingKey().signDigest(hashMessage(message)))}))}_signTypedData(domain,types,value){return __awaiter(this,void 0,void 0,(function*(){const populated=yield _TypedDataEncoder.resolveNames(domain,types,value,(name=>(null==this.provider&&logger.throwError("cannot resolve ENS names without a provider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"resolveName",value:name}),this.provider.resolveName(name))));return joinSignature(this._signingKey().signDigest(_TypedDataEncoder.hash(populated.domain,types,populated.value)))}))}encrypt(password,options,progressCallback){if("function"!=typeof options||progressCallback||(progressCallback=options,options={}),progressCallback&&"function"!=typeof progressCallback)throw new Error("invalid callback");return options||(options={}),encryptKeystore(this,password,options,progressCallback)}static createRandom(options){let entropy=randomBytes(16);options||(options={}),options.extraEntropy&&(entropy=arrayify(hexDataSlice(keccak256(concat([entropy,options.extraEntropy])),0,16)));const mnemonic=entropyToMnemonic(entropy,options.locale);return Wallet.fromMnemonic(mnemonic,options.path,options.locale)}static fromEncryptedJson(json,password,progressCallback){return decryptJsonWallet(json,password,progressCallback).then((account=>new Wallet(account)))}static fromEncryptedJsonSync(json,password){return new Wallet(decryptJsonWalletSync(json,password))}static fromMnemonic(mnemonic,path,wordlist){return path||(path=defaultPath),new Wallet(HDNode.fromMnemonic(mnemonic,null,wordlist).derivePath(path))}}export function verifyMessage(message,signature){return recoverAddress(hashMessage(message),signature)}export function verifyTypedData(domain,types,value,signature){return recoverAddress(_TypedDataEncoder.hash(domain,types,value),signature)}