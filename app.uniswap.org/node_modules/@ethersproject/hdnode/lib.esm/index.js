"use strict";import{Base58}from"@ethersproject/basex";import{arrayify,concat,hexDataSlice,hexZeroPad,hexlify}from"@ethersproject/bytes";import{BigNumber}from"@ethersproject/bignumber";import{toUtf8Bytes,UnicodeNormalizationForm}from"@ethersproject/strings";import{pbkdf2}from"@ethersproject/pbkdf2";import{defineReadOnly}from"@ethersproject/properties";import{SigningKey}from"@ethersproject/signing-key";import{computeHmac,ripemd160,sha256,SupportedAlgorithm}from"@ethersproject/sha2";import{computeAddress}from"@ethersproject/transactions";import{wordlists}from"@ethersproject/wordlists";import{Logger}from"@ethersproject/logger";import{version}from"./_version";const logger=new Logger(version),N=BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),MasterSecret=toUtf8Bytes("Bitcoin seed"),HardenedBit=2147483648;function getUpperMask(bits){return(1<<bits)-1<<8-bits}function getLowerMask(bits){return(1<<bits)-1}function bytes32(value){return hexZeroPad(hexlify(value),32)}function base58check(data){return Base58.encode(concat([data,hexDataSlice(sha256(sha256(data)),0,4)]))}function getWordlist(wordlist){if(null==wordlist)return wordlists.en;if("string"==typeof wordlist){const words=wordlists[wordlist];return null==words&&logger.throwArgumentError("unknown locale","wordlist",wordlist),words}return wordlist}const _constructorGuard={};export const defaultPath="m/44'/60'/0'/0/0";export class HDNode{constructor(constructorGuard,privateKey,publicKey,parentFingerprint,chainCode,index,depth,mnemonicOrPath){if(constructorGuard!==_constructorGuard)throw new Error("HDNode constructor cannot be called directly");if(privateKey){const signingKey=new SigningKey(privateKey);defineReadOnly(this,"privateKey",signingKey.privateKey),defineReadOnly(this,"publicKey",signingKey.compressedPublicKey)}else defineReadOnly(this,"privateKey",null),defineReadOnly(this,"publicKey",hexlify(publicKey));defineReadOnly(this,"parentFingerprint",parentFingerprint),defineReadOnly(this,"fingerprint",hexDataSlice(ripemd160(sha256(this.publicKey)),0,4)),defineReadOnly(this,"address",computeAddress(this.publicKey)),defineReadOnly(this,"chainCode",chainCode),defineReadOnly(this,"index",index),defineReadOnly(this,"depth",depth),null==mnemonicOrPath?(defineReadOnly(this,"mnemonic",null),defineReadOnly(this,"path",null)):"string"==typeof mnemonicOrPath?(defineReadOnly(this,"mnemonic",null),defineReadOnly(this,"path",mnemonicOrPath)):(defineReadOnly(this,"mnemonic",mnemonicOrPath),defineReadOnly(this,"path",mnemonicOrPath.path))}get extendedKey(){if(this.depth>=256)throw new Error("Depth too large!");return base58check(concat([null!=this.privateKey?"0x0488ADE4":"0x0488B21E",hexlify(this.depth),this.parentFingerprint,hexZeroPad(hexlify(this.index),4),this.chainCode,null!=this.privateKey?concat(["0x00",this.privateKey]):this.publicKey]))}neuter(){return new HDNode(_constructorGuard,null,this.publicKey,this.parentFingerprint,this.chainCode,this.index,this.depth,this.path)}_derive(index){if(index>4294967295)throw new Error("invalid index - "+String(index));let path=this.path;path&&(path+="/"+(2147483647&index));const data=new Uint8Array(37);if(2147483648&index){if(!this.privateKey)throw new Error("cannot derive child of neutered node");data.set(arrayify(this.privateKey),1),path&&(path+="'")}else data.set(arrayify(this.publicKey));for(let i=24;i>=0;i-=8)data[33+(i>>3)]=index>>24-i&255;const I=arrayify(computeHmac(SupportedAlgorithm.sha512,this.chainCode,data)),IL=I.slice(0,32),IR=I.slice(32);let ki=null,Ki=null;if(this.privateKey)ki=bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));else{Ki=new SigningKey(hexlify(IL))._addPoint(this.publicKey)}let mnemonicOrPath=path;const srcMnemonic=this.mnemonic;return srcMnemonic&&(mnemonicOrPath=Object.freeze({phrase:srcMnemonic.phrase,path:path,locale:srcMnemonic.locale||"en"})),new HDNode(_constructorGuard,ki,Ki,this.fingerprint,bytes32(IR),index,this.depth+1,mnemonicOrPath)}derivePath(path){const components=path.split("/");if(0===components.length||"m"===components[0]&&0!==this.depth)throw new Error("invalid path - "+path);"m"===components[0]&&components.shift();let result=this;for(let i=0;i<components.length;i++){const component=components[i];if(component.match(/^[0-9]+'$/)){const index=parseInt(component.substring(0,component.length-1));if(index>=2147483648)throw new Error("invalid path index - "+component);result=result._derive(2147483648+index)}else{if(!component.match(/^[0-9]+$/))throw new Error("invalid path component - "+component);{const index=parseInt(component);if(index>=2147483648)throw new Error("invalid path index - "+component);result=result._derive(index)}}}return result}static _fromSeed(seed,mnemonic){const seedArray=arrayify(seed);if(seedArray.length<16||seedArray.length>64)throw new Error("invalid seed");const I=arrayify(computeHmac(SupportedAlgorithm.sha512,MasterSecret,seedArray));return new HDNode(_constructorGuard,bytes32(I.slice(0,32)),null,"0x00000000",bytes32(I.slice(32)),0,0,mnemonic)}static fromMnemonic(mnemonic,password,wordlist){return mnemonic=entropyToMnemonic(mnemonicToEntropy(mnemonic,wordlist=getWordlist(wordlist)),wordlist),HDNode._fromSeed(mnemonicToSeed(mnemonic,password),{phrase:mnemonic,path:"m",locale:wordlist.locale})}static fromSeed(seed){return HDNode._fromSeed(seed,null)}static fromExtendedKey(extendedKey){const bytes=Base58.decode(extendedKey);82===bytes.length&&base58check(bytes.slice(0,78))===extendedKey||logger.throwArgumentError("invalid extended key","extendedKey","[REDACTED]");const depth=bytes[4],parentFingerprint=hexlify(bytes.slice(5,9)),index=parseInt(hexlify(bytes.slice(9,13)).substring(2),16),chainCode=hexlify(bytes.slice(13,45)),key=bytes.slice(45,78);switch(hexlify(bytes.slice(0,4))){case"0x0488b21e":case"0x043587cf":return new HDNode(_constructorGuard,null,hexlify(key),parentFingerprint,chainCode,index,depth,null);case"0x0488ade4":case"0x04358394 ":if(0!==key[0])break;return new HDNode(_constructorGuard,hexlify(key.slice(1)),null,parentFingerprint,chainCode,index,depth,null)}return logger.throwArgumentError("invalid extended key","extendedKey","[REDACTED]")}}export function mnemonicToSeed(mnemonic,password){password||(password="");const salt=toUtf8Bytes("mnemonic"+password,UnicodeNormalizationForm.NFKD);return pbkdf2(toUtf8Bytes(mnemonic,UnicodeNormalizationForm.NFKD),salt,2048,64,"sha512")}export function mnemonicToEntropy(mnemonic,wordlist){wordlist=getWordlist(wordlist),logger.checkNormalize();const words=wordlist.split(mnemonic);if(words.length%3!=0)throw new Error("invalid mnemonic");const entropy=arrayify(new Uint8Array(Math.ceil(11*words.length/8)));let offset=0;for(let i=0;i<words.length;i++){let index=wordlist.getWordIndex(words[i].normalize("NFKD"));if(-1===index)throw new Error("invalid mnemonic");for(let bit=0;bit<11;bit++)index&1<<10-bit&&(entropy[offset>>3]|=1<<7-offset%8),offset++}const entropyBits=32*words.length/3,checksumMask=getUpperMask(words.length/3);if((arrayify(sha256(entropy.slice(0,entropyBits/8)))[0]&checksumMask)!==(entropy[entropy.length-1]&checksumMask))throw new Error("invalid checksum");return hexlify(entropy.slice(0,entropyBits/8))}export function entropyToMnemonic(entropy,wordlist){if(wordlist=getWordlist(wordlist),(entropy=arrayify(entropy)).length%4!=0||entropy.length<16||entropy.length>32)throw new Error("invalid entropy");const indices=[0];let remainingBits=11;for(let i=0;i<entropy.length;i++)remainingBits>8?(indices[indices.length-1]<<=8,indices[indices.length-1]|=entropy[i],remainingBits-=8):(indices[indices.length-1]<<=remainingBits,indices[indices.length-1]|=entropy[i]>>8-remainingBits,indices.push(entropy[i]&getLowerMask(8-remainingBits)),remainingBits+=3);const checksumBits=entropy.length/4,checksum=arrayify(sha256(entropy))[0]&getUpperMask(checksumBits);return indices[indices.length-1]<<=checksumBits,indices[indices.length-1]|=checksum>>8-checksumBits,wordlist.join(indices.map((index=>wordlist.getWord(index))))}export function isValidMnemonic(mnemonic,wordlist){try{return mnemonicToEntropy(mnemonic,wordlist),!0}catch(error){}return!1}export function getAccountPath(index){return("number"!=typeof index||index<0||index>=2147483648||index%1)&&logger.throwArgumentError("invalid account index","index",index),`m/44'/60'/${index}'/0/0`}