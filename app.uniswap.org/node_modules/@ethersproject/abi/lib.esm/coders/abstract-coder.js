"use strict";import{arrayify,concat,hexConcat,hexlify}from"@ethersproject/bytes";import{BigNumber}from"@ethersproject/bignumber";import{defineReadOnly}from"@ethersproject/properties";import{Logger}from"@ethersproject/logger";import{version}from"../_version";const logger=new Logger(version);export function checkResultErrors(result){const errors=[],checkErrors=function(path,object){if(Array.isArray(object))for(let key in object){const childPath=path.slice();childPath.push(key);try{checkErrors(childPath,object[key])}catch(error){errors.push({path:childPath,error:error})}}};return checkErrors([],result),errors}export class Coder{constructor(name,type,localName,dynamic){this.name=name,this.type=type,this.localName=localName,this.dynamic=dynamic}_throwError(message,value){logger.throwArgumentError(message,this.localName,value)}}export class Writer{constructor(wordSize){defineReadOnly(this,"wordSize",wordSize||32),this._data=[],this._dataLength=0,this._padding=new Uint8Array(wordSize)}get data(){return hexConcat(this._data)}get length(){return this._dataLength}_writeData(data){return this._data.push(data),this._dataLength+=data.length,data.length}appendWriter(writer){return this._writeData(concat(writer._data))}writeBytes(value){let bytes=arrayify(value);const paddingOffset=bytes.length%this.wordSize;return paddingOffset&&(bytes=concat([bytes,this._padding.slice(paddingOffset)])),this._writeData(bytes)}_getValue(value){let bytes=arrayify(BigNumber.from(value));return bytes.length>this.wordSize&&logger.throwError("value out-of-bounds",Logger.errors.BUFFER_OVERRUN,{length:this.wordSize,offset:bytes.length}),bytes.length%this.wordSize&&(bytes=concat([this._padding.slice(bytes.length%this.wordSize),bytes])),bytes}writeValue(value){return this._writeData(this._getValue(value))}writeUpdatableValue(){const offset=this._data.length;return this._data.push(this._padding),this._dataLength+=this.wordSize,value=>{this._data[offset]=this._getValue(value)}}}export class Reader{constructor(data,wordSize,coerceFunc,allowLoose){defineReadOnly(this,"_data",arrayify(data)),defineReadOnly(this,"wordSize",wordSize||32),defineReadOnly(this,"_coerceFunc",coerceFunc),defineReadOnly(this,"allowLoose",allowLoose),this._offset=0}get data(){return hexlify(this._data)}get consumed(){return this._offset}static coerce(name,value){let match=name.match("^u?int([0-9]+)$");return match&&parseInt(match[1])<=48&&(value=value.toNumber()),value}coerce(name,value){return this._coerceFunc?this._coerceFunc(name,value):Reader.coerce(name,value)}_peekBytes(offset,length,loose){let alignedLength=Math.ceil(length/this.wordSize)*this.wordSize;return this._offset+alignedLength>this._data.length&&(this.allowLoose&&loose&&this._offset+length<=this._data.length?alignedLength=length:logger.throwError("data out-of-bounds",Logger.errors.BUFFER_OVERRUN,{length:this._data.length,offset:this._offset+alignedLength})),this._data.slice(this._offset,this._offset+alignedLength)}subReader(offset){return new Reader(this._data.slice(this._offset+offset),this.wordSize,this._coerceFunc,this.allowLoose)}readBytes(length,loose){let bytes=this._peekBytes(0,length,!!loose);return this._offset+=bytes.length,bytes.slice(0,length)}readValue(){return BigNumber.from(this.readBytes(this.wordSize))}}