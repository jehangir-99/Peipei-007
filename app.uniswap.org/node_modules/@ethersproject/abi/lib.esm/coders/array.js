"use strict";import{Logger}from"@ethersproject/logger";import{version}from"../_version";const logger=new Logger(version);import{Coder,Writer}from"./abstract-coder";import{AnonymousCoder}from"./anonymous";export function pack(writer,coders,values){let arrayValues=null;if(Array.isArray(values))arrayValues=values;else if(values&&"object"==typeof values){let unique={};arrayValues=coders.map((coder=>{const name=coder.localName;return name||logger.throwError("cannot encode object for signature with missing names",Logger.errors.INVALID_ARGUMENT,{argument:"values",coder:coder,value:values}),unique[name]&&logger.throwError("cannot encode object for signature with duplicate names",Logger.errors.INVALID_ARGUMENT,{argument:"values",coder:coder,value:values}),unique[name]=!0,values[name]}))}else logger.throwArgumentError("invalid tuple value","tuple",values);coders.length!==arrayValues.length&&logger.throwArgumentError("types/value length mismatch","tuple",values);let staticWriter=new Writer(writer.wordSize),dynamicWriter=new Writer(writer.wordSize),updateFuncs=[];coders.forEach(((coder,index)=>{let value=arrayValues[index];if(coder.dynamic){let dynamicOffset=dynamicWriter.length;coder.encode(dynamicWriter,value);let updateFunc=staticWriter.writeUpdatableValue();updateFuncs.push((baseOffset=>{updateFunc(baseOffset+dynamicOffset)}))}else coder.encode(staticWriter,value)})),updateFuncs.forEach((func=>{func(staticWriter.length)}));let length=writer.appendWriter(staticWriter);return length+=writer.appendWriter(dynamicWriter),length}export function unpack(reader,coders){let values=[],baseReader=reader.subReader(0);coders.forEach((coder=>{let value=null;if(coder.dynamic){let offset=reader.readValue(),offsetReader=baseReader.subReader(offset.toNumber());try{value=coder.decode(offsetReader)}catch(error){if(error.code===Logger.errors.BUFFER_OVERRUN)throw error;value=error,value.baseType=coder.name,value.name=coder.localName,value.type=coder.type}}else try{value=coder.decode(reader)}catch(error){if(error.code===Logger.errors.BUFFER_OVERRUN)throw error;value=error,value.baseType=coder.name,value.name=coder.localName,value.type=coder.type}null!=value&&values.push(value)}));const uniqueNames=coders.reduce(((accum,coder)=>{const name=coder.localName;return name&&(accum[name]||(accum[name]=0),accum[name]++),accum}),{});coders.forEach(((coder,index)=>{let name=coder.localName;if(!name||1!==uniqueNames[name])return;if("length"===name&&(name="_length"),null!=values[name])return;const value=values[index];value instanceof Error?Object.defineProperty(values,name,{enumerable:!0,get:()=>{throw value}}):values[name]=value}));for(let i=0;i<values.length;i++){const value=values[i];value instanceof Error&&Object.defineProperty(values,i,{enumerable:!0,get:()=>{throw value}})}return Object.freeze(values)}export class ArrayCoder extends Coder{constructor(coder,length,localName){super("array",coder.type+"["+(length>=0?length:"")+"]",localName,-1===length||coder.dynamic),this.coder=coder,this.length=length}defaultValue(){const defaultChild=this.coder.defaultValue(),result=[];for(let i=0;i<this.length;i++)result.push(defaultChild);return result}encode(writer,value){Array.isArray(value)||this._throwError("expected array value",value);let count=this.length;-1===count&&(count=value.length,writer.writeValue(value.length)),logger.checkArgumentCount(value.length,count,"coder array"+(this.localName?" "+this.localName:""));let coders=[];for(let i=0;i<value.length;i++)coders.push(this.coder);return pack(writer,coders,value)}decode(reader){let count=this.length;-1===count&&(count=reader.readValue().toNumber(),32*count>reader._data.length&&logger.throwError("insufficient data length",Logger.errors.BUFFER_OVERRUN,{length:reader._data.length,count:count}));let coders=[];for(let i=0;i<count;i++)coders.push(new AnonymousCoder(this.coder));return reader.coerce(this.name,unpack(reader,coders))}}