"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P((function(resolve){resolve(value)}))).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))};import{defineReadOnly,resolveProperties,shallowCopy}from"@ethersproject/properties";import{Logger}from"@ethersproject/logger";import{version}from"./_version";const logger=new Logger(version),allowedTransactionKeys=["accessList","ccipReadEnabled","chainId","customData","data","from","gasLimit","gasPrice","maxFeePerGas","maxPriorityFeePerGas","nonce","to","type","value"],forwardErrors=[Logger.errors.INSUFFICIENT_FUNDS,Logger.errors.NONCE_EXPIRED,Logger.errors.REPLACEMENT_UNDERPRICED];export class Signer{constructor(){logger.checkAbstract(new.target,Signer),defineReadOnly(this,"_isSigner",!0)}getBalance(blockTag){return __awaiter(this,void 0,void 0,(function*(){return this._checkProvider("getBalance"),yield this.provider.getBalance(this.getAddress(),blockTag)}))}getTransactionCount(blockTag){return __awaiter(this,void 0,void 0,(function*(){return this._checkProvider("getTransactionCount"),yield this.provider.getTransactionCount(this.getAddress(),blockTag)}))}estimateGas(transaction){return __awaiter(this,void 0,void 0,(function*(){this._checkProvider("estimateGas");const tx=yield resolveProperties(this.checkTransaction(transaction));return yield this.provider.estimateGas(tx)}))}call(transaction,blockTag){return __awaiter(this,void 0,void 0,(function*(){this._checkProvider("call");const tx=yield resolveProperties(this.checkTransaction(transaction));return yield this.provider.call(tx,blockTag)}))}sendTransaction(transaction){return __awaiter(this,void 0,void 0,(function*(){this._checkProvider("sendTransaction");const tx=yield this.populateTransaction(transaction),signedTx=yield this.signTransaction(tx);return yield this.provider.sendTransaction(signedTx)}))}getChainId(){return __awaiter(this,void 0,void 0,(function*(){this._checkProvider("getChainId");return(yield this.provider.getNetwork()).chainId}))}getGasPrice(){return __awaiter(this,void 0,void 0,(function*(){return this._checkProvider("getGasPrice"),yield this.provider.getGasPrice()}))}getFeeData(){return __awaiter(this,void 0,void 0,(function*(){return this._checkProvider("getFeeData"),yield this.provider.getFeeData()}))}resolveName(name){return __awaiter(this,void 0,void 0,(function*(){return this._checkProvider("resolveName"),yield this.provider.resolveName(name)}))}checkTransaction(transaction){for(const key in transaction)-1===allowedTransactionKeys.indexOf(key)&&logger.throwArgumentError("invalid transaction key: "+key,"transaction",transaction);const tx=shallowCopy(transaction);return null==tx.from?tx.from=this.getAddress():tx.from=Promise.all([Promise.resolve(tx.from),this.getAddress()]).then((result=>(result[0].toLowerCase()!==result[1].toLowerCase()&&logger.throwArgumentError("from address mismatch","transaction",transaction),result[0]))),tx}populateTransaction(transaction){return __awaiter(this,void 0,void 0,(function*(){const tx=yield resolveProperties(this.checkTransaction(transaction));null!=tx.to&&(tx.to=Promise.resolve(tx.to).then((to=>__awaiter(this,void 0,void 0,(function*(){if(null==to)return null;const address=yield this.resolveName(to);return null==address&&logger.throwArgumentError("provided ENS name resolves to null","tx.to",to),address})))),tx.to.catch((error=>{})));const hasEip1559=null!=tx.maxFeePerGas||null!=tx.maxPriorityFeePerGas;if(null==tx.gasPrice||2!==tx.type&&!hasEip1559?0!==tx.type&&1!==tx.type||!hasEip1559||logger.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas","transaction",transaction):logger.throwArgumentError("eip-1559 transaction do not support gasPrice","transaction",transaction),2!==tx.type&&null!=tx.type||null==tx.maxFeePerGas||null==tx.maxPriorityFeePerGas)if(0===tx.type||1===tx.type)null==tx.gasPrice&&(tx.gasPrice=this.getGasPrice());else{const feeData=yield this.getFeeData();if(null==tx.type)if(null!=feeData.maxFeePerGas&&null!=feeData.maxPriorityFeePerGas)if(tx.type=2,null!=tx.gasPrice){const gasPrice=tx.gasPrice;delete tx.gasPrice,tx.maxFeePerGas=gasPrice,tx.maxPriorityFeePerGas=gasPrice}else null==tx.maxFeePerGas&&(tx.maxFeePerGas=feeData.maxFeePerGas),null==tx.maxPriorityFeePerGas&&(tx.maxPriorityFeePerGas=feeData.maxPriorityFeePerGas);else null!=feeData.gasPrice?(hasEip1559&&logger.throwError("network does not support EIP-1559",Logger.errors.UNSUPPORTED_OPERATION,{operation:"populateTransaction"}),null==tx.gasPrice&&(tx.gasPrice=feeData.gasPrice),tx.type=0):logger.throwError("failed to get consistent fee data",Logger.errors.UNSUPPORTED_OPERATION,{operation:"signer.getFeeData"});else 2===tx.type&&(null==tx.maxFeePerGas&&(tx.maxFeePerGas=feeData.maxFeePerGas),null==tx.maxPriorityFeePerGas&&(tx.maxPriorityFeePerGas=feeData.maxPriorityFeePerGas))}else tx.type=2;return null==tx.nonce&&(tx.nonce=this.getTransactionCount("pending")),null==tx.gasLimit&&(tx.gasLimit=this.estimateGas(tx).catch((error=>{if(forwardErrors.indexOf(error.code)>=0)throw error;return logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit",Logger.errors.UNPREDICTABLE_GAS_LIMIT,{error:error,tx:tx})}))),null==tx.chainId?tx.chainId=this.getChainId():tx.chainId=Promise.all([Promise.resolve(tx.chainId),this.getChainId()]).then((results=>(0!==results[1]&&results[0]!==results[1]&&logger.throwArgumentError("chainId address mismatch","transaction",transaction),results[0]))),yield resolveProperties(tx)}))}_checkProvider(operation){this.provider||logger.throwError("missing provider",Logger.errors.UNSUPPORTED_OPERATION,{operation:operation||"_checkProvider"})}static isSigner(value){return!(!value||!value._isSigner)}}export class VoidSigner extends Signer{constructor(address,provider){super(),defineReadOnly(this,"address",address),defineReadOnly(this,"provider",provider||null)}getAddress(){return Promise.resolve(this.address)}_fail(message,operation){return Promise.resolve().then((()=>{logger.throwError(message,Logger.errors.UNSUPPORTED_OPERATION,{operation:operation})}))}signMessage(message){return this._fail("VoidSigner cannot sign messages","signMessage")}signTransaction(transaction){return this._fail("VoidSigner cannot sign transactions","signTransaction")}_signTypedData(domain,types,value){return this._fail("VoidSigner cannot sign typed data","signTypedData")}connect(provider){return new VoidSigner(this.address,provider)}}