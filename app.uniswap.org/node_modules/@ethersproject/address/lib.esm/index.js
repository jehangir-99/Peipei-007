"use strict";import{arrayify,concat,hexDataLength,hexDataSlice,isHexString,stripZeros}from"@ethersproject/bytes";import{BigNumber,_base16To36,_base36To16}from"@ethersproject/bignumber";import{keccak256}from"@ethersproject/keccak256";import{encode}from"@ethersproject/rlp";import{Logger}from"@ethersproject/logger";import{version}from"./_version";const logger=new Logger(version);function getChecksumAddress(address){isHexString(address,20)||logger.throwArgumentError("invalid address","address",address);const chars=(address=address.toLowerCase()).substring(2).split(""),expanded=new Uint8Array(40);for(let i=0;i<40;i++)expanded[i]=chars[i].charCodeAt(0);const hashed=arrayify(keccak256(expanded));for(let i=0;i<40;i+=2)hashed[i>>1]>>4>=8&&(chars[i]=chars[i].toUpperCase()),(15&hashed[i>>1])>=8&&(chars[i+1]=chars[i+1].toUpperCase());return"0x"+chars.join("")}const MAX_SAFE_INTEGER=9007199254740991;function log10(x){return Math.log10?Math.log10(x):Math.log(x)/Math.LN10}const ibanLookup={};for(let i=0;i<10;i++)ibanLookup[String(i)]=String(i);for(let i=0;i<26;i++)ibanLookup[String.fromCharCode(65+i)]=String(10+i);const safeDigits=Math.floor(log10(9007199254740991));function ibanChecksum(address){let expanded=(address=(address=address.toUpperCase()).substring(4)+address.substring(0,2)+"00").split("").map((c=>ibanLookup[c])).join("");for(;expanded.length>=safeDigits;){let block=expanded.substring(0,safeDigits);expanded=parseInt(block,10)%97+expanded.substring(block.length)}let checksum=String(98-parseInt(expanded,10)%97);for(;checksum.length<2;)checksum="0"+checksum;return checksum}export function getAddress(address){let result=null;if("string"!=typeof address&&logger.throwArgumentError("invalid address","address",address),address.match(/^(0x)?[0-9a-fA-F]{40}$/))"0x"!==address.substring(0,2)&&(address="0x"+address),result=getChecksumAddress(address),address.match(/([A-F].*[a-f])|([a-f].*[A-F])/)&&result!==address&&logger.throwArgumentError("bad address checksum","address",address);else if(address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){for(address.substring(2,4)!==ibanChecksum(address)&&logger.throwArgumentError("bad icap checksum","address",address),result=_base36To16(address.substring(4));result.length<40;)result="0"+result;result=getChecksumAddress("0x"+result)}else logger.throwArgumentError("invalid address","address",address);return result}export function isAddress(address){try{return getAddress(address),!0}catch(error){}return!1}export function getIcapAddress(address){let base36=_base16To36(getAddress(address).substring(2)).toUpperCase();for(;base36.length<30;)base36="0"+base36;return"XE"+ibanChecksum("XE00"+base36)+base36}export function getContractAddress(transaction){let from=null;try{from=getAddress(transaction.from)}catch(error){logger.throwArgumentError("missing from address","transaction",transaction)}const nonce=stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));return getAddress(hexDataSlice(keccak256(encode([from,nonce])),12))}export function getCreate2Address(from,salt,initCodeHash){return 32!==hexDataLength(salt)&&logger.throwArgumentError("salt must be 32 bytes","salt",salt),32!==hexDataLength(initCodeHash)&&logger.throwArgumentError("initCodeHash must be 32 bytes","initCodeHash",initCodeHash),getAddress(hexDataSlice(keccak256(concat(["0xff",getAddress(from),salt,initCodeHash])),12))}