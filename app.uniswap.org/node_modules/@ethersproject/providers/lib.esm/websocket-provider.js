"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P((function(resolve){resolve(value)}))).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))};import{BigNumber}from"@ethersproject/bignumber";import{defineReadOnly}from"@ethersproject/properties";import{JsonRpcProvider}from"./json-rpc-provider";import{WebSocket}from"./ws";import{Logger}from"@ethersproject/logger";import{version}from"./_version";const logger=new Logger(version);let NextId=1;export class WebSocketProvider extends JsonRpcProvider{constructor(url,network){"any"===network&&logger.throwError("WebSocketProvider does not support 'any' network yet",Logger.errors.UNSUPPORTED_OPERATION,{operation:"network:any"}),super("string"==typeof url?url:"_websocket",network),this._pollingInterval=-1,this._wsReady=!1,defineReadOnly(this,"_websocket","string"==typeof url?new WebSocket(this.connection.url):url),defineReadOnly(this,"_requests",{}),defineReadOnly(this,"_subs",{}),defineReadOnly(this,"_subIds",{}),defineReadOnly(this,"_detectNetwork",super.detectNetwork()),this.websocket.onopen=()=>{this._wsReady=!0,Object.keys(this._requests).forEach((id=>{this.websocket.send(this._requests[id].payload)}))},this.websocket.onmessage=messageEvent=>{const data=messageEvent.data,result=JSON.parse(data);if(null!=result.id){const id=String(result.id),request=this._requests[id];if(delete this._requests[id],void 0!==result.result)request.callback(null,result.result),this.emit("debug",{action:"response",request:JSON.parse(request.payload),response:result.result,provider:this});else{let error=null;result.error?(error=new Error(result.error.message||"unknown error"),defineReadOnly(error,"code",result.error.code||null),defineReadOnly(error,"response",data)):error=new Error("unknown error"),request.callback(error,void 0),this.emit("debug",{action:"response",error:error,request:JSON.parse(request.payload),provider:this})}}else if("eth_subscription"===result.method){const sub=this._subs[result.params.subscription];sub&&sub.processFunc(result.params.result)}else console.warn("this should not happen")};const fauxPoll=setInterval((()=>{this.emit("poll")}),1e3);fauxPoll.unref&&fauxPoll.unref()}get websocket(){return this._websocket}detectNetwork(){return this._detectNetwork}get pollingInterval(){return 0}resetEventsBlock(blockNumber){logger.throwError("cannot reset events block on WebSocketProvider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"resetEventBlock"})}set pollingInterval(value){logger.throwError("cannot set polling interval on WebSocketProvider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setPollingInterval"})}poll(){return __awaiter(this,void 0,void 0,(function*(){return null}))}set polling(value){value&&logger.throwError("cannot set polling on WebSocketProvider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setPolling"})}send(method,params){const rid=NextId++;return new Promise(((resolve,reject)=>{const payload=JSON.stringify({method:method,params:params,id:rid,jsonrpc:"2.0"});this.emit("debug",{action:"request",request:JSON.parse(payload),provider:this}),this._requests[String(rid)]={callback:function(error,result){return error?reject(error):resolve(result)},payload:payload},this._wsReady&&this.websocket.send(payload)}))}static defaultUrl(){return"ws://localhost:8546"}_subscribe(tag,param,processFunc){return __awaiter(this,void 0,void 0,(function*(){let subIdPromise=this._subIds[tag];null==subIdPromise&&(subIdPromise=Promise.all(param).then((param=>this.send("eth_subscribe",param))),this._subIds[tag]=subIdPromise);const subId=yield subIdPromise;this._subs[subId]={tag:tag,processFunc:processFunc}}))}_startEvent(event){switch(event.type){case"block":this._subscribe("block",["newHeads"],(result=>{const blockNumber=BigNumber.from(result.number).toNumber();this._emitted.block=blockNumber,this.emit("block",blockNumber)}));break;case"pending":this._subscribe("pending",["newPendingTransactions"],(result=>{this.emit("pending",result)}));break;case"filter":this._subscribe(event.tag,["logs",this._getFilter(event.filter)],(result=>{null==result.removed&&(result.removed=!1),this.emit(event.filter,this.formatter.filterLog(result))}));break;case"tx":{const emitReceipt=event=>{const hash=event.hash;this.getTransactionReceipt(hash).then((receipt=>{receipt&&this.emit(hash,receipt)}))};emitReceipt(event),this._subscribe("tx",["newHeads"],(result=>{this._events.filter((e=>"tx"===e.type)).forEach(emitReceipt)}));break}case"debug":case"poll":case"willPoll":case"didPoll":case"error":break;default:console.log("unhandled:",event)}}_stopEvent(event){let tag=event.tag;if("tx"===event.type){if(this._events.filter((e=>"tx"===e.type)).length)return;tag="tx"}else if(this.listenerCount(event.event))return;const subId=this._subIds[tag];subId&&(delete this._subIds[tag],subId.then((subId=>{this._subs[subId]&&(delete this._subs[subId],this.send("eth_unsubscribe",[subId]))})))}destroy(){return __awaiter(this,void 0,void 0,(function*(){this.websocket.readyState===WebSocket.CONNECTING&&(yield new Promise((resolve=>{this.websocket.onopen=function(){resolve(!0)},this.websocket.onerror=function(){resolve(!1)}}))),this.websocket.close(1e3)}))}}