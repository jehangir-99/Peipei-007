import{concat,hexlify}from"@ethersproject/bytes";import{toUtf8Bytes,toUtf8String}from"@ethersproject/strings";import{keccak256}from"@ethersproject/keccak256";import{Logger}from"@ethersproject/logger";import{version}from"./_version";const logger=new Logger(version);import{ens_normalize}from"./ens-normalize/lib";const Zeros=new Uint8Array(32);function checkComponent(comp){if(0===comp.length)throw new Error("invalid ENS name; empty component");return comp}function ensNameSplit(name){const bytes=toUtf8Bytes(ens_normalize(name)),comps=[];if(0===name.length)return comps;let last=0;for(let i=0;i<bytes.length;i++){46===bytes[i]&&(comps.push(checkComponent(bytes.slice(last,i))),last=i+1)}if(last>=bytes.length)throw new Error("invalid ENS name; empty component");return comps.push(checkComponent(bytes.slice(last))),comps}Zeros.fill(0);export function ensNormalize(name){return ensNameSplit(name).map((comp=>toUtf8String(comp))).join(".")}export function isValidName(name){try{return 0!==ensNameSplit(name).length}catch(error){}return!1}export function namehash(name){"string"!=typeof name&&logger.throwArgumentError("invalid ENS name; not a string","name",name);let result=Zeros;const comps=ensNameSplit(name);for(;comps.length;)result=keccak256(concat([result,keccak256(comps.pop())]));return hexlify(result)}export function dnsEncode(name){return hexlify(concat(ensNameSplit(name).map((comp=>{if(comp.length>63)throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");const bytes=new Uint8Array(comp.length+1);return bytes.set(comp,1),bytes[0]=bytes.length-1,bytes}))))+"00"}