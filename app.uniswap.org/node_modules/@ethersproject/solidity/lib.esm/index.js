"use strict";import{BigNumber}from"@ethersproject/bignumber";import{arrayify,concat,hexlify,zeroPad}from"@ethersproject/bytes";import{keccak256 as hashKeccak256}from"@ethersproject/keccak256";import{sha256 as hashSha256}from"@ethersproject/sha2";import{toUtf8Bytes}from"@ethersproject/strings";const regexBytes=new RegExp("^bytes([0-9]+)$"),regexNumber=new RegExp("^(u?int)([0-9]*)$"),regexArray=new RegExp("^(.*)\\[([0-9]*)\\]$"),Zeros="0000000000000000000000000000000000000000000000000000000000000000";import{Logger}from"@ethersproject/logger";import{version}from"./_version";const logger=new Logger(version);function _pack(type,value,isArray){switch(type){case"address":return isArray?zeroPad(value,32):arrayify(value);case"string":return toUtf8Bytes(value);case"bytes":return arrayify(value);case"bool":return value=value?"0x01":"0x00",isArray?zeroPad(value,32):arrayify(value)}let match=type.match(regexNumber);if(match){let size=parseInt(match[2]||"256");return(match[2]&&String(size)!==match[2]||size%8!=0||0===size||size>256)&&logger.throwArgumentError("invalid number type","type",type),isArray&&(size=256),value=BigNumber.from(value).toTwos(size),zeroPad(value,size/8)}if(match=type.match(regexBytes),match){const size=parseInt(match[1]);return(String(size)!==match[1]||0===size||size>32)&&logger.throwArgumentError("invalid bytes type","type",type),arrayify(value).byteLength!==size&&logger.throwArgumentError(`invalid value for ${type}`,"value",value),isArray?arrayify((value+Zeros).substring(0,66)):value}if(match=type.match(regexArray),match&&Array.isArray(value)){const baseType=match[1];parseInt(match[2]||String(value.length))!=value.length&&logger.throwArgumentError(`invalid array length for ${type}`,"value",value);const result=[];return value.forEach((function(value){result.push(_pack(baseType,value,!0))})),concat(result)}return logger.throwArgumentError("invalid type","type",type)}export function pack(types,values){types.length!=values.length&&logger.throwArgumentError("wrong number of values; expected ${ types.length }","values",values);const tight=[];return types.forEach((function(type,index){tight.push(_pack(type,values[index]))})),hexlify(concat(tight))}export function keccak256(types,values){return hashKeccak256(pack(types,values))}export function sha256(types,values){return hashSha256(pack(types,values))}