"use strict";import{arrayify,hexlify,isBytesLike}from"@ethersproject/bytes";import{Logger}from"@ethersproject/logger";import{version}from"./_version";const logger=new Logger(version);function arrayifyInteger(value){const result=[];for(;value;)result.unshift(255&value),value>>=8;return result}function unarrayifyInteger(data,offset,length){let result=0;for(let i=0;i<length;i++)result=256*result+data[offset+i];return result}function _encode(object){if(Array.isArray(object)){let payload=[];if(object.forEach((function(child){payload=payload.concat(_encode(child))})),payload.length<=55)return payload.unshift(192+payload.length),payload;const length=arrayifyInteger(payload.length);return length.unshift(247+length.length),length.concat(payload)}isBytesLike(object)||logger.throwArgumentError("RLP object must be BytesLike","object",object);const data=Array.prototype.slice.call(arrayify(object));if(1===data.length&&data[0]<=127)return data;if(data.length<=55)return data.unshift(128+data.length),data;const length=arrayifyInteger(data.length);return length.unshift(183+length.length),length.concat(data)}export function encode(object){return hexlify(_encode(object))}function _decodeChildren(data,offset,childOffset,length){const result=[];for(;childOffset<offset+1+length;){const decoded=_decode(data,childOffset);result.push(decoded.result),(childOffset+=decoded.consumed)>offset+1+length&&logger.throwError("child data too short",Logger.errors.BUFFER_OVERRUN,{})}return{consumed:1+length,result:result}}function _decode(data,offset){if(0===data.length&&logger.throwError("data too short",Logger.errors.BUFFER_OVERRUN,{}),data[offset]>=248){const lengthLength=data[offset]-247;offset+1+lengthLength>data.length&&logger.throwError("data short segment too short",Logger.errors.BUFFER_OVERRUN,{});const length=unarrayifyInteger(data,offset+1,lengthLength);return offset+1+lengthLength+length>data.length&&logger.throwError("data long segment too short",Logger.errors.BUFFER_OVERRUN,{}),_decodeChildren(data,offset,offset+1+lengthLength,lengthLength+length)}if(data[offset]>=192){const length=data[offset]-192;return offset+1+length>data.length&&logger.throwError("data array too short",Logger.errors.BUFFER_OVERRUN,{}),_decodeChildren(data,offset,offset+1,length)}if(data[offset]>=184){const lengthLength=data[offset]-183;offset+1+lengthLength>data.length&&logger.throwError("data array too short",Logger.errors.BUFFER_OVERRUN,{});const length=unarrayifyInteger(data,offset+1,lengthLength);offset+1+lengthLength+length>data.length&&logger.throwError("data array too short",Logger.errors.BUFFER_OVERRUN,{});return{consumed:1+lengthLength+length,result:hexlify(data.slice(offset+1+lengthLength,offset+1+lengthLength+length))}}if(data[offset]>=128){const length=data[offset]-128;offset+1+length>data.length&&logger.throwError("data too short",Logger.errors.BUFFER_OVERRUN,{});return{consumed:1+length,result:hexlify(data.slice(offset+1,offset+1+length))}}return{consumed:1,result:hexlify(data[offset])}}export function decode(data){const bytes=arrayify(data),decoded=_decode(bytes,0);return decoded.consumed!==bytes.length&&logger.throwArgumentError("invalid rlp data","data",data),decoded.result}