"use strict";const multibase=require("multibase"),varint=require("varint"),{names:names}=require("./constants"),uint8ArrayToString=require("uint8arrays/to-string"),uint8ArrayFromString=require("uint8arrays/from-string"),uint8ArrayConcat=require("uint8arrays/concat"),codes={};for(const key in names){const name=key;codes[names[name]]=name}function toHexString(hash){if(!(hash instanceof Uint8Array))throw new Error("must be passed a Uint8Array");return uint8ArrayToString(hash,"base16")}function fromHexString(hash){return uint8ArrayFromString(hash,"base16")}function toB58String(hash){if(!(hash instanceof Uint8Array))throw new Error("must be passed a Uint8Array");return uint8ArrayToString(multibase.encode("base58btc",hash)).slice(1)}function fromB58String(hash){const encoded=hash instanceof Uint8Array?uint8ArrayToString(hash):hash;return multibase.decode("z"+encoded)}function decode(bytes){if(!(bytes instanceof Uint8Array))throw new Error("multihash must be a Uint8Array");if(bytes.length<2)throw new Error("multihash too short. must be > 2 bytes.");const code=varint.decode(bytes);if(!isValidCode(code))throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);bytes=bytes.slice(varint.decode.bytes);const len=varint.decode(bytes);if(len<0)throw new Error(`multihash invalid length: ${len}`);if((bytes=bytes.slice(varint.decode.bytes)).length!==len)throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes,"base16")}`);return{code:code,name:codes[code],length:len,digest:bytes}}function encode(digest,code,length){if(!digest||void 0===code)throw new Error("multihash encode requires at least two args: digest, code");const hashfn=coerceCode(code);if(!(digest instanceof Uint8Array))throw new Error("digest should be a Uint8Array");if(null==length&&(length=digest.length),length&&digest.length!==length)throw new Error("digest length should be equal to specified length.");const hash=varint.encode(hashfn),len=varint.encode(length);return uint8ArrayConcat([hash,len,digest],hash.length+len.length+digest.length)}function coerceCode(name){let code=name;if("string"==typeof name){if(void 0===names[name])throw new Error(`Unrecognized hash function named: ${name}`);code=names[name]}if("number"!=typeof code)throw new Error(`Hash function code should be a number. Got: ${code}`);if(void 0===codes[code]&&!isAppCode(code))throw new Error(`Unrecognized function code: ${code}`);return code}function isAppCode(code){return code>0&&code<16}function isValidCode(code){return!!isAppCode(code)||!!codes[code]}function validate(multihash){decode(multihash)}function prefix(multihash){return validate(multihash),multihash.subarray(0,2)}Object.freeze(codes),module.exports={names:names,codes:codes,toHexString:toHexString,fromHexString:fromHexString,toB58String:toB58String,fromB58String:fromB58String,decode:decode,encode:encode,coerceCode:coerceCode,isAppCode:isAppCode,validate:validate,prefix:prefix,isValidCode:isValidCode};