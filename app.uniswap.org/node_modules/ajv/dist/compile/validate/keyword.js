"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.validateKeywordUsage=exports.validSchemaType=exports.funcKeywordCode=exports.macroKeywordCode=void 0;const codegen_1=require("../codegen"),names_1=require("../names"),code_1=require("../../vocabularies/code"),errors_1=require("../errors");function macroKeywordCode(cxt,def){const{gen:gen,keyword:keyword,schema:schema,parentSchema:parentSchema,it:it}=cxt,macroSchema=def.macro.call(it.self,schema,parentSchema,it),schemaRef=useKeyword(gen,keyword,macroSchema);!1!==it.opts.validateSchema&&it.self.validateSchema(macroSchema,!0);const valid=gen.name("valid");cxt.subschema({schema:macroSchema,schemaPath:codegen_1.nil,errSchemaPath:`${it.errSchemaPath}/${keyword}`,topSchemaRef:schemaRef,compositeRule:!0},valid),cxt.pass(valid,(()=>cxt.error(!0)))}function funcKeywordCode(cxt,def){var _a;const{gen:gen,keyword:keyword,schema:schema,parentSchema:parentSchema,$data:$data,it:it}=cxt;checkAsyncKeyword(it,def);const validate=!$data&&def.compile?def.compile.call(it.self,schema,parentSchema,it):def.validate,validateRef=useKeyword(gen,keyword,validate),valid=gen.let("valid");function assignValid(_await=(def.async?codegen_1._`await `:codegen_1.nil)){const passCxt=it.opts.passContext?names_1.default.this:names_1.default.self,passSchema=!("compile"in def&&!$data||!1===def.schema);gen.assign(valid,codegen_1._`${_await}${(0,code_1.callValidateCode)(cxt,validateRef,passCxt,passSchema)}`,def.modifying)}function reportErrs(errors){var _a;gen.if((0,codegen_1.not)(null!==(_a=def.valid)&&void 0!==_a?_a:valid),errors)}cxt.block$data(valid,(function(){if(!1===def.errors)assignValid(),def.modifying&&modifyData(cxt),reportErrs((()=>cxt.error()));else{const ruleErrs=def.async?function(){const ruleErrs=gen.let("ruleErrs",null);return gen.try((()=>assignValid(codegen_1._`await `)),(e=>gen.assign(valid,!1).if(codegen_1._`${e} instanceof ${it.ValidationError}`,(()=>gen.assign(ruleErrs,codegen_1._`${e}.errors`)),(()=>gen.throw(e))))),ruleErrs}():function(){const validateErrs=codegen_1._`${validateRef}.errors`;return gen.assign(validateErrs,null),assignValid(codegen_1.nil),validateErrs}();def.modifying&&modifyData(cxt),reportErrs((()=>addErrs(cxt,ruleErrs)))}})),cxt.ok(null!==(_a=def.valid)&&void 0!==_a?_a:valid)}function modifyData(cxt){const{gen:gen,data:data,it:it}=cxt;gen.if(it.parentData,(()=>gen.assign(data,codegen_1._`${it.parentData}[${it.parentDataProperty}]`)))}function addErrs(cxt,errs){const{gen:gen}=cxt;gen.if(codegen_1._`Array.isArray(${errs})`,(()=>{gen.assign(names_1.default.vErrors,codegen_1._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors,codegen_1._`${names_1.default.vErrors}.length`),(0,errors_1.extendErrors)(cxt)}),(()=>cxt.error()))}function checkAsyncKeyword({schemaEnv:schemaEnv},def){if(def.async&&!schemaEnv.$async)throw new Error("async keyword in sync schema")}function useKeyword(gen,keyword,result){if(void 0===result)throw new Error(`keyword "${keyword}" failed to compile`);return gen.scopeValue("keyword","function"==typeof result?{ref:result}:{ref:result,code:(0,codegen_1.stringify)(result)})}function validSchemaType(schema,schemaType,allowUndefined=!1){return!schemaType.length||schemaType.some((st=>"array"===st?Array.isArray(schema):"object"===st?schema&&"object"==typeof schema&&!Array.isArray(schema):typeof schema==st||allowUndefined&&void 0===schema))}function validateKeywordUsage({schema:schema,opts:opts,self:self,errSchemaPath:errSchemaPath},def,keyword){if(Array.isArray(def.keyword)?!def.keyword.includes(keyword):def.keyword!==keyword)throw new Error("ajv implementation error");const deps=def.dependencies;if(null==deps?void 0:deps.some((kwd=>!Object.prototype.hasOwnProperty.call(schema,kwd))))throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);if(def.validateSchema){if(!def.validateSchema(schema[keyword])){const msg=`keyword "${keyword}" value is invalid at path "${errSchemaPath}": `+self.errorsText(def.validateSchema.errors);if("log"!==opts.validateSchema)throw new Error(msg);self.logger.error(msg)}}}exports.macroKeywordCode=macroKeywordCode,exports.funcKeywordCode=funcKeywordCode,exports.validSchemaType=validSchemaType,exports.validateKeywordUsage=validateKeywordUsage;