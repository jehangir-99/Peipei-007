"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const codegen_1=require("../../compile/codegen"),util_1=require("../../compile/util"),error={message:"must match exactly one schema in oneOf",params:({params:params})=>codegen_1._`{passingSchemas: ${params.passing}}`},def={keyword:"oneOf",schemaType:"array",trackErrors:!0,error:error,code(cxt){const{gen:gen,schema:schema,parentSchema:parentSchema,it:it}=cxt;if(!Array.isArray(schema))throw new Error("ajv implementation error");if(it.opts.discriminator&&parentSchema.discriminator)return;const schArr=schema,valid=gen.let("valid",!1),passing=gen.let("passing",null),schValid=gen.name("_valid");cxt.setParams({passing:passing}),gen.block((function(){schArr.forEach(((sch,i)=>{let schCxt;(0,util_1.alwaysValidSchema)(it,sch)?gen.var(schValid,!0):schCxt=cxt.subschema({keyword:"oneOf",schemaProp:i,compositeRule:!0},schValid),i>0&&gen.if(codegen_1._`${schValid} && ${valid}`).assign(valid,!1).assign(passing,codegen_1._`[${passing}, ${i}]`).else(),gen.if(schValid,(()=>{gen.assign(valid,!0),gen.assign(passing,i),schCxt&&cxt.mergeEvaluated(schCxt,codegen_1.Name)}))}))})),cxt.result(valid,(()=>cxt.reset()),(()=>cxt.error(!0)))}};exports.default=def;