"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.validateTuple=void 0;const codegen_1=require("../../compile/codegen"),util_1=require("../../compile/util"),code_1=require("../code"),def={keyword:"items",type:"array",schemaType:["object","array","boolean"],before:"uniqueItems",code(cxt){const{schema:schema,it:it}=cxt;if(Array.isArray(schema))return validateTuple(cxt,"additionalItems",schema);it.items=!0,(0,util_1.alwaysValidSchema)(it,schema)||cxt.ok((0,code_1.validateArray)(cxt))}};function validateTuple(cxt,extraItems,schArr=cxt.schema){const{gen:gen,parentSchema:parentSchema,data:data,keyword:keyword,it:it}=cxt;!function(sch){const{opts:opts,errSchemaPath:errSchemaPath}=it,l=schArr.length,fullTuple=l===sch.minItems&&(l===sch.maxItems||!1===sch[extraItems]);if(opts.strictTuples&&!fullTuple){const msg=`"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;(0,util_1.checkStrictMode)(it,msg,opts.strictTuples)}}(parentSchema),it.opts.unevaluated&&schArr.length&&!0!==it.items&&(it.items=util_1.mergeEvaluated.items(gen,schArr.length,it.items));const valid=gen.name("valid"),len=gen.const("len",codegen_1._`${data}.length`);schArr.forEach(((sch,i)=>{(0,util_1.alwaysValidSchema)(it,sch)||(gen.if(codegen_1._`${len} > ${i}`,(()=>cxt.subschema({keyword:keyword,schemaProp:i,dataProp:i},valid))),cxt.ok(valid))}))}exports.validateTuple=validateTuple,exports.default=def;